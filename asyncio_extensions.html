<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>server.asyncio_extensions API documentation</title>
<meta name="description" content="Some helper functions for common async tasks" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>server.asyncio_extensions</code></h1>
</header>
<section id="section-intro">
<p>Some helper functions for common async tasks</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Some helper functions for common async tasks
&#34;&#34;&#34;

import asyncio
import inspect
import logging
from asyncio.locks import _ContextManagerMixin
from functools import wraps
from typing import (
    Any,
    AsyncContextManager,
    Callable,
    Coroutine,
    Iterable,
    Optional,
    Protocol,
    TypeVar,
    cast,
    overload
)

logger = logging.getLogger(__name__)

AsyncFunc = Callable[..., Coroutine[Any, Any, Any]]
AsyncDecorator = Callable[[AsyncFunc], AsyncFunc]
T = TypeVar(&#34;T&#34;)


class AsyncLock(Protocol, AsyncContextManager[&#34;AsyncLock&#34;]):
    def locked(self) -&gt; bool: ...
    async def acquire(self) -&gt; bool: ...
    def release(self) -&gt; None: ...


async def map_suppress(
    func: Callable[[T], Coroutine[Any, Any, Any]],
    iterable: Iterable[T],
    logger: logging.Logger = logger,
    msg: str = &#34;&#34;
):
    results = await asyncio.gather(
        *(func(item) for item in iterable),
        return_exceptions=True
    )
    for result, item in zip(results, iterable):
        if isinstance(result, BaseException):
            logger.exception(
                &#34;Unexpected error %s%s&#34;,
                msg,
                item,
                exc_info=result
            )


# Based on python3.8 asyncio.Lock
# https://github.com/python/cpython/blob/6c6c256df3636ff6f6136820afaefa5a10a3ac33/Lib/asyncio/locks.py#L106
class SpinLock(_ContextManagerMixin):
    &#34;&#34;&#34;
    An asyncio spinlock. The advantage of using this over asyncio.Lock is that
    it can be called accross multiple event loops at the cost of being less
    performant. As with any spinlock, it&#39;s best used in situations where
    concurrent access is unlikely.
    &#34;&#34;&#34;

    def __init__(self, sleep_duration: float = 0.01):
        self.sleep_duration = sleep_duration
        self._locked = False

    def __repr__(self) -&gt; str:
        res = super().__repr__()
        extra = &#34;locked&#34; if self._locked else &#34;unlocked&#34;
        return f&#34;&lt;{res[1:-1]} [{extra}]&gt;&#34;

    def locked(self) -&gt; bool:
        &#34;&#34;&#34;Return True if lock is acquired.&#34;&#34;&#34;
        return self._locked

    async def acquire(self) -&gt; bool:
        &#34;&#34;&#34;
        Sleeps repeatedly for sleep_duration until the lock is unlocked, then
        sets it to locked and returns True.
        &#34;&#34;&#34;
        while self._locked:
            await asyncio.sleep(self.sleep_duration)

        self._locked = True
        return True

    def release(self) -&gt; None:
        &#34;&#34;&#34;
        When invoked on an unlocked lock, a RuntimeError is raised.
        &#34;&#34;&#34;
        if self._locked:
            self._locked = False
        else:
            raise RuntimeError(&#34;Lock is not acquired.&#34;)


class _partial(object):
    &#34;&#34;&#34;
    Like functools.partial but applies arguments to the end.

    # Example:
    ```
    def foo(arg1, arg2):
        print(arg1, arg2)

    new = _partial(foo, &#34;partially_applied&#34;)
    new(&#34;bar&#34;)
    # bar partially_applied
    ```
    &#34;&#34;&#34;

    def __init__(self, func, *args):
        self.func = func
        self.args = args

    def __call__(self, *args):
        return self.func(*args, *self.args)


@overload
def synchronized() -&gt; AsyncDecorator: ...
@overload
def synchronized(function: AsyncFunc) -&gt; AsyncFunc: ...
@overload
def synchronized(lock: Optional[AsyncLock]) -&gt; AsyncDecorator: ...


def synchronized(*args):
    &#34;&#34;&#34;
    Ensure that a function will only execute in serial.

    # Params
    - `lock`: An instance of asyncio.Lock to use for synchronization.
    &#34;&#34;&#34;
    # Invoked like @synchronized
    if args and inspect.isfunction(args[0]):
        return _synchronize(args[0])

    # Invoked like @synchronized() or @synchronized(args, ...)
    return _partial(_synchronize, *args)


def _synchronize(
    function: AsyncFunc,
    lock: Optional[AsyncLock] = None
) -&gt; AsyncFunc:
    &#34;&#34;&#34;Wrap an async function with an async lock.&#34;&#34;&#34;
    @wraps(function)
    async def wrapped(*args, **kwargs):
        nonlocal lock

        if lock is None:
            lock = lock or cast(AsyncLock, asyncio.Lock())

        async with lock:
            return await function(*args, **kwargs)

    return wrapped


@overload
def synchronizedmethod() -&gt; AsyncDecorator: ...
@overload
def synchronizedmethod(function: AsyncFunc) -&gt; AsyncFunc: ...
@overload
def synchronizedmethod(lock_name: Optional[str]) -&gt; AsyncDecorator: ...


def synchronizedmethod(*args):
    &#34;&#34;&#34;
    Create a method that will be wrapped with an async lock.

    # Params
    - `attrname`: The name of the lock attribute that will be used. If the
        attribute doesn&#39;t exist or is None, a lock will be created. The default
        is to use a value based on the decorated function name.
    &#34;&#34;&#34;
    # Invoked like @synchronizedmethod
    if args and inspect.isfunction(args[0]):
        return _synchronize_method(args[0])

    # Invoked like @synchronizedmethod() or @synchronizedmethod(args, ...)
    return _partial(_synchronize_method, *args)


def _synchronize_method(
    function: AsyncFunc,
    lock_name: Optional[str] = None
) -&gt; AsyncFunc:
    &#34;&#34;&#34;Wrap an async method with an async lock stored on the instance.&#34;&#34;&#34;
    if lock_name is None:
        lock_name = f&#34;#{function.__name__}_lock&#34;

    @wraps(function)
    async def wrapped(obj, *args, **kwargs):
        lock = getattr(obj, lock_name, None)
        if lock is None:
            lock = asyncio.Lock()
            setattr(obj, lock_name, lock)

        async with lock:
            return await function(obj, *args, **kwargs)

    return wrapped</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="server.asyncio_extensions.map_suppress"><code class="name flex">
<span>async def <span class="ident">map_suppress</span></span>(<span>func: Callable[[~T], Coroutine[Any, Any, Any]], iterable: Iterable[~T], logger: logging.Logger = &lt;Logger server.asyncio_extensions (WARNING)&gt;, msg: str = '')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def map_suppress(
    func: Callable[[T], Coroutine[Any, Any, Any]],
    iterable: Iterable[T],
    logger: logging.Logger = logger,
    msg: str = &#34;&#34;
):
    results = await asyncio.gather(
        *(func(item) for item in iterable),
        return_exceptions=True
    )
    for result, item in zip(results, iterable):
        if isinstance(result, BaseException):
            logger.exception(
                &#34;Unexpected error %s%s&#34;,
                msg,
                item,
                exc_info=result
            )</code></pre>
</details>
</dd>
<dt id="server.asyncio_extensions.synchronized"><code class="name flex">
<span>def <span class="ident">synchronized</span></span>(<span>*args)</span>
</code></dt>
<dd>
<div class="desc"><p>Ensure that a function will only execute in serial.</p>
<h1 id="params">Params</h1>
<ul>
<li><code>lock</code>: An instance of asyncio.Lock to use for synchronization.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def synchronized(*args):
    &#34;&#34;&#34;
    Ensure that a function will only execute in serial.

    # Params
    - `lock`: An instance of asyncio.Lock to use for synchronization.
    &#34;&#34;&#34;
    # Invoked like @synchronized
    if args and inspect.isfunction(args[0]):
        return _synchronize(args[0])

    # Invoked like @synchronized() or @synchronized(args, ...)
    return _partial(_synchronize, *args)</code></pre>
</details>
</dd>
<dt id="server.asyncio_extensions.synchronizedmethod"><code class="name flex">
<span>def <span class="ident">synchronizedmethod</span></span>(<span>*args)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a method that will be wrapped with an async lock.</p>
<h1 id="params">Params</h1>
<ul>
<li><code>attrname</code>: The name of the lock attribute that will be used. If the
attribute doesn't exist or is None, a lock will be created. The default
is to use a value based on the decorated function name.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def synchronizedmethod(*args):
    &#34;&#34;&#34;
    Create a method that will be wrapped with an async lock.

    # Params
    - `attrname`: The name of the lock attribute that will be used. If the
        attribute doesn&#39;t exist or is None, a lock will be created. The default
        is to use a value based on the decorated function name.
    &#34;&#34;&#34;
    # Invoked like @synchronizedmethod
    if args and inspect.isfunction(args[0]):
        return _synchronize_method(args[0])

    # Invoked like @synchronizedmethod() or @synchronizedmethod(args, ...)
    return _partial(_synchronize_method, *args)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="server.asyncio_extensions.AsyncLock"><code class="flex name class">
<span>class <span class="ident">AsyncLock</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for protocol classes.</p>
<p>Protocol classes are defined as::</p>
<pre><code>class Proto(Protocol):
    def meth(self) -&gt; int:
        ...
</code></pre>
<p>Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing), for example::</p>
<pre><code>class C:
    def meth(self) -&gt; int:
        return 0

def func(x: Proto) -&gt; int:
    return x.meth()

func(C())  # Passes static type check
</code></pre>
<p>See PEP 544 for details. Protocol classes decorated with
@typing.runtime_checkable act as simple-minded runtime protocols that check
only the presence of given attributes, ignoring their type signatures.
Protocol classes can be generic, they are defined as::</p>
<pre><code>class GenProto(Protocol[T]):
    def meth(self) -&gt; T:
        ...
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AsyncLock(Protocol, AsyncContextManager[&#34;AsyncLock&#34;]):
    def locked(self) -&gt; bool: ...
    async def acquire(self) -&gt; bool: ...
    def release(self) -&gt; None: ...</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Protocol</li>
<li>contextlib.AbstractAsyncContextManager</li>
<li>typing.Generic</li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="server.asyncio_extensions.AsyncLock.acquire"><code class="name flex">
<span>async def <span class="ident">acquire</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def acquire(self) -&gt; bool: ...</code></pre>
</details>
</dd>
<dt id="server.asyncio_extensions.AsyncLock.locked"><code class="name flex">
<span>def <span class="ident">locked</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def locked(self) -&gt; bool: ...</code></pre>
</details>
</dd>
<dt id="server.asyncio_extensions.AsyncLock.release"><code class="name flex">
<span>def <span class="ident">release</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def release(self) -&gt; None: ...</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="server.asyncio_extensions.SpinLock"><code class="flex name class">
<span>class <span class="ident">SpinLock</span></span>
<span>(</span><span>sleep_duration: float = 0.01)</span>
</code></dt>
<dd>
<div class="desc"><p>An asyncio spinlock. The advantage of using this over asyncio.Lock is that
it can be called accross multiple event loops at the cost of being less
performant. As with any spinlock, it's best used in situations where
concurrent access is unlikely.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SpinLock(_ContextManagerMixin):
    &#34;&#34;&#34;
    An asyncio spinlock. The advantage of using this over asyncio.Lock is that
    it can be called accross multiple event loops at the cost of being less
    performant. As with any spinlock, it&#39;s best used in situations where
    concurrent access is unlikely.
    &#34;&#34;&#34;

    def __init__(self, sleep_duration: float = 0.01):
        self.sleep_duration = sleep_duration
        self._locked = False

    def __repr__(self) -&gt; str:
        res = super().__repr__()
        extra = &#34;locked&#34; if self._locked else &#34;unlocked&#34;
        return f&#34;&lt;{res[1:-1]} [{extra}]&gt;&#34;

    def locked(self) -&gt; bool:
        &#34;&#34;&#34;Return True if lock is acquired.&#34;&#34;&#34;
        return self._locked

    async def acquire(self) -&gt; bool:
        &#34;&#34;&#34;
        Sleeps repeatedly for sleep_duration until the lock is unlocked, then
        sets it to locked and returns True.
        &#34;&#34;&#34;
        while self._locked:
            await asyncio.sleep(self.sleep_duration)

        self._locked = True
        return True

    def release(self) -&gt; None:
        &#34;&#34;&#34;
        When invoked on an unlocked lock, a RuntimeError is raised.
        &#34;&#34;&#34;
        if self._locked:
            self._locked = False
        else:
            raise RuntimeError(&#34;Lock is not acquired.&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>asyncio.locks._ContextManagerMixin</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="server.asyncio_extensions.SpinLock.acquire"><code class="name flex">
<span>async def <span class="ident">acquire</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Sleeps repeatedly for sleep_duration until the lock is unlocked, then
sets it to locked and returns True.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def acquire(self) -&gt; bool:
    &#34;&#34;&#34;
    Sleeps repeatedly for sleep_duration until the lock is unlocked, then
    sets it to locked and returns True.
    &#34;&#34;&#34;
    while self._locked:
        await asyncio.sleep(self.sleep_duration)

    self._locked = True
    return True</code></pre>
</details>
</dd>
<dt id="server.asyncio_extensions.SpinLock.locked"><code class="name flex">
<span>def <span class="ident">locked</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Return True if lock is acquired.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def locked(self) -&gt; bool:
    &#34;&#34;&#34;Return True if lock is acquired.&#34;&#34;&#34;
    return self._locked</code></pre>
</details>
</dd>
<dt id="server.asyncio_extensions.SpinLock.release"><code class="name flex">
<span>def <span class="ident">release</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>When invoked on an unlocked lock, a RuntimeError is raised.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def release(self) -&gt; None:
    &#34;&#34;&#34;
    When invoked on an unlocked lock, a RuntimeError is raised.
    &#34;&#34;&#34;
    if self._locked:
        self._locked = False
    else:
        raise RuntimeError(&#34;Lock is not acquired.&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="server" href="index.html">server</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="server.asyncio_extensions.map_suppress" href="#server.asyncio_extensions.map_suppress">map_suppress</a></code></li>
<li><code><a title="server.asyncio_extensions.synchronized" href="#server.asyncio_extensions.synchronized">synchronized</a></code></li>
<li><code><a title="server.asyncio_extensions.synchronizedmethod" href="#server.asyncio_extensions.synchronizedmethod">synchronizedmethod</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="server.asyncio_extensions.AsyncLock" href="#server.asyncio_extensions.AsyncLock">AsyncLock</a></code></h4>
<ul class="">
<li><code><a title="server.asyncio_extensions.AsyncLock.acquire" href="#server.asyncio_extensions.AsyncLock.acquire">acquire</a></code></li>
<li><code><a title="server.asyncio_extensions.AsyncLock.locked" href="#server.asyncio_extensions.AsyncLock.locked">locked</a></code></li>
<li><code><a title="server.asyncio_extensions.AsyncLock.release" href="#server.asyncio_extensions.AsyncLock.release">release</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="server.asyncio_extensions.SpinLock" href="#server.asyncio_extensions.SpinLock">SpinLock</a></code></h4>
<ul class="">
<li><code><a title="server.asyncio_extensions.SpinLock.acquire" href="#server.asyncio_extensions.SpinLock.acquire">acquire</a></code></li>
<li><code><a title="server.asyncio_extensions.SpinLock.locked" href="#server.asyncio_extensions.SpinLock.locked">locked</a></code></li>
<li><code><a title="server.asyncio_extensions.SpinLock.release" href="#server.asyncio_extensions.SpinLock.release">release</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>