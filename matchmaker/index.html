<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>server.matchmaker API documentation</title>
<meta name="description" content="The matchmaker system …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>server.matchmaker</code></h1>
</header>
<section id="section-intro">
<p>The matchmaker system</p>
<p>Used for keeping track of queues of players wanting to play specific kinds of
games, currently just used for 1v1 <code>ladder</code>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
The matchmaker system

Used for keeping track of queues of players wanting to play specific kinds of
games, currently just used for 1v1 ``ladder``.
&#34;&#34;&#34;
from .map_pool import MapPool
from .matchmaker_queue import MatchmakerQueue
from .pop_timer import PopTimer
from .search import CombinedSearch, OnMatchedCallback, Search

__all__ = (
    &#34;CombinedSearch&#34;,
    &#34;MapPool&#34;,
    &#34;MatchmakerQueue&#34;,
    &#34;OnMatchedCallback&#34;,
    &#34;PopTimer&#34;,
    &#34;Search&#34;,
)</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="server.matchmaker.algorithm" href="algorithm/index.html">server.matchmaker.algorithm</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="server.matchmaker.map_pool" href="map_pool.html">server.matchmaker.map_pool</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="server.matchmaker.matchmaker_queue" href="matchmaker_queue.html">server.matchmaker.matchmaker_queue</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="server.matchmaker.pop_timer" href="pop_timer.html">server.matchmaker.pop_timer</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="server.matchmaker.search" href="search.html">server.matchmaker.search</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="server.matchmaker.CombinedSearch"><code class="flex name class">
<span>class <span class="ident">CombinedSearch</span></span>
<span>(</span><span>*searches: <a title="server.matchmaker.search.Search" href="search.html#server.matchmaker.search.Search">Search</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents the state of a users search for a match.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CombinedSearch(Search):
    def __init__(self, *searches: Search):
        assert searches
        rating_type = searches[0].rating_type
        assert all(map(lambda s: s.rating_type == rating_type, searches))

        self.rating_type = rating_type
        self.searches = searches

    @property
    def players(self) -&gt; list[Player]:
        return list(itertools.chain(*[s.players for s in self.searches]))

    @property
    def ratings(self) -&gt; list[Rating]:
        return list(itertools.chain(*[s.ratings for s in self.searches]))

    @property
    def cumulative_rating(self) -&gt; float:
        return sum(s.cumulative_rating for s in self.searches)

    @property
    def average_rating(self) -&gt; float:
        return get_average_rating(self.searches)

    @property
    def raw_ratings(self) -&gt; list[Rating]:
        return list(itertools.chain(*[s.raw_ratings for s in self.searches]))

    @property
    def displayed_ratings(self) -&gt; list[float]:
        return list(itertools.chain(*[s.displayed_ratings for s in self.searches]))

    @property
    def failed_matching_attempts(self) -&gt; int:
        return max(search.failed_matching_attempts for search in self.searches)

    def register_failed_matching_attempt(self):
        for search in self.searches:
            search.register_failed_matching_attempt()

    @property
    def match_threshold(self) -&gt; float:
        &#34;&#34;&#34;
        Defines the threshold for game quality
        &#34;&#34;&#34;
        return min(s.match_threshold for s in self.searches)

    @property
    def is_matched(self) -&gt; bool:
        return all(s.is_matched for s in self.searches)

    def done(self) -&gt; bool:
        return all(s.done() for s in self.searches)

    @property
    def is_cancelled(self) -&gt; bool:
        return any(s.is_cancelled for s in self.searches)

    def match(self, other: &#34;Search&#34;):
        &#34;&#34;&#34;
        Mark as matched with given opponent
        &#34;&#34;&#34;
        self._logger.info(&#34;Combined search matched %s with %s&#34;, self.players, other.players)

        for s in self.searches:
            s.match(other)

    async def await_match(self):
        &#34;&#34;&#34;
        Wait for this search to complete
        &#34;&#34;&#34;
        await asyncio.wait({s.await_match() for s in self.searches})

    def cancel(self):
        &#34;&#34;&#34;
        Cancel searching for a match
        &#34;&#34;&#34;
        for s in self.searches:
            s.cancel()

    def __str__(self):
        return f&#34;CombinedSearch({&#39;, &#39;.join(str(s) for s in self.searches)})&#34;

    def __repr__(self):
        return f&#34;CombinedSearch({&#39;, &#39;.join(str(s) for s in self.searches)})&#34;

    def get_original_searches(self) -&gt; list[Search]:
        &#34;&#34;&#34;
        Returns the searches of which this CombinedSearch is comprised
        &#34;&#34;&#34;
        return list(self.searches)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="server.matchmaker.search.Search" href="search.html#server.matchmaker.search.Search">Search</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="server.matchmaker.CombinedSearch.average_rating"><code class="name">var <span class="ident">average_rating</span> : float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def average_rating(self) -&gt; float:
    return get_average_rating(self.searches)</code></pre>
</details>
</dd>
<dt id="server.matchmaker.CombinedSearch.cumulative_rating"><code class="name">var <span class="ident">cumulative_rating</span> : float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cumulative_rating(self) -&gt; float:
    return sum(s.cumulative_rating for s in self.searches)</code></pre>
</details>
</dd>
<dt id="server.matchmaker.CombinedSearch.failed_matching_attempts"><code class="name">var <span class="ident">failed_matching_attempts</span> : int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def failed_matching_attempts(self) -&gt; int:
    return max(search.failed_matching_attempts for search in self.searches)</code></pre>
</details>
</dd>
<dt id="server.matchmaker.CombinedSearch.is_cancelled"><code class="name">var <span class="ident">is_cancelled</span> : bool</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_cancelled(self) -&gt; bool:
    return any(s.is_cancelled for s in self.searches)</code></pre>
</details>
</dd>
<dt id="server.matchmaker.CombinedSearch.is_matched"><code class="name">var <span class="ident">is_matched</span> : bool</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_matched(self) -&gt; bool:
    return all(s.is_matched for s in self.searches)</code></pre>
</details>
</dd>
<dt id="server.matchmaker.CombinedSearch.match_threshold"><code class="name">var <span class="ident">match_threshold</span> : float</code></dt>
<dd>
<div class="desc"><p>Defines the threshold for game quality</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def match_threshold(self) -&gt; float:
    &#34;&#34;&#34;
    Defines the threshold for game quality
    &#34;&#34;&#34;
    return min(s.match_threshold for s in self.searches)</code></pre>
</details>
</dd>
<dt id="server.matchmaker.CombinedSearch.players"><code class="name">var <span class="ident">players</span> : list[<a title="server.players.Player" href="../players.html#server.players.Player">Player</a>]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def players(self) -&gt; list[Player]:
    return list(itertools.chain(*[s.players for s in self.searches]))</code></pre>
</details>
</dd>
<dt id="server.matchmaker.CombinedSearch.ratings"><code class="name">var <span class="ident">ratings</span> : list[<a title="server.rating.Rating" href="../rating.html#server.rating.Rating">Rating</a>]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ratings(self) -&gt; list[Rating]:
    return list(itertools.chain(*[s.ratings for s in self.searches]))</code></pre>
</details>
</dd>
<dt id="server.matchmaker.CombinedSearch.raw_ratings"><code class="name">var <span class="ident">raw_ratings</span> : list[<a title="server.rating.Rating" href="../rating.html#server.rating.Rating">Rating</a>]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def raw_ratings(self) -&gt; list[Rating]:
    return list(itertools.chain(*[s.raw_ratings for s in self.searches]))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="server.matchmaker.CombinedSearch.done"><code class="name flex">
<span>def <span class="ident">done</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def done(self) -&gt; bool:
    return all(s.done() for s in self.searches)</code></pre>
</details>
</dd>
<dt id="server.matchmaker.CombinedSearch.get_original_searches"><code class="name flex">
<span>def <span class="ident">get_original_searches</span></span>(<span>self) ‑> list[<a title="server.matchmaker.search.Search" href="search.html#server.matchmaker.search.Search">Search</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the searches of which this CombinedSearch is comprised</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_original_searches(self) -&gt; list[Search]:
    &#34;&#34;&#34;
    Returns the searches of which this CombinedSearch is comprised
    &#34;&#34;&#34;
    return list(self.searches)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="server.matchmaker.search.Search" href="search.html#server.matchmaker.search.Search">Search</a></b></code>:
<ul class="hlist">
<li><code><a title="server.matchmaker.search.Search.adjusted_rating" href="search.html#server.matchmaker.search.Search.adjusted_rating">adjusted_rating</a></code></li>
<li><code><a title="server.matchmaker.search.Search.await_match" href="search.html#server.matchmaker.search.Search.await_match">await_match</a></code></li>
<li><code><a title="server.matchmaker.search.Search.boundary_75" href="search.html#server.matchmaker.search.Search.boundary_75">boundary_75</a></code></li>
<li><code><a title="server.matchmaker.search.Search.boundary_80" href="search.html#server.matchmaker.search.Search.boundary_80">boundary_80</a></code></li>
<li><code><a title="server.matchmaker.search.Search.cancel" href="search.html#server.matchmaker.search.Search.cancel">cancel</a></code></li>
<li><code><a title="server.matchmaker.search.Search.displayed_ratings" href="search.html#server.matchmaker.search.Search.displayed_ratings">displayed_ratings</a></code></li>
<li><code><a title="server.matchmaker.search.Search.match" href="search.html#server.matchmaker.search.Search.match">match</a></code></li>
<li><code><a title="server.matchmaker.search.Search.matches_with" href="search.html#server.matchmaker.search.Search.matches_with">matches_with</a></code></li>
<li><code><a title="server.matchmaker.search.Search.register_failed_matching_attempt" href="search.html#server.matchmaker.search.Search.register_failed_matching_attempt">register_failed_matching_attempt</a></code></li>
<li><code><a title="server.matchmaker.search.Search.search_expansion" href="search.html#server.matchmaker.search.Search.search_expansion">search_expansion</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="server.matchmaker.MapPool"><code class="flex name class">
<span>class <span class="ident">MapPool</span></span>
<span>(</span><span>map_pool_id: int, name: str, maps: Iterable[<a title="server.types.MapPoolMap" href="../types.html#server.types.MapPoolMap">MapPoolMap</a>] = ())</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@with_logger
class MapPool(object):
    def __init__(
        self,
        map_pool_id: int,
        name: str,
        maps: Iterable[MapPoolMap] = ()
    ):
        self.id = map_pool_id
        self.name = name
        self.set_maps(maps)

    def set_maps(self, maps: Iterable[MapPoolMap]) -&gt; None:
        self.maps = {map_.id: map_ for map_ in maps}

    def choose_map(self, played_map_ids: Iterable[int] = ()) -&gt; Map:
        &#34;&#34;&#34;
        Select a random map who&#39;s id does not appear in `played_map_ids`. If
        all map ids appear in the list, then pick one that appears the least
        amount of times.
        &#34;&#34;&#34;
        if not self.maps:
            self._logger.critical(
                &#34;Trying to choose a map from an empty map pool: %s&#34;, self.name
            )
            raise RuntimeError(f&#34;Map pool {self.name} not set!&#34;)

        # Make sure the counter has every available map
        counter = Counter(self.maps.keys())
        counter.update(id_ for id_ in played_map_ids if id_ in self.maps)

        least_common = counter.most_common()[::-1]
        least_count = 1
        for id_, count in least_common:
            if isinstance(self.maps[id_], Map):
                least_count = count
                break

        # Trim off the maps with higher play counts
        for i, (_, count) in enumerate(least_common):
            if count &gt; least_count:
                least_common = least_common[:i]
                break

        weights = [self.maps[id_].weight for id_, _ in least_common]

        map_id = random.choices(least_common, weights=weights, k=1)[0][0]
        return self.maps[map_id].get_map()

    def __repr__(self) -&gt; str:
        return f&#34;MapPool({self.id}, {self.name}, {list(self.maps.values())})&#34;</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="server.matchmaker.MapPool.choose_map"><code class="name flex">
<span>def <span class="ident">choose_map</span></span>(<span>self, played_map_ids: Iterable[int] = ()) ‑> <a title="server.types.Map" href="../types.html#server.types.Map">Map</a></span>
</code></dt>
<dd>
<div class="desc"><p>Select a random map who's id does not appear in <code>played_map_ids</code>. If
all map ids appear in the list, then pick one that appears the least
amount of times.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def choose_map(self, played_map_ids: Iterable[int] = ()) -&gt; Map:
    &#34;&#34;&#34;
    Select a random map who&#39;s id does not appear in `played_map_ids`. If
    all map ids appear in the list, then pick one that appears the least
    amount of times.
    &#34;&#34;&#34;
    if not self.maps:
        self._logger.critical(
            &#34;Trying to choose a map from an empty map pool: %s&#34;, self.name
        )
        raise RuntimeError(f&#34;Map pool {self.name} not set!&#34;)

    # Make sure the counter has every available map
    counter = Counter(self.maps.keys())
    counter.update(id_ for id_ in played_map_ids if id_ in self.maps)

    least_common = counter.most_common()[::-1]
    least_count = 1
    for id_, count in least_common:
        if isinstance(self.maps[id_], Map):
            least_count = count
            break

    # Trim off the maps with higher play counts
    for i, (_, count) in enumerate(least_common):
        if count &gt; least_count:
            least_common = least_common[:i]
            break

    weights = [self.maps[id_].weight for id_, _ in least_common]

    map_id = random.choices(least_common, weights=weights, k=1)[0][0]
    return self.maps[map_id].get_map()</code></pre>
</details>
</dd>
<dt id="server.matchmaker.MapPool.set_maps"><code class="name flex">
<span>def <span class="ident">set_maps</span></span>(<span>self, maps: Iterable[<a title="server.types.MapPoolMap" href="../types.html#server.types.MapPoolMap">MapPoolMap</a>]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_maps(self, maps: Iterable[MapPoolMap]) -&gt; None:
    self.maps = {map_.id: map_ for map_ in maps}</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="server.matchmaker.MatchmakerQueue"><code class="flex name class">
<span>class <span class="ident">MatchmakerQueue</span></span>
<span>(</span><span>game_service: GameService, on_match_found: Callable[[<a title="server.matchmaker.search.Search" href="search.html#server.matchmaker.search.Search">Search</a>, <a title="server.matchmaker.search.Search" href="search.html#server.matchmaker.search.Search">Search</a>, ForwardRef('<a title="server.matchmaker.MatchmakerQueue" href="#server.matchmaker.MatchmakerQueue">MatchmakerQueue</a>')], Any], name: str, queue_id: int, featured_mod: str, rating_type: str, team_size: int = 1, params: Optional[dict[str, typing.Any]] = None, map_pools: Iterable[tuple[<a title="server.matchmaker.map_pool.MapPool" href="map_pool.html#server.matchmaker.map_pool.MapPool">MapPool</a>, Optional[int], Optional[int]]] = ())</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@with_logger
class MatchmakerQueue:
    def __init__(
        self,
        game_service: &#34;GameService&#34;,
        on_match_found: MatchFoundCallback,
        name: str,
        queue_id: int,
        featured_mod: str,
        rating_type: str,
        team_size: int = 1,
        params: Optional[dict[str, Any]] = None,
        map_pools: Iterable[tuple[MapPool, Optional[int], Optional[int]]] = (),
    ):
        self.game_service = game_service
        self.name = name
        self.id = queue_id
        self.featured_mod = featured_mod
        self.rating_type = rating_type
        self.team_size = team_size
        self.rating_peak = 1000.0
        self.params = params or {}
        self.map_pools = {info[0].id: info for info in map_pools}

        self._queue: dict[Search, None] = OrderedDict()
        self.on_match_found = on_match_found
        self._is_running = True

        self.timer = PopTimer(self)

        self.matchmaker = TeamMatchMaker()

    def add_map_pool(
        self,
        map_pool: MapPool,
        min_rating: Optional[int],
        max_rating: Optional[int]
    ) -&gt; None:
        self.map_pools[map_pool.id] = (map_pool, min_rating, max_rating)

    def get_map_pool_for_rating(self, rating: float) -&gt; Optional[MapPool]:
        for map_pool, min_rating, max_rating in self.map_pools.values():
            if min_rating is not None and rating &lt; min_rating:
                continue
            if max_rating is not None and rating &gt; max_rating:
                continue
            return map_pool

    def get_game_options(self) -&gt; dict[str, Any]:
        return self.params.get(&#34;GameOptions&#34;) or None

    def initialize(self):
        asyncio.create_task(self.queue_pop_timer())

    @property
    def num_players(self) -&gt; int:
        return sum(len(search.players) for search in self._queue.keys())

    async def queue_pop_timer(self) -&gt; None:
        &#34;&#34;&#34; Periodically tries to match all Searches in the queue. The amount
        of time until next queue &#39;pop&#39; is determined by the number of players
        in the queue.
        &#34;&#34;&#34;
        self._logger.debug(&#34;MatchmakerQueue initialized for %s&#34;, self.name)
        while self._is_running:
            try:
                await self.timer.next_pop()

                await self.find_matches()

                number_of_unmatched_searches = len(self._queue)
                metrics.unmatched_searches.labels(self.name).set(
                    number_of_unmatched_searches
                )

                # Any searches in the queue at this point were unable to find a
                # match this round and will have higher priority next round.

                self.game_service.mark_dirty(self)
            except asyncio.CancelledError:
                break
            except Exception:
                self._logger.exception(
                    &#34;Unexpected error during queue pop timer loop!&#34;
                )
                # To avoid potential busy loops
                await asyncio.sleep(1)
        self._logger.info(&#34;%s queue stopped&#34;, self.name)

    async def search(self, search: Search) -&gt; None:
        &#34;&#34;&#34;
        Search for a match.

        Puts a search object into the queue and awaits completion.
        &#34;&#34;&#34;
        assert search is not None

        try:
            with MatchmakerSearchTimer(self.name):
                self.push(search)
                await search.await_match()
            self._logger.debug(&#34;Search complete: %s&#34;, search)
        except CancelledError:
            pass
        finally:
            # If the queue was cancelled, or some other error occurred,
            # make sure to clean up.
            self.game_service.mark_dirty(self)
            if search in self._queue:
                del self._queue[search]

    @synchronized(SpinLock(sleep_duration=1))
    async def find_matches(self) -&gt; None:
        &#34;&#34;&#34;
        Perform the matchmaking algorithm.

        Note that this function is synchronized such that only one instance of
        MatchmakerQueue can call this function at any given time. This is
        needed in order to safely enable multiqueuing.
        &#34;&#34;&#34;
        self._logger.info(&#34;Searching for matches: %s&#34;, self.name)

        searches = list(self._queue.keys())

        if self.num_players &lt; 2 * self.team_size:
            self._register_unmatched_searches(searches)
            return

        # Call self.match on all matches and filter out the ones that were cancelled
        loop = asyncio.get_running_loop()
        proposed_matches, unmatched_searches = await loop.run_in_executor(
            None,
            self.matchmaker.find,
            searches,
            self.team_size,
            self.rating_peak,
        )

        # filter out matches that were cancelled
        matches: list[Match] = []
        for match in proposed_matches:
            if self.match(match[0], match[1]):
                matches.append(match)
            else:
                unmatched_searches.extend(match)

        self._register_unmatched_searches(unmatched_searches)

        for search1, search2 in matches:
            self._report_party_sizes(search1)
            self._report_party_sizes(search2)

            rating_imbalance = abs(search1.cumulative_rating - search2.cumulative_rating)
            metrics.match_rating_imbalance.labels(self.name).observe(rating_imbalance)

            ratings = search1.displayed_ratings + search2.displayed_ratings
            rating_variety = max(ratings) - min(ratings)
            metrics.match_rating_variety.labels(self.name).observe(rating_variety)

            metrics.match_quality.labels(self.name).observe(
                search1.quality_with(search2)
            )
            try:
                self.on_match_found(search1, search2, self)
            except Exception:
                self._logger.exception(&#34;Match callback raised an exception!&#34;)

    def _report_party_sizes(self, team):
        for search in team.get_original_searches():
            metrics.matched_matchmaker_searches.labels(
                self.name, len(search.players)
            ).inc()

    def _register_unmatched_searches(
        self,
        unmatched_searches: list[Search],
    ):
        &#34;&#34;&#34;
        Tells all unmatched searches that they went through a failed matching
        attempt.
        &#34;&#34;&#34;
        for search in unmatched_searches:
            search.register_failed_matching_attempt()
            self._logger.debug(
                &#34;Search %s remained unmatched at threshold %f in attempt number %s&#34;,
                search, search.match_threshold, search.failed_matching_attempts
            )

    def push(self, search: Search):
        &#34;&#34;&#34; Push the given search object onto the queue &#34;&#34;&#34;

        self._queue[search] = None
        self.game_service.mark_dirty(self)

    def match(self, s1: Search, s2: Search) -&gt; bool:
        &#34;&#34;&#34;
        Mark the given two searches as matched

        # Returns
        `True` if matching succeeded or `False` if matching failed.
        &#34;&#34;&#34;
        if s1.is_matched or s2.is_matched:
            return False
        if s1.is_cancelled or s2.is_cancelled:
            return False
        # Additional failsafe. Ideally this check will never fail.
        if any(
            player.state != PlayerState.SEARCHING_LADDER
            for player in s1.players + s2.players
        ):
            self._logger.warning(
                &#34;Tried to match searches %s and %s while some players had &#34;
                &#34;invalid states: team1: %s team2: %s&#34;,
                s1, s2,
                list(p.state for p in s1.players),
                list(p.state for p in s2.players)
            )
            return False

        s1.match(s2)
        s2.match(s1)
        if s1 in self._queue:
            del self._queue[s1]
        if s2 in self._queue:
            del self._queue[s2]

        return True

    def shutdown(self):
        self._is_running = False

    def to_dict(self):
        &#34;&#34;&#34;
        Return a fuzzy representation of the searches currently in the queue
        &#34;&#34;&#34;
        return {
            &#34;queue_name&#34;: self.name,
            &#34;queue_pop_time&#34;: datetime.fromtimestamp(
                self.timer.next_queue_pop, timezone.utc
            ).isoformat(),
            &#34;queue_pop_time_delta&#34;: self.timer.next_queue_pop - time.time(),
            &#34;num_players&#34;: self.num_players,
            &#34;boundary_80s&#34;: [search.boundary_80 for search in self._queue.keys()],
            &#34;boundary_75s&#34;: [search.boundary_75 for search in self._queue.keys()],
            # TODO: Remove, the client should query the API for this
            &#34;team_size&#34;: self.team_size,
        }

    def __repr__(self):
        return repr(self._queue)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="server.matchmaker.MatchmakerQueue.num_players"><code class="name">var <span class="ident">num_players</span> : int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def num_players(self) -&gt; int:
    return sum(len(search.players) for search in self._queue.keys())</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="server.matchmaker.MatchmakerQueue.add_map_pool"><code class="name flex">
<span>def <span class="ident">add_map_pool</span></span>(<span>self, map_pool: <a title="server.matchmaker.map_pool.MapPool" href="map_pool.html#server.matchmaker.map_pool.MapPool">MapPool</a>, min_rating: Optional[int], max_rating: Optional[int]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_map_pool(
    self,
    map_pool: MapPool,
    min_rating: Optional[int],
    max_rating: Optional[int]
) -&gt; None:
    self.map_pools[map_pool.id] = (map_pool, min_rating, max_rating)</code></pre>
</details>
</dd>
<dt id="server.matchmaker.MatchmakerQueue.find_matches"><code class="name flex">
<span>async def <span class="ident">find_matches</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Perform the matchmaking algorithm.</p>
<p>Note that this function is synchronized such that only one instance of
MatchmakerQueue can call this function at any given time. This is
needed in order to safely enable multiqueuing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@synchronized(SpinLock(sleep_duration=1))
async def find_matches(self) -&gt; None:
    &#34;&#34;&#34;
    Perform the matchmaking algorithm.

    Note that this function is synchronized such that only one instance of
    MatchmakerQueue can call this function at any given time. This is
    needed in order to safely enable multiqueuing.
    &#34;&#34;&#34;
    self._logger.info(&#34;Searching for matches: %s&#34;, self.name)

    searches = list(self._queue.keys())

    if self.num_players &lt; 2 * self.team_size:
        self._register_unmatched_searches(searches)
        return

    # Call self.match on all matches and filter out the ones that were cancelled
    loop = asyncio.get_running_loop()
    proposed_matches, unmatched_searches = await loop.run_in_executor(
        None,
        self.matchmaker.find,
        searches,
        self.team_size,
        self.rating_peak,
    )

    # filter out matches that were cancelled
    matches: list[Match] = []
    for match in proposed_matches:
        if self.match(match[0], match[1]):
            matches.append(match)
        else:
            unmatched_searches.extend(match)

    self._register_unmatched_searches(unmatched_searches)

    for search1, search2 in matches:
        self._report_party_sizes(search1)
        self._report_party_sizes(search2)

        rating_imbalance = abs(search1.cumulative_rating - search2.cumulative_rating)
        metrics.match_rating_imbalance.labels(self.name).observe(rating_imbalance)

        ratings = search1.displayed_ratings + search2.displayed_ratings
        rating_variety = max(ratings) - min(ratings)
        metrics.match_rating_variety.labels(self.name).observe(rating_variety)

        metrics.match_quality.labels(self.name).observe(
            search1.quality_with(search2)
        )
        try:
            self.on_match_found(search1, search2, self)
        except Exception:
            self._logger.exception(&#34;Match callback raised an exception!&#34;)</code></pre>
</details>
</dd>
<dt id="server.matchmaker.MatchmakerQueue.get_game_options"><code class="name flex">
<span>def <span class="ident">get_game_options</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_game_options(self) -&gt; dict[str, Any]:
    return self.params.get(&#34;GameOptions&#34;) or None</code></pre>
</details>
</dd>
<dt id="server.matchmaker.MatchmakerQueue.get_map_pool_for_rating"><code class="name flex">
<span>def <span class="ident">get_map_pool_for_rating</span></span>(<span>self, rating: float) ‑> Optional[<a title="server.matchmaker.map_pool.MapPool" href="map_pool.html#server.matchmaker.map_pool.MapPool">MapPool</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_map_pool_for_rating(self, rating: float) -&gt; Optional[MapPool]:
    for map_pool, min_rating, max_rating in self.map_pools.values():
        if min_rating is not None and rating &lt; min_rating:
            continue
        if max_rating is not None and rating &gt; max_rating:
            continue
        return map_pool</code></pre>
</details>
</dd>
<dt id="server.matchmaker.MatchmakerQueue.initialize"><code class="name flex">
<span>def <span class="ident">initialize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize(self):
    asyncio.create_task(self.queue_pop_timer())</code></pre>
</details>
</dd>
<dt id="server.matchmaker.MatchmakerQueue.match"><code class="name flex">
<span>def <span class="ident">match</span></span>(<span>self, s1: <a title="server.matchmaker.search.Search" href="search.html#server.matchmaker.search.Search">Search</a>, s2: <a title="server.matchmaker.search.Search" href="search.html#server.matchmaker.search.Search">Search</a>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Mark the given two searches as matched</p>
<h1 id="returns">Returns</h1>
<p><code>True</code> if matching succeeded or <code>False</code> if matching failed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match(self, s1: Search, s2: Search) -&gt; bool:
    &#34;&#34;&#34;
    Mark the given two searches as matched

    # Returns
    `True` if matching succeeded or `False` if matching failed.
    &#34;&#34;&#34;
    if s1.is_matched or s2.is_matched:
        return False
    if s1.is_cancelled or s2.is_cancelled:
        return False
    # Additional failsafe. Ideally this check will never fail.
    if any(
        player.state != PlayerState.SEARCHING_LADDER
        for player in s1.players + s2.players
    ):
        self._logger.warning(
            &#34;Tried to match searches %s and %s while some players had &#34;
            &#34;invalid states: team1: %s team2: %s&#34;,
            s1, s2,
            list(p.state for p in s1.players),
            list(p.state for p in s2.players)
        )
        return False

    s1.match(s2)
    s2.match(s1)
    if s1 in self._queue:
        del self._queue[s1]
    if s2 in self._queue:
        del self._queue[s2]

    return True</code></pre>
</details>
</dd>
<dt id="server.matchmaker.MatchmakerQueue.push"><code class="name flex">
<span>def <span class="ident">push</span></span>(<span>self, search: <a title="server.matchmaker.search.Search" href="search.html#server.matchmaker.search.Search">Search</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Push the given search object onto the queue</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push(self, search: Search):
    &#34;&#34;&#34; Push the given search object onto the queue &#34;&#34;&#34;

    self._queue[search] = None
    self.game_service.mark_dirty(self)</code></pre>
</details>
</dd>
<dt id="server.matchmaker.MatchmakerQueue.queue_pop_timer"><code class="name flex">
<span>async def <span class="ident">queue_pop_timer</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Periodically tries to match all Searches in the queue. The amount
of time until next queue 'pop' is determined by the number of players
in the queue.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def queue_pop_timer(self) -&gt; None:
    &#34;&#34;&#34; Periodically tries to match all Searches in the queue. The amount
    of time until next queue &#39;pop&#39; is determined by the number of players
    in the queue.
    &#34;&#34;&#34;
    self._logger.debug(&#34;MatchmakerQueue initialized for %s&#34;, self.name)
    while self._is_running:
        try:
            await self.timer.next_pop()

            await self.find_matches()

            number_of_unmatched_searches = len(self._queue)
            metrics.unmatched_searches.labels(self.name).set(
                number_of_unmatched_searches
            )

            # Any searches in the queue at this point were unable to find a
            # match this round and will have higher priority next round.

            self.game_service.mark_dirty(self)
        except asyncio.CancelledError:
            break
        except Exception:
            self._logger.exception(
                &#34;Unexpected error during queue pop timer loop!&#34;
            )
            # To avoid potential busy loops
            await asyncio.sleep(1)
    self._logger.info(&#34;%s queue stopped&#34;, self.name)</code></pre>
</details>
</dd>
<dt id="server.matchmaker.MatchmakerQueue.search"><code class="name flex">
<span>async def <span class="ident">search</span></span>(<span>self, search: <a title="server.matchmaker.search.Search" href="search.html#server.matchmaker.search.Search">Search</a>) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Search for a match.</p>
<p>Puts a search object into the queue and awaits completion.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def search(self, search: Search) -&gt; None:
    &#34;&#34;&#34;
    Search for a match.

    Puts a search object into the queue and awaits completion.
    &#34;&#34;&#34;
    assert search is not None

    try:
        with MatchmakerSearchTimer(self.name):
            self.push(search)
            await search.await_match()
        self._logger.debug(&#34;Search complete: %s&#34;, search)
    except CancelledError:
        pass
    finally:
        # If the queue was cancelled, or some other error occurred,
        # make sure to clean up.
        self.game_service.mark_dirty(self)
        if search in self._queue:
            del self._queue[search]</code></pre>
</details>
</dd>
<dt id="server.matchmaker.MatchmakerQueue.shutdown"><code class="name flex">
<span>def <span class="ident">shutdown</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shutdown(self):
    self._is_running = False</code></pre>
</details>
</dd>
<dt id="server.matchmaker.MatchmakerQueue.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a fuzzy representation of the searches currently in the queue</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self):
    &#34;&#34;&#34;
    Return a fuzzy representation of the searches currently in the queue
    &#34;&#34;&#34;
    return {
        &#34;queue_name&#34;: self.name,
        &#34;queue_pop_time&#34;: datetime.fromtimestamp(
            self.timer.next_queue_pop, timezone.utc
        ).isoformat(),
        &#34;queue_pop_time_delta&#34;: self.timer.next_queue_pop - time.time(),
        &#34;num_players&#34;: self.num_players,
        &#34;boundary_80s&#34;: [search.boundary_80 for search in self._queue.keys()],
        &#34;boundary_75s&#34;: [search.boundary_75 for search in self._queue.keys()],
        # TODO: Remove, the client should query the API for this
        &#34;team_size&#34;: self.team_size,
    }</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="server.matchmaker.PopTimer"><code class="flex name class">
<span>class <span class="ident">PopTimer</span></span>
<span>(</span><span>queue: <a title="server.matchmaker.MatchmakerQueue" href="#server.matchmaker.MatchmakerQueue">MatchmakerQueue</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates when the next pop should happen based on the rate of players
queuing.</p>
<pre><code>timer = PopTimer(some_queue)
# Pauses the coroutine until the next queue pop
await timer.next_pop()
</code></pre>
<p>The timer will adjust the pop times in an attempt to maintain a fixed queue
size on each pop. So generally, the more people are in the queue, the
shorter the time will be.</p>
<p>The player queue rate is based on a moving average over the last few pops.
The exact size can be set in config.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@with_logger
class PopTimer(object):
    &#34;&#34;&#34; Calculates when the next pop should happen based on the rate of players
    queuing.

        timer = PopTimer(some_queue)
        # Pauses the coroutine until the next queue pop
        await timer.next_pop()

    The timer will adjust the pop times in an attempt to maintain a fixed queue
    size on each pop. So generally, the more people are in the queue, the
    shorter the time will be.

    The player queue rate is based on a moving average over the last few pops.
    The exact size can be set in config.
    &#34;&#34;&#34;

    def __init__(self, queue: &#34;MatchmakerQueue&#34;):
        self.queue = queue
        # Set up deque&#39;s for calculating a moving average
        self.last_queue_amounts: deque[int] = deque(maxlen=config.QUEUE_POP_TIME_MOVING_AVG_SIZE)
        self.last_queue_times: deque[float] = deque(maxlen=config.QUEUE_POP_TIME_MOVING_AVG_SIZE)

        self._last_queue_pop = time()
        # Optimistically schedule first pop for half of the max pop time
        self.next_queue_pop = self._last_queue_pop + (config.QUEUE_POP_TIME_MAX / 2)

    async def next_pop(self):
        &#34;&#34;&#34; Wait for the timer to pop. &#34;&#34;&#34;

        time_remaining = self.next_queue_pop - time()
        self._logger.info(&#34;Next %s wave happening in %is&#34;, self.queue.name, time_remaining)
        metrics.matchmaker_queue_pop.labels(self.queue.name).set(int(time_remaining))
        await asyncio.sleep(time_remaining)
        num_players = self.queue.num_players
        metrics.matchmaker_players.labels(self.queue.name).set(num_players)

        self._last_queue_pop = time()
        self.next_queue_pop = self._last_queue_pop + self.time_until_next_pop(
            num_players, time_remaining
        )

    def time_until_next_pop(self, num_queued: int, time_queued: float) -&gt; float:
        &#34;&#34;&#34; Calculate how long we should wait for the next queue to pop based
        on the current rate of ladder queues
        &#34;&#34;&#34;
        # Calculate moving average of player queue rate
        self.last_queue_amounts.append(num_queued)
        self.last_queue_times.append(time_queued)

        total_players = sum(self.last_queue_amounts)
        if total_players == 0:
            return config.QUEUE_POP_TIME_MAX

        total_times = sum(self.last_queue_times)
        if total_times:
            self._logger.debug(
                &#34;Queue rate for %s: %f/s&#34;, self.queue.name,
                total_players / total_times
            )

        players_per_match = self.queue.team_size * 2
        desired_players = config.QUEUE_POP_DESIRED_MATCHES * players_per_match
        # Obtained by solving $ NUM_PLAYERS = rate * time $ for time.
        next_pop_time = desired_players * total_times / total_players
        if next_pop_time &gt; config.QUEUE_POP_TIME_MAX:
            self._logger.info(
                &#34;Required time (%.2fs) for %s is larger than max pop time (%ds). &#34;
                &#34;Consider increasing the max pop time&#34;,
                next_pop_time, self.queue.name, config.QUEUE_POP_TIME_MAX
            )
            return config.QUEUE_POP_TIME_MAX
        return next_pop_time</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="server.matchmaker.PopTimer.next_pop"><code class="name flex">
<span>async def <span class="ident">next_pop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Wait for the timer to pop.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def next_pop(self):
    &#34;&#34;&#34; Wait for the timer to pop. &#34;&#34;&#34;

    time_remaining = self.next_queue_pop - time()
    self._logger.info(&#34;Next %s wave happening in %is&#34;, self.queue.name, time_remaining)
    metrics.matchmaker_queue_pop.labels(self.queue.name).set(int(time_remaining))
    await asyncio.sleep(time_remaining)
    num_players = self.queue.num_players
    metrics.matchmaker_players.labels(self.queue.name).set(num_players)

    self._last_queue_pop = time()
    self.next_queue_pop = self._last_queue_pop + self.time_until_next_pop(
        num_players, time_remaining
    )</code></pre>
</details>
</dd>
<dt id="server.matchmaker.PopTimer.time_until_next_pop"><code class="name flex">
<span>def <span class="ident">time_until_next_pop</span></span>(<span>self, num_queued: int, time_queued: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate how long we should wait for the next queue to pop based
on the current rate of ladder queues</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def time_until_next_pop(self, num_queued: int, time_queued: float) -&gt; float:
    &#34;&#34;&#34; Calculate how long we should wait for the next queue to pop based
    on the current rate of ladder queues
    &#34;&#34;&#34;
    # Calculate moving average of player queue rate
    self.last_queue_amounts.append(num_queued)
    self.last_queue_times.append(time_queued)

    total_players = sum(self.last_queue_amounts)
    if total_players == 0:
        return config.QUEUE_POP_TIME_MAX

    total_times = sum(self.last_queue_times)
    if total_times:
        self._logger.debug(
            &#34;Queue rate for %s: %f/s&#34;, self.queue.name,
            total_players / total_times
        )

    players_per_match = self.queue.team_size * 2
    desired_players = config.QUEUE_POP_DESIRED_MATCHES * players_per_match
    # Obtained by solving $ NUM_PLAYERS = rate * time $ for time.
    next_pop_time = desired_players * total_times / total_players
    if next_pop_time &gt; config.QUEUE_POP_TIME_MAX:
        self._logger.info(
            &#34;Required time (%.2fs) for %s is larger than max pop time (%ds). &#34;
            &#34;Consider increasing the max pop time&#34;,
            next_pop_time, self.queue.name, config.QUEUE_POP_TIME_MAX
        )
        return config.QUEUE_POP_TIME_MAX
    return next_pop_time</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="server.matchmaker.Search"><code class="flex name class">
<span>class <span class="ident">Search</span></span>
<span>(</span><span>players: list[<a title="server.players.Player" href="../players.html#server.players.Player">Player</a>], start_time: Optional[float] = None, rating_type: str = 'ladder_1v1', on_matched: Callable[[ForwardRef('<a title="server.matchmaker.Search" href="#server.matchmaker.Search">Search</a>'), ForwardRef('<a title="server.matchmaker.Search" href="#server.matchmaker.Search">Search</a>')], Any] = &lt;function Search.&lt;lambda&gt;&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents the state of a users search for a match.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@with_logger
class Search:
    &#34;&#34;&#34;
    Represents the state of a users search for a match.
    &#34;&#34;&#34;

    def __init__(
        self,
        players: list[Player],
        start_time: Optional[float] = None,
        rating_type: str = RatingType.LADDER_1V1,
        on_matched: OnMatchedCallback = lambda _1, _2: None
    ):
        assert isinstance(players, list)
        for player in players:
            assert player.ratings[rating_type] is not None

        self.players = players
        self.rating_type = rating_type
        self.start_time = start_time or time.time()
        self._match = asyncio.get_event_loop().create_future()
        self._failed_matching_attempts = 0
        self.on_matched = on_matched

        # Precompute this
        self.quality_against_self = self.quality_with(self)

    def adjusted_rating(self, player: Player) -&gt; Rating:
        &#34;&#34;&#34;
        Returns an adjusted mean with a simple linear interpolation between current mean and a specified base mean
        &#34;&#34;&#34;
        mean, dev = player.ratings[self.rating_type]
        game_count = player.game_count[self.rating_type]
        adjusted_mean = ((config.NEWBIE_MIN_GAMES - game_count) * config.NEWBIE_BASE_MEAN
                         + game_count * mean) / config.NEWBIE_MIN_GAMES
        return Rating(adjusted_mean, dev)

    def is_newbie(self, player: Player) -&gt; bool:
        return player.game_count[self.rating_type] &lt;= config.NEWBIE_MIN_GAMES

    def is_single_party(self) -&gt; bool:
        return len(self.players) == 1

    def has_newbie(self) -&gt; bool:
        for player in self.players:
            if self.is_newbie(player):
                return True

        return False

    def num_newbies(self) -&gt; int:
        return sum(self.is_newbie(player) for player in self.players)

    def has_high_rated_player(self) -&gt; bool:
        max_rating = max(self.displayed_ratings)
        return max_rating &gt;= config.HIGH_RATED_PLAYER_MIN_RATING

    def has_top_player(self) -&gt; bool:
        max_rating = max(self.displayed_ratings)
        return max_rating &gt;= config.TOP_PLAYER_MIN_RATING

    @property
    def ratings(self) -&gt; list[Rating]:
        ratings = []
        for player, rating in zip(self.players, self.raw_ratings):
            # New players (less than config.NEWBIE_MIN_GAMES games) match against less skilled opponents
            if self.is_newbie(player):
                rating = self.adjusted_rating(player)
            ratings.append(rating)
        return ratings

    @property
    def cumulative_rating(self) -&gt; float:
        return sum(self.displayed_ratings)

    @property
    def average_rating(self) -&gt; float:
        return statistics.mean(self.displayed_ratings)

    @property
    def raw_ratings(self) -&gt; list[Rating]:
        return [player.ratings[self.rating_type] for player in self.players]

    @property
    def displayed_ratings(self) -&gt; list[float]:
        &#34;&#34;&#34;
        The client always displays mean - 3 * dev as a player&#39;s rating.
        So generally this is perceived as a player&#39;s true rating.
        &#34;&#34;&#34;
        return [rating.displayed() for rating in self.raw_ratings]

    def _nearby_rating_range(self, delta: int) -&gt; tuple[int, int]:
        &#34;&#34;&#34;
        Returns &#39;boundary&#39; mu values for player matching. Adjust delta for
        different game qualities.
        &#34;&#34;&#34;
        mu, _ = self.ratings[0]  # Takes the rating of the first player, only works for 1v1
        rounded_mu = int(math.ceil(mu / 10) * 10)  # Round to 10
        return rounded_mu - delta, rounded_mu + delta

    @property
    def boundary_80(self) -&gt; tuple[int, int]:
        &#34;&#34;&#34; Achieves roughly 80% quality. &#34;&#34;&#34;
        return self._nearby_rating_range(200)

    @property
    def boundary_75(self) -&gt; tuple[int, int]:
        &#34;&#34;&#34; Achieves roughly 75% quality. FIXME - why is it MORE restrictive??? &#34;&#34;&#34;
        return self._nearby_rating_range(100)

    @property
    def failed_matching_attempts(self) -&gt; int:
        return self._failed_matching_attempts

    @property
    def search_expansion(self) -&gt; float:
        &#34;&#34;&#34;
        Defines how much to expand the search range of game quality due to waiting
        time.

        The threshold will expand linearly with every failed matching attempt
        until it reaches the specified MAX.

        Top players use bigger values to make matching easier.
        &#34;&#34;&#34;
        if self.has_top_player():
            return min(
                self._failed_matching_attempts * config.LADDER_TOP_PLAYER_SEARCH_EXPANSION_STEP,
                config.LADDER_TOP_PLAYER_SEARCH_EXPANSION_MAX
            )
        else:
            return min(
                self._failed_matching_attempts * config.LADDER_SEARCH_EXPANSION_STEP,
                config.LADDER_SEARCH_EXPANSION_MAX
            )

    def register_failed_matching_attempt(self):
        &#34;&#34;&#34;
        Signal that matchmaker tried to match this search but was unsuccessful
        and increase internal counter by one.
        &#34;&#34;&#34;

        self._failed_matching_attempts += 1

    @property
    def match_threshold(self) -&gt; float:
        &#34;&#34;&#34;
        Defines the threshold for game quality

        The base minimum quality is determined as 80% of the quality of a game
        against a copy of yourself. This is decreased by `self.search_expansion`
        if search is to be expanded.
        &#34;&#34;&#34;

        return max(0.8 * self.quality_against_self - self.search_expansion, 0)

    def quality_with(self, other: &#34;Search&#34;) -&gt; float:
        assert all(other.raw_ratings)
        assert other.players

        team1 = [trueskill.Rating(*rating) for rating in self.ratings]
        team2 = [trueskill.Rating(*rating) for rating in other.ratings]

        return trueskill.quality([team1, team2])

    @property
    def is_matched(self) -&gt; bool:
        return self._match.done() and not self._match.cancelled()

    def done(self) -&gt; bool:
        return self._match.done()

    @property
    def is_cancelled(self) -&gt; bool:
        return self._match.cancelled()

    def matches_with(self, other: &#34;Search&#34;) -&gt; bool:
        &#34;&#34;&#34;
        Determine if this search is compatible with other given search according
        to both wishes.
        &#34;&#34;&#34;
        if not isinstance(other, Search):
            return False

        quality = self.quality_with(other)
        return self._match_quality_acceptable(other, quality)

    def _match_quality_acceptable(self, other: &#34;Search&#34;, quality: float) -&gt; bool:
        &#34;&#34;&#34;
        Determine if the given match quality is acceptable.

        This gets it&#39;s own function so we can call it from the Matchmaker using
        a cached `quality` value.
        &#34;&#34;&#34;
        # NOTE: We are assuming for optimization purposes that quality is
        # symmetric. If this ever changes, update here
        return (quality &gt;= self.match_threshold and
                quality &gt;= other.match_threshold)

    def match(self, other: &#34;Search&#34;):
        &#34;&#34;&#34;
        Mark as matched with given opponent
        &#34;&#34;&#34;
        self._logger.info(&#34;Matched %s with %s&#34;, self, other)

        self.on_matched(self, other)

        for player, raw_rating in zip(self.players, self.raw_ratings):
            if self.is_newbie(player):
                mean, dev = raw_rating
                adjusted_mean, adjusted_dev = self.adjusted_rating(player)
                self._logger.info(
                    &#34;Adjusted mean rating for %s with %d games from %.1f to %.1f&#34;,
                    player.login,
                    player.game_count[self.rating_type],
                    mean,
                    adjusted_mean
                )
        self._match.set_result(other)

    async def await_match(self):
        &#34;&#34;&#34;
        Wait for this search to complete
        &#34;&#34;&#34;
        await asyncio.wait_for(self._match, None)
        return self._match

    def cancel(self):
        &#34;&#34;&#34;
        Cancel searching for a match
        &#34;&#34;&#34;
        self._match.cancel()

    def __str__(self) -&gt; str:
        return (
            f&#34;Search({self.rating_type}, {self._players_repr()}, threshold=&#34;
            f&#34;{self.match_threshold:.2}, expansion={self.search_expansion:.2})&#34;
        )

    def _players_repr(self) -&gt; str:
        contents = &#39;, &#39;.join(
            f&#34;Player({p.login}, {p.id}, {p.ratings[self.rating_type]})&#34;
            for p in self.players
        )
        return f&#34;[{contents}]&#34;

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;For debugging&#34;&#34;&#34;
        return (
            f&#34;Search({[p.login for p in self.players]}, {self.average_rating}&#34;
            f&#34;{f&#39;, FMA: {self.failed_matching_attempts}&#39; if self.failed_matching_attempts else &#39;&#39;}&#34;
            f&#34;{&#39;, has_newbie)&#39; if self.has_newbie() else &#39;)&#39;}&#34;
        )

    def get_original_searches(self) -&gt; list[&#34;Search&#34;]:
        &#34;&#34;&#34;
        Returns the searches of which this Search is comprised,
        as if it were a CombinedSearch of one
        &#34;&#34;&#34;
        return [self]</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="server.matchmaker.search.CombinedSearch" href="search.html#server.matchmaker.search.CombinedSearch">CombinedSearch</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="server.matchmaker.Search.average_rating"><code class="name">var <span class="ident">average_rating</span> : float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def average_rating(self) -&gt; float:
    return statistics.mean(self.displayed_ratings)</code></pre>
</details>
</dd>
<dt id="server.matchmaker.Search.boundary_75"><code class="name">var <span class="ident">boundary_75</span> : tuple[int, int]</code></dt>
<dd>
<div class="desc"><p>Achieves roughly 75% quality. FIXME - why is it MORE restrictive???</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary_75(self) -&gt; tuple[int, int]:
    &#34;&#34;&#34; Achieves roughly 75% quality. FIXME - why is it MORE restrictive??? &#34;&#34;&#34;
    return self._nearby_rating_range(100)</code></pre>
</details>
</dd>
<dt id="server.matchmaker.Search.boundary_80"><code class="name">var <span class="ident">boundary_80</span> : tuple[int, int]</code></dt>
<dd>
<div class="desc"><p>Achieves roughly 80% quality.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary_80(self) -&gt; tuple[int, int]:
    &#34;&#34;&#34; Achieves roughly 80% quality. &#34;&#34;&#34;
    return self._nearby_rating_range(200)</code></pre>
</details>
</dd>
<dt id="server.matchmaker.Search.cumulative_rating"><code class="name">var <span class="ident">cumulative_rating</span> : float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cumulative_rating(self) -&gt; float:
    return sum(self.displayed_ratings)</code></pre>
</details>
</dd>
<dt id="server.matchmaker.Search.displayed_ratings"><code class="name">var <span class="ident">displayed_ratings</span> : list[float]</code></dt>
<dd>
<div class="desc"><p>The client always displays mean - 3 * dev as a player's rating.
So generally this is perceived as a player's true rating.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def displayed_ratings(self) -&gt; list[float]:
    &#34;&#34;&#34;
    The client always displays mean - 3 * dev as a player&#39;s rating.
    So generally this is perceived as a player&#39;s true rating.
    &#34;&#34;&#34;
    return [rating.displayed() for rating in self.raw_ratings]</code></pre>
</details>
</dd>
<dt id="server.matchmaker.Search.failed_matching_attempts"><code class="name">var <span class="ident">failed_matching_attempts</span> : int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def failed_matching_attempts(self) -&gt; int:
    return self._failed_matching_attempts</code></pre>
</details>
</dd>
<dt id="server.matchmaker.Search.is_cancelled"><code class="name">var <span class="ident">is_cancelled</span> : bool</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_cancelled(self) -&gt; bool:
    return self._match.cancelled()</code></pre>
</details>
</dd>
<dt id="server.matchmaker.Search.is_matched"><code class="name">var <span class="ident">is_matched</span> : bool</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_matched(self) -&gt; bool:
    return self._match.done() and not self._match.cancelled()</code></pre>
</details>
</dd>
<dt id="server.matchmaker.Search.match_threshold"><code class="name">var <span class="ident">match_threshold</span> : float</code></dt>
<dd>
<div class="desc"><p>Defines the threshold for game quality</p>
<p>The base minimum quality is determined as 80% of the quality of a game
against a copy of yourself. This is decreased by <code>self.search_expansion</code>
if search is to be expanded.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def match_threshold(self) -&gt; float:
    &#34;&#34;&#34;
    Defines the threshold for game quality

    The base minimum quality is determined as 80% of the quality of a game
    against a copy of yourself. This is decreased by `self.search_expansion`
    if search is to be expanded.
    &#34;&#34;&#34;

    return max(0.8 * self.quality_against_self - self.search_expansion, 0)</code></pre>
</details>
</dd>
<dt id="server.matchmaker.Search.ratings"><code class="name">var <span class="ident">ratings</span> : list[<a title="server.rating.Rating" href="../rating.html#server.rating.Rating">Rating</a>]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ratings(self) -&gt; list[Rating]:
    ratings = []
    for player, rating in zip(self.players, self.raw_ratings):
        # New players (less than config.NEWBIE_MIN_GAMES games) match against less skilled opponents
        if self.is_newbie(player):
            rating = self.adjusted_rating(player)
        ratings.append(rating)
    return ratings</code></pre>
</details>
</dd>
<dt id="server.matchmaker.Search.raw_ratings"><code class="name">var <span class="ident">raw_ratings</span> : list[<a title="server.rating.Rating" href="../rating.html#server.rating.Rating">Rating</a>]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def raw_ratings(self) -&gt; list[Rating]:
    return [player.ratings[self.rating_type] for player in self.players]</code></pre>
</details>
</dd>
<dt id="server.matchmaker.Search.search_expansion"><code class="name">var <span class="ident">search_expansion</span> : float</code></dt>
<dd>
<div class="desc"><p>Defines how much to expand the search range of game quality due to waiting
time.</p>
<p>The threshold will expand linearly with every failed matching attempt
until it reaches the specified MAX.</p>
<p>Top players use bigger values to make matching easier.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def search_expansion(self) -&gt; float:
    &#34;&#34;&#34;
    Defines how much to expand the search range of game quality due to waiting
    time.

    The threshold will expand linearly with every failed matching attempt
    until it reaches the specified MAX.

    Top players use bigger values to make matching easier.
    &#34;&#34;&#34;
    if self.has_top_player():
        return min(
            self._failed_matching_attempts * config.LADDER_TOP_PLAYER_SEARCH_EXPANSION_STEP,
            config.LADDER_TOP_PLAYER_SEARCH_EXPANSION_MAX
        )
    else:
        return min(
            self._failed_matching_attempts * config.LADDER_SEARCH_EXPANSION_STEP,
            config.LADDER_SEARCH_EXPANSION_MAX
        )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="server.matchmaker.Search.adjusted_rating"><code class="name flex">
<span>def <span class="ident">adjusted_rating</span></span>(<span>self, player: <a title="server.players.Player" href="../players.html#server.players.Player">Player</a>) ‑> <a title="server.rating.Rating" href="../rating.html#server.rating.Rating">Rating</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns an adjusted mean with a simple linear interpolation between current mean and a specified base mean</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def adjusted_rating(self, player: Player) -&gt; Rating:
    &#34;&#34;&#34;
    Returns an adjusted mean with a simple linear interpolation between current mean and a specified base mean
    &#34;&#34;&#34;
    mean, dev = player.ratings[self.rating_type]
    game_count = player.game_count[self.rating_type]
    adjusted_mean = ((config.NEWBIE_MIN_GAMES - game_count) * config.NEWBIE_BASE_MEAN
                     + game_count * mean) / config.NEWBIE_MIN_GAMES
    return Rating(adjusted_mean, dev)</code></pre>
</details>
</dd>
<dt id="server.matchmaker.Search.await_match"><code class="name flex">
<span>async def <span class="ident">await_match</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Wait for this search to complete</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def await_match(self):
    &#34;&#34;&#34;
    Wait for this search to complete
    &#34;&#34;&#34;
    await asyncio.wait_for(self._match, None)
    return self._match</code></pre>
</details>
</dd>
<dt id="server.matchmaker.Search.cancel"><code class="name flex">
<span>def <span class="ident">cancel</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Cancel searching for a match</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cancel(self):
    &#34;&#34;&#34;
    Cancel searching for a match
    &#34;&#34;&#34;
    self._match.cancel()</code></pre>
</details>
</dd>
<dt id="server.matchmaker.Search.done"><code class="name flex">
<span>def <span class="ident">done</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def done(self) -&gt; bool:
    return self._match.done()</code></pre>
</details>
</dd>
<dt id="server.matchmaker.Search.get_original_searches"><code class="name flex">
<span>def <span class="ident">get_original_searches</span></span>(<span>self) ‑> list['<a title="server.matchmaker.Search" href="#server.matchmaker.Search">Search</a>']</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the searches of which this Search is comprised,
as if it were a CombinedSearch of one</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_original_searches(self) -&gt; list[&#34;Search&#34;]:
    &#34;&#34;&#34;
    Returns the searches of which this Search is comprised,
    as if it were a CombinedSearch of one
    &#34;&#34;&#34;
    return [self]</code></pre>
</details>
</dd>
<dt id="server.matchmaker.Search.has_high_rated_player"><code class="name flex">
<span>def <span class="ident">has_high_rated_player</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_high_rated_player(self) -&gt; bool:
    max_rating = max(self.displayed_ratings)
    return max_rating &gt;= config.HIGH_RATED_PLAYER_MIN_RATING</code></pre>
</details>
</dd>
<dt id="server.matchmaker.Search.has_newbie"><code class="name flex">
<span>def <span class="ident">has_newbie</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_newbie(self) -&gt; bool:
    for player in self.players:
        if self.is_newbie(player):
            return True

    return False</code></pre>
</details>
</dd>
<dt id="server.matchmaker.Search.has_top_player"><code class="name flex">
<span>def <span class="ident">has_top_player</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_top_player(self) -&gt; bool:
    max_rating = max(self.displayed_ratings)
    return max_rating &gt;= config.TOP_PLAYER_MIN_RATING</code></pre>
</details>
</dd>
<dt id="server.matchmaker.Search.is_newbie"><code class="name flex">
<span>def <span class="ident">is_newbie</span></span>(<span>self, player: <a title="server.players.Player" href="../players.html#server.players.Player">Player</a>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_newbie(self, player: Player) -&gt; bool:
    return player.game_count[self.rating_type] &lt;= config.NEWBIE_MIN_GAMES</code></pre>
</details>
</dd>
<dt id="server.matchmaker.Search.is_single_party"><code class="name flex">
<span>def <span class="ident">is_single_party</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_single_party(self) -&gt; bool:
    return len(self.players) == 1</code></pre>
</details>
</dd>
<dt id="server.matchmaker.Search.match"><code class="name flex">
<span>def <span class="ident">match</span></span>(<span>self, other: <a title="server.matchmaker.Search" href="#server.matchmaker.Search">Search</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Mark as matched with given opponent</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match(self, other: &#34;Search&#34;):
    &#34;&#34;&#34;
    Mark as matched with given opponent
    &#34;&#34;&#34;
    self._logger.info(&#34;Matched %s with %s&#34;, self, other)

    self.on_matched(self, other)

    for player, raw_rating in zip(self.players, self.raw_ratings):
        if self.is_newbie(player):
            mean, dev = raw_rating
            adjusted_mean, adjusted_dev = self.adjusted_rating(player)
            self._logger.info(
                &#34;Adjusted mean rating for %s with %d games from %.1f to %.1f&#34;,
                player.login,
                player.game_count[self.rating_type],
                mean,
                adjusted_mean
            )
    self._match.set_result(other)</code></pre>
</details>
</dd>
<dt id="server.matchmaker.Search.matches_with"><code class="name flex">
<span>def <span class="ident">matches_with</span></span>(<span>self, other: <a title="server.matchmaker.Search" href="#server.matchmaker.Search">Search</a>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Determine if this search is compatible with other given search according
to both wishes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def matches_with(self, other: &#34;Search&#34;) -&gt; bool:
    &#34;&#34;&#34;
    Determine if this search is compatible with other given search according
    to both wishes.
    &#34;&#34;&#34;
    if not isinstance(other, Search):
        return False

    quality = self.quality_with(other)
    return self._match_quality_acceptable(other, quality)</code></pre>
</details>
</dd>
<dt id="server.matchmaker.Search.num_newbies"><code class="name flex">
<span>def <span class="ident">num_newbies</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num_newbies(self) -&gt; int:
    return sum(self.is_newbie(player) for player in self.players)</code></pre>
</details>
</dd>
<dt id="server.matchmaker.Search.quality_with"><code class="name flex">
<span>def <span class="ident">quality_with</span></span>(<span>self, other: <a title="server.matchmaker.Search" href="#server.matchmaker.Search">Search</a>) ‑> float</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def quality_with(self, other: &#34;Search&#34;) -&gt; float:
    assert all(other.raw_ratings)
    assert other.players

    team1 = [trueskill.Rating(*rating) for rating in self.ratings]
    team2 = [trueskill.Rating(*rating) for rating in other.ratings]

    return trueskill.quality([team1, team2])</code></pre>
</details>
</dd>
<dt id="server.matchmaker.Search.register_failed_matching_attempt"><code class="name flex">
<span>def <span class="ident">register_failed_matching_attempt</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Signal that matchmaker tried to match this search but was unsuccessful
and increase internal counter by one.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_failed_matching_attempt(self):
    &#34;&#34;&#34;
    Signal that matchmaker tried to match this search but was unsuccessful
    and increase internal counter by one.
    &#34;&#34;&#34;

    self._failed_matching_attempts += 1</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="server" href="../index.html">server</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="server.matchmaker.algorithm" href="algorithm/index.html">server.matchmaker.algorithm</a></code></li>
<li><code><a title="server.matchmaker.map_pool" href="map_pool.html">server.matchmaker.map_pool</a></code></li>
<li><code><a title="server.matchmaker.matchmaker_queue" href="matchmaker_queue.html">server.matchmaker.matchmaker_queue</a></code></li>
<li><code><a title="server.matchmaker.pop_timer" href="pop_timer.html">server.matchmaker.pop_timer</a></code></li>
<li><code><a title="server.matchmaker.search" href="search.html">server.matchmaker.search</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="server.matchmaker.CombinedSearch" href="#server.matchmaker.CombinedSearch">CombinedSearch</a></code></h4>
<ul class="">
<li><code><a title="server.matchmaker.CombinedSearch.average_rating" href="#server.matchmaker.CombinedSearch.average_rating">average_rating</a></code></li>
<li><code><a title="server.matchmaker.CombinedSearch.cumulative_rating" href="#server.matchmaker.CombinedSearch.cumulative_rating">cumulative_rating</a></code></li>
<li><code><a title="server.matchmaker.CombinedSearch.done" href="#server.matchmaker.CombinedSearch.done">done</a></code></li>
<li><code><a title="server.matchmaker.CombinedSearch.failed_matching_attempts" href="#server.matchmaker.CombinedSearch.failed_matching_attempts">failed_matching_attempts</a></code></li>
<li><code><a title="server.matchmaker.CombinedSearch.get_original_searches" href="#server.matchmaker.CombinedSearch.get_original_searches">get_original_searches</a></code></li>
<li><code><a title="server.matchmaker.CombinedSearch.is_cancelled" href="#server.matchmaker.CombinedSearch.is_cancelled">is_cancelled</a></code></li>
<li><code><a title="server.matchmaker.CombinedSearch.is_matched" href="#server.matchmaker.CombinedSearch.is_matched">is_matched</a></code></li>
<li><code><a title="server.matchmaker.CombinedSearch.match_threshold" href="#server.matchmaker.CombinedSearch.match_threshold">match_threshold</a></code></li>
<li><code><a title="server.matchmaker.CombinedSearch.players" href="#server.matchmaker.CombinedSearch.players">players</a></code></li>
<li><code><a title="server.matchmaker.CombinedSearch.ratings" href="#server.matchmaker.CombinedSearch.ratings">ratings</a></code></li>
<li><code><a title="server.matchmaker.CombinedSearch.raw_ratings" href="#server.matchmaker.CombinedSearch.raw_ratings">raw_ratings</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="server.matchmaker.MapPool" href="#server.matchmaker.MapPool">MapPool</a></code></h4>
<ul class="">
<li><code><a title="server.matchmaker.MapPool.choose_map" href="#server.matchmaker.MapPool.choose_map">choose_map</a></code></li>
<li><code><a title="server.matchmaker.MapPool.set_maps" href="#server.matchmaker.MapPool.set_maps">set_maps</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="server.matchmaker.MatchmakerQueue" href="#server.matchmaker.MatchmakerQueue">MatchmakerQueue</a></code></h4>
<ul class="">
<li><code><a title="server.matchmaker.MatchmakerQueue.add_map_pool" href="#server.matchmaker.MatchmakerQueue.add_map_pool">add_map_pool</a></code></li>
<li><code><a title="server.matchmaker.MatchmakerQueue.find_matches" href="#server.matchmaker.MatchmakerQueue.find_matches">find_matches</a></code></li>
<li><code><a title="server.matchmaker.MatchmakerQueue.get_game_options" href="#server.matchmaker.MatchmakerQueue.get_game_options">get_game_options</a></code></li>
<li><code><a title="server.matchmaker.MatchmakerQueue.get_map_pool_for_rating" href="#server.matchmaker.MatchmakerQueue.get_map_pool_for_rating">get_map_pool_for_rating</a></code></li>
<li><code><a title="server.matchmaker.MatchmakerQueue.initialize" href="#server.matchmaker.MatchmakerQueue.initialize">initialize</a></code></li>
<li><code><a title="server.matchmaker.MatchmakerQueue.match" href="#server.matchmaker.MatchmakerQueue.match">match</a></code></li>
<li><code><a title="server.matchmaker.MatchmakerQueue.num_players" href="#server.matchmaker.MatchmakerQueue.num_players">num_players</a></code></li>
<li><code><a title="server.matchmaker.MatchmakerQueue.push" href="#server.matchmaker.MatchmakerQueue.push">push</a></code></li>
<li><code><a title="server.matchmaker.MatchmakerQueue.queue_pop_timer" href="#server.matchmaker.MatchmakerQueue.queue_pop_timer">queue_pop_timer</a></code></li>
<li><code><a title="server.matchmaker.MatchmakerQueue.search" href="#server.matchmaker.MatchmakerQueue.search">search</a></code></li>
<li><code><a title="server.matchmaker.MatchmakerQueue.shutdown" href="#server.matchmaker.MatchmakerQueue.shutdown">shutdown</a></code></li>
<li><code><a title="server.matchmaker.MatchmakerQueue.to_dict" href="#server.matchmaker.MatchmakerQueue.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="server.matchmaker.PopTimer" href="#server.matchmaker.PopTimer">PopTimer</a></code></h4>
<ul class="">
<li><code><a title="server.matchmaker.PopTimer.next_pop" href="#server.matchmaker.PopTimer.next_pop">next_pop</a></code></li>
<li><code><a title="server.matchmaker.PopTimer.time_until_next_pop" href="#server.matchmaker.PopTimer.time_until_next_pop">time_until_next_pop</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="server.matchmaker.Search" href="#server.matchmaker.Search">Search</a></code></h4>
<ul class="">
<li><code><a title="server.matchmaker.Search.adjusted_rating" href="#server.matchmaker.Search.adjusted_rating">adjusted_rating</a></code></li>
<li><code><a title="server.matchmaker.Search.average_rating" href="#server.matchmaker.Search.average_rating">average_rating</a></code></li>
<li><code><a title="server.matchmaker.Search.await_match" href="#server.matchmaker.Search.await_match">await_match</a></code></li>
<li><code><a title="server.matchmaker.Search.boundary_75" href="#server.matchmaker.Search.boundary_75">boundary_75</a></code></li>
<li><code><a title="server.matchmaker.Search.boundary_80" href="#server.matchmaker.Search.boundary_80">boundary_80</a></code></li>
<li><code><a title="server.matchmaker.Search.cancel" href="#server.matchmaker.Search.cancel">cancel</a></code></li>
<li><code><a title="server.matchmaker.Search.cumulative_rating" href="#server.matchmaker.Search.cumulative_rating">cumulative_rating</a></code></li>
<li><code><a title="server.matchmaker.Search.displayed_ratings" href="#server.matchmaker.Search.displayed_ratings">displayed_ratings</a></code></li>
<li><code><a title="server.matchmaker.Search.done" href="#server.matchmaker.Search.done">done</a></code></li>
<li><code><a title="server.matchmaker.Search.failed_matching_attempts" href="#server.matchmaker.Search.failed_matching_attempts">failed_matching_attempts</a></code></li>
<li><code><a title="server.matchmaker.Search.get_original_searches" href="#server.matchmaker.Search.get_original_searches">get_original_searches</a></code></li>
<li><code><a title="server.matchmaker.Search.has_high_rated_player" href="#server.matchmaker.Search.has_high_rated_player">has_high_rated_player</a></code></li>
<li><code><a title="server.matchmaker.Search.has_newbie" href="#server.matchmaker.Search.has_newbie">has_newbie</a></code></li>
<li><code><a title="server.matchmaker.Search.has_top_player" href="#server.matchmaker.Search.has_top_player">has_top_player</a></code></li>
<li><code><a title="server.matchmaker.Search.is_cancelled" href="#server.matchmaker.Search.is_cancelled">is_cancelled</a></code></li>
<li><code><a title="server.matchmaker.Search.is_matched" href="#server.matchmaker.Search.is_matched">is_matched</a></code></li>
<li><code><a title="server.matchmaker.Search.is_newbie" href="#server.matchmaker.Search.is_newbie">is_newbie</a></code></li>
<li><code><a title="server.matchmaker.Search.is_single_party" href="#server.matchmaker.Search.is_single_party">is_single_party</a></code></li>
<li><code><a title="server.matchmaker.Search.match" href="#server.matchmaker.Search.match">match</a></code></li>
<li><code><a title="server.matchmaker.Search.match_threshold" href="#server.matchmaker.Search.match_threshold">match_threshold</a></code></li>
<li><code><a title="server.matchmaker.Search.matches_with" href="#server.matchmaker.Search.matches_with">matches_with</a></code></li>
<li><code><a title="server.matchmaker.Search.num_newbies" href="#server.matchmaker.Search.num_newbies">num_newbies</a></code></li>
<li><code><a title="server.matchmaker.Search.quality_with" href="#server.matchmaker.Search.quality_with">quality_with</a></code></li>
<li><code><a title="server.matchmaker.Search.ratings" href="#server.matchmaker.Search.ratings">ratings</a></code></li>
<li><code><a title="server.matchmaker.Search.raw_ratings" href="#server.matchmaker.Search.raw_ratings">raw_ratings</a></code></li>
<li><code><a title="server.matchmaker.Search.register_failed_matching_attempt" href="#server.matchmaker.Search.register_failed_matching_attempt">register_failed_matching_attempt</a></code></li>
<li><code><a title="server.matchmaker.Search.search_expansion" href="#server.matchmaker.Search.search_expansion">search_expansion</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>