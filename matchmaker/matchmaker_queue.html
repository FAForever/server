<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>server.matchmaker.matchmaker_queue API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>server.matchmaker.matchmaker_queue</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import asyncio
import time
from collections import OrderedDict
from concurrent.futures import CancelledError
from datetime import datetime, timezone
from typing import Any, Callable, Dict, Iterable, List, Optional, Tuple

import server.metrics as metrics

from ..asyncio_extensions import SpinLock, synchronized
from ..decorators import with_logger
from ..players import PlayerState
from .algorithm import make_matches, make_teams, make_teams_from_single
from .map_pool import MapPool
from .pop_timer import PopTimer
from .search import Search

MatchFoundCallback = Callable[[Search, Search, &#34;MatchmakerQueue&#34;], Any]


class MatchmakerSearchTimer:
    def __init__(self, queue_name):
        self.queue_name = queue_name

    def __enter__(self):
        self.start_time = time.monotonic()

    def __exit__(self, exc_type, exc_value, traceback):
        total_time = time.monotonic() - self.start_time
        if exc_type is None:
            status = &#34;successful&#34;
        elif exc_type is CancelledError:
            status = &#34;cancelled&#34;
        else:
            status = &#34;errored&#34;

        metric = metrics.matchmaker_searches.labels(self.queue_name, status)
        metric.observe(total_time)


@with_logger
class MatchmakerQueue:
    def __init__(
        self,
        game_service: &#34;GameService&#34;,
        on_match_found: MatchFoundCallback,
        name: str,
        queue_id: int,
        featured_mod: str,
        rating_type: str,
        team_size: int = 1,
        map_pools: Iterable[Tuple[MapPool, Optional[int], Optional[int]]] = (),
    ):
        self.game_service = game_service
        self.name = name
        self.id = queue_id
        self.featured_mod = featured_mod
        self.rating_type = rating_type
        self.team_size = team_size
        self.map_pools = {info[0].id: info for info in map_pools}

        self._queue: Dict[Search, None] = OrderedDict()
        self.on_match_found = on_match_found
        self._is_running = True

        self.timer = PopTimer(self)

    def add_map_pool(
        self,
        map_pool: MapPool,
        min_rating: Optional[int],
        max_rating: Optional[int]
    ) -&gt; None:
        self.map_pools[map_pool.id] = (map_pool, min_rating, max_rating)

    def get_map_pool_for_rating(self, rating: int) -&gt; Optional[MapPool]:
        for map_pool, min_rating, max_rating in self.map_pools.values():
            if min_rating is not None and rating &lt; min_rating:
                continue
            if max_rating is not None and rating &gt; max_rating:
                continue
            return map_pool

    def initialize(self):
        asyncio.create_task(self.queue_pop_timer())

    @property
    def num_players(self) -&gt; int:
        return sum(len(search.players) for search in self._queue.keys())

    async def queue_pop_timer(self) -&gt; None:
        &#34;&#34;&#34; Periodically tries to match all Searches in the queue. The amount
        of time until next queue &#39;pop&#39; is determined by the number of players
        in the queue.
        &#34;&#34;&#34;
        self._logger.debug(&#34;MatchmakerQueue initialized for %s&#34;, self.name)
        while self._is_running:
            try:
                await self.timer.next_pop()

                await self.find_matches()

                number_of_unmatched_searches = len(self._queue)
                metrics.unmatched_searches.labels(self.name).set(
                    number_of_unmatched_searches
                )

                # Any searches in the queue at this point were unable to find a
                # match this round and will have higher priority next round.

                self.game_service.mark_dirty(self)
            except Exception:
                self._logger.exception(
                    &#34;Unexpected error during queue pop timer loop!&#34;
                )
                # To avoid potential busy loops
                await asyncio.sleep(1)

    async def search(self, search: Search) -&gt; None:
        &#34;&#34;&#34;
        Search for a match.

        Puts a search object into the Queue and awaits completion.

        :param player: Player to search for a matchup for
        &#34;&#34;&#34;
        assert search is not None

        try:
            with MatchmakerSearchTimer(self.name):
                self.push(search)
                await search.await_match()
            self._logger.debug(&#34;Search complete: %s&#34;, search)
        except CancelledError:
            pass
        finally:
            # If the queue was cancelled, or some other error occurred,
            # make sure to clean up.
            self.game_service.mark_dirty(self)
            if search in self._queue:
                del self._queue[search]

    @synchronized(SpinLock(sleep_duration=1))
    async def find_matches(self) -&gt; None:
        &#34;&#34;&#34;
        Perform the matchmaking algorithm.

        Note that this function is synchronized such that only one instance of
        MatchmakerQueue can call this function at any given time. This is
        needed in order to safely enable multiqueuing.
        &#34;&#34;&#34;
        self._logger.info(&#34;Searching for matches: %s&#34;, self.name)

        if self.num_players &lt; 2 * self.team_size:
            return

        searches = self.find_teams()

        # Call self.match on all matches and filter out the ones that were cancelled
        loop = asyncio.get_running_loop()
        matches = list(filter(
            lambda m: self.match(m[0], m[1]),
            await loop.run_in_executor(None, make_matches, searches)
        ))

        number_of_matches = len(matches)
        metrics.matches.labels(self.name).set(number_of_matches)

        for search1, search2 in matches:
            # TODO: Move this into algorithm, then don&#39;t need to recalculate
            # quality_with? Probably not a major bottleneck though.
            metrics.match_quality.labels(self.name).observe(
                search1.quality_with(search2)
            )
            try:
                self.on_match_found(search1, search2, self)
            except Exception:
                self._logger.exception(&#34;Match callback raised an exception!&#34;)

    def find_teams(self) -&gt; List[Search]:
        searches = []
        unmatched = list(self._queue.keys())
        need_team = []
        for search in unmatched:
            if len(search.players) == self.team_size:
                searches.append(search)
            else:
                need_team.append(search)

        if all(len(s.players) == 1 for s in need_team):
            teams, unmatched = make_teams_from_single(need_team, self.team_size)
        else:
            teams, unmatched = make_teams(need_team, self.team_size)
        searches.extend(teams)

        return searches

    def push(self, search: Search):
        &#34;&#34;&#34; Push the given search object onto the queue &#34;&#34;&#34;

        self._queue[search] = None
        self.game_service.mark_dirty(self)

    def match(self, s1: Search, s2: Search) -&gt; bool:
        &#34;&#34;&#34;
        Mark the given two searches as matched
        :param s1:
        :param s2:
        :return: True if matching succeeded or False if matching failed
        &#34;&#34;&#34;
        if s1.is_matched or s2.is_matched:
            return False
        if s1.is_cancelled or s2.is_cancelled:
            return False
        # Additional failsafe. Ideally this check will never fail.
        if any(
            player.state != PlayerState.SEARCHING_LADDER
            for player in s1.players + s2.players
        ):
            self._logger.warning(
                &#34;Tried to match searches %s and %s while some players had &#34;
                &#34;invalid states: team1: %s team2: %s&#34;,
                s1, s2,
                list(p.state for p in s1.players),
                list(p.state for p in s2.players)
            )
            return False

        s1.match(s2)
        s2.match(s1)
        if s1 in self._queue:
            del self._queue[s1]
        if s2 in self._queue:
            del self._queue[s2]

        return True

    def shutdown(self):
        self._is_running = False

    def to_dict(self):
        &#34;&#34;&#34;
        Return a fuzzy representation of the searches currently in the queue
        &#34;&#34;&#34;
        return {
            &#34;queue_name&#34;: self.name,
            &#34;queue_pop_time&#34;: datetime.fromtimestamp(
                self.timer.next_queue_pop, timezone.utc
            ).isoformat(),
            &#34;num_players&#34;: self.num_players,
            &#34;boundary_80s&#34;: [search.boundary_80 for search in self._queue.keys()],
            &#34;boundary_75s&#34;: [search.boundary_75 for search in self._queue.keys()],
            # TODO: Remove, the client should query the API for this
            &#34;team_size&#34;: self.team_size,
        }

    def __repr__(self):
        return repr(self._queue)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="server.matchmaker.matchmaker_queue.MatchmakerQueue"><code class="flex name class">
<span>class <span class="ident">MatchmakerQueue</span></span>
<span>(</span><span>game_service: GameService, on_match_found: Callable[[<a title="server.matchmaker.search.Search" href="search.html#server.matchmaker.search.Search">Search</a>, <a title="server.matchmaker.search.Search" href="search.html#server.matchmaker.search.Search">Search</a>, ForwardRef('<a title="server.matchmaker.matchmaker_queue.MatchmakerQueue" href="#server.matchmaker.matchmaker_queue.MatchmakerQueue">MatchmakerQueue</a>')], Any], name: str, queue_id: int, featured_mod: str, rating_type: str, team_size: int = 1, map_pools: Iterable[Tuple[<a title="server.matchmaker.map_pool.MapPool" href="map_pool.html#server.matchmaker.map_pool.MapPool">MapPool</a>, Union[int, NoneType], Union[int, NoneType]]] = ())</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MatchmakerQueue:
    def __init__(
        self,
        game_service: &#34;GameService&#34;,
        on_match_found: MatchFoundCallback,
        name: str,
        queue_id: int,
        featured_mod: str,
        rating_type: str,
        team_size: int = 1,
        map_pools: Iterable[Tuple[MapPool, Optional[int], Optional[int]]] = (),
    ):
        self.game_service = game_service
        self.name = name
        self.id = queue_id
        self.featured_mod = featured_mod
        self.rating_type = rating_type
        self.team_size = team_size
        self.map_pools = {info[0].id: info for info in map_pools}

        self._queue: Dict[Search, None] = OrderedDict()
        self.on_match_found = on_match_found
        self._is_running = True

        self.timer = PopTimer(self)

    def add_map_pool(
        self,
        map_pool: MapPool,
        min_rating: Optional[int],
        max_rating: Optional[int]
    ) -&gt; None:
        self.map_pools[map_pool.id] = (map_pool, min_rating, max_rating)

    def get_map_pool_for_rating(self, rating: int) -&gt; Optional[MapPool]:
        for map_pool, min_rating, max_rating in self.map_pools.values():
            if min_rating is not None and rating &lt; min_rating:
                continue
            if max_rating is not None and rating &gt; max_rating:
                continue
            return map_pool

    def initialize(self):
        asyncio.create_task(self.queue_pop_timer())

    @property
    def num_players(self) -&gt; int:
        return sum(len(search.players) for search in self._queue.keys())

    async def queue_pop_timer(self) -&gt; None:
        &#34;&#34;&#34; Periodically tries to match all Searches in the queue. The amount
        of time until next queue &#39;pop&#39; is determined by the number of players
        in the queue.
        &#34;&#34;&#34;
        self._logger.debug(&#34;MatchmakerQueue initialized for %s&#34;, self.name)
        while self._is_running:
            try:
                await self.timer.next_pop()

                await self.find_matches()

                number_of_unmatched_searches = len(self._queue)
                metrics.unmatched_searches.labels(self.name).set(
                    number_of_unmatched_searches
                )

                # Any searches in the queue at this point were unable to find a
                # match this round and will have higher priority next round.

                self.game_service.mark_dirty(self)
            except Exception:
                self._logger.exception(
                    &#34;Unexpected error during queue pop timer loop!&#34;
                )
                # To avoid potential busy loops
                await asyncio.sleep(1)

    async def search(self, search: Search) -&gt; None:
        &#34;&#34;&#34;
        Search for a match.

        Puts a search object into the Queue and awaits completion.

        :param player: Player to search for a matchup for
        &#34;&#34;&#34;
        assert search is not None

        try:
            with MatchmakerSearchTimer(self.name):
                self.push(search)
                await search.await_match()
            self._logger.debug(&#34;Search complete: %s&#34;, search)
        except CancelledError:
            pass
        finally:
            # If the queue was cancelled, or some other error occurred,
            # make sure to clean up.
            self.game_service.mark_dirty(self)
            if search in self._queue:
                del self._queue[search]

    @synchronized(SpinLock(sleep_duration=1))
    async def find_matches(self) -&gt; None:
        &#34;&#34;&#34;
        Perform the matchmaking algorithm.

        Note that this function is synchronized such that only one instance of
        MatchmakerQueue can call this function at any given time. This is
        needed in order to safely enable multiqueuing.
        &#34;&#34;&#34;
        self._logger.info(&#34;Searching for matches: %s&#34;, self.name)

        if self.num_players &lt; 2 * self.team_size:
            return

        searches = self.find_teams()

        # Call self.match on all matches and filter out the ones that were cancelled
        loop = asyncio.get_running_loop()
        matches = list(filter(
            lambda m: self.match(m[0], m[1]),
            await loop.run_in_executor(None, make_matches, searches)
        ))

        number_of_matches = len(matches)
        metrics.matches.labels(self.name).set(number_of_matches)

        for search1, search2 in matches:
            # TODO: Move this into algorithm, then don&#39;t need to recalculate
            # quality_with? Probably not a major bottleneck though.
            metrics.match_quality.labels(self.name).observe(
                search1.quality_with(search2)
            )
            try:
                self.on_match_found(search1, search2, self)
            except Exception:
                self._logger.exception(&#34;Match callback raised an exception!&#34;)

    def find_teams(self) -&gt; List[Search]:
        searches = []
        unmatched = list(self._queue.keys())
        need_team = []
        for search in unmatched:
            if len(search.players) == self.team_size:
                searches.append(search)
            else:
                need_team.append(search)

        if all(len(s.players) == 1 for s in need_team):
            teams, unmatched = make_teams_from_single(need_team, self.team_size)
        else:
            teams, unmatched = make_teams(need_team, self.team_size)
        searches.extend(teams)

        return searches

    def push(self, search: Search):
        &#34;&#34;&#34; Push the given search object onto the queue &#34;&#34;&#34;

        self._queue[search] = None
        self.game_service.mark_dirty(self)

    def match(self, s1: Search, s2: Search) -&gt; bool:
        &#34;&#34;&#34;
        Mark the given two searches as matched
        :param s1:
        :param s2:
        :return: True if matching succeeded or False if matching failed
        &#34;&#34;&#34;
        if s1.is_matched or s2.is_matched:
            return False
        if s1.is_cancelled or s2.is_cancelled:
            return False
        # Additional failsafe. Ideally this check will never fail.
        if any(
            player.state != PlayerState.SEARCHING_LADDER
            for player in s1.players + s2.players
        ):
            self._logger.warning(
                &#34;Tried to match searches %s and %s while some players had &#34;
                &#34;invalid states: team1: %s team2: %s&#34;,
                s1, s2,
                list(p.state for p in s1.players),
                list(p.state for p in s2.players)
            )
            return False

        s1.match(s2)
        s2.match(s1)
        if s1 in self._queue:
            del self._queue[s1]
        if s2 in self._queue:
            del self._queue[s2]

        return True

    def shutdown(self):
        self._is_running = False

    def to_dict(self):
        &#34;&#34;&#34;
        Return a fuzzy representation of the searches currently in the queue
        &#34;&#34;&#34;
        return {
            &#34;queue_name&#34;: self.name,
            &#34;queue_pop_time&#34;: datetime.fromtimestamp(
                self.timer.next_queue_pop, timezone.utc
            ).isoformat(),
            &#34;num_players&#34;: self.num_players,
            &#34;boundary_80s&#34;: [search.boundary_80 for search in self._queue.keys()],
            &#34;boundary_75s&#34;: [search.boundary_75 for search in self._queue.keys()],
            # TODO: Remove, the client should query the API for this
            &#34;team_size&#34;: self.team_size,
        }

    def __repr__(self):
        return repr(self._queue)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="server.matchmaker.matchmaker_queue.MatchmakerQueue.num_players"><code class="name">var <span class="ident">num_players</span> : int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def num_players(self) -&gt; int:
    return sum(len(search.players) for search in self._queue.keys())</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="server.matchmaker.matchmaker_queue.MatchmakerQueue.add_map_pool"><code class="name flex">
<span>def <span class="ident">add_map_pool</span></span>(<span>self, map_pool: <a title="server.matchmaker.map_pool.MapPool" href="map_pool.html#server.matchmaker.map_pool.MapPool">MapPool</a>, min_rating: Union[int, NoneType], max_rating: Union[int, NoneType]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_map_pool(
    self,
    map_pool: MapPool,
    min_rating: Optional[int],
    max_rating: Optional[int]
) -&gt; None:
    self.map_pools[map_pool.id] = (map_pool, min_rating, max_rating)</code></pre>
</details>
</dd>
<dt id="server.matchmaker.matchmaker_queue.MatchmakerQueue.find_matches"><code class="name flex">
<span>async def <span class="ident">find_matches</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Perform the matchmaking algorithm.</p>
<p>Note that this function is synchronized such that only one instance of
MatchmakerQueue can call this function at any given time. This is
needed in order to safely enable multiqueuing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@synchronized(SpinLock(sleep_duration=1))
async def find_matches(self) -&gt; None:
    &#34;&#34;&#34;
    Perform the matchmaking algorithm.

    Note that this function is synchronized such that only one instance of
    MatchmakerQueue can call this function at any given time. This is
    needed in order to safely enable multiqueuing.
    &#34;&#34;&#34;
    self._logger.info(&#34;Searching for matches: %s&#34;, self.name)

    if self.num_players &lt; 2 * self.team_size:
        return

    searches = self.find_teams()

    # Call self.match on all matches and filter out the ones that were cancelled
    loop = asyncio.get_running_loop()
    matches = list(filter(
        lambda m: self.match(m[0], m[1]),
        await loop.run_in_executor(None, make_matches, searches)
    ))

    number_of_matches = len(matches)
    metrics.matches.labels(self.name).set(number_of_matches)

    for search1, search2 in matches:
        # TODO: Move this into algorithm, then don&#39;t need to recalculate
        # quality_with? Probably not a major bottleneck though.
        metrics.match_quality.labels(self.name).observe(
            search1.quality_with(search2)
        )
        try:
            self.on_match_found(search1, search2, self)
        except Exception:
            self._logger.exception(&#34;Match callback raised an exception!&#34;)</code></pre>
</details>
</dd>
<dt id="server.matchmaker.matchmaker_queue.MatchmakerQueue.find_teams"><code class="name flex">
<span>def <span class="ident">find_teams</span></span>(<span>self) ‑> List[<a title="server.matchmaker.search.Search" href="search.html#server.matchmaker.search.Search">Search</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_teams(self) -&gt; List[Search]:
    searches = []
    unmatched = list(self._queue.keys())
    need_team = []
    for search in unmatched:
        if len(search.players) == self.team_size:
            searches.append(search)
        else:
            need_team.append(search)

    if all(len(s.players) == 1 for s in need_team):
        teams, unmatched = make_teams_from_single(need_team, self.team_size)
    else:
        teams, unmatched = make_teams(need_team, self.team_size)
    searches.extend(teams)

    return searches</code></pre>
</details>
</dd>
<dt id="server.matchmaker.matchmaker_queue.MatchmakerQueue.get_map_pool_for_rating"><code class="name flex">
<span>def <span class="ident">get_map_pool_for_rating</span></span>(<span>self, rating: int) ‑> Union[<a title="server.matchmaker.map_pool.MapPool" href="map_pool.html#server.matchmaker.map_pool.MapPool">MapPool</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_map_pool_for_rating(self, rating: int) -&gt; Optional[MapPool]:
    for map_pool, min_rating, max_rating in self.map_pools.values():
        if min_rating is not None and rating &lt; min_rating:
            continue
        if max_rating is not None and rating &gt; max_rating:
            continue
        return map_pool</code></pre>
</details>
</dd>
<dt id="server.matchmaker.matchmaker_queue.MatchmakerQueue.initialize"><code class="name flex">
<span>def <span class="ident">initialize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize(self):
    asyncio.create_task(self.queue_pop_timer())</code></pre>
</details>
</dd>
<dt id="server.matchmaker.matchmaker_queue.MatchmakerQueue.match"><code class="name flex">
<span>def <span class="ident">match</span></span>(<span>self, s1: <a title="server.matchmaker.search.Search" href="search.html#server.matchmaker.search.Search">Search</a>, s2: <a title="server.matchmaker.search.Search" href="search.html#server.matchmaker.search.Search">Search</a>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Mark the given two searches as matched
:param s1:
:param s2:
:return: True if matching succeeded or False if matching failed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match(self, s1: Search, s2: Search) -&gt; bool:
    &#34;&#34;&#34;
    Mark the given two searches as matched
    :param s1:
    :param s2:
    :return: True if matching succeeded or False if matching failed
    &#34;&#34;&#34;
    if s1.is_matched or s2.is_matched:
        return False
    if s1.is_cancelled or s2.is_cancelled:
        return False
    # Additional failsafe. Ideally this check will never fail.
    if any(
        player.state != PlayerState.SEARCHING_LADDER
        for player in s1.players + s2.players
    ):
        self._logger.warning(
            &#34;Tried to match searches %s and %s while some players had &#34;
            &#34;invalid states: team1: %s team2: %s&#34;,
            s1, s2,
            list(p.state for p in s1.players),
            list(p.state for p in s2.players)
        )
        return False

    s1.match(s2)
    s2.match(s1)
    if s1 in self._queue:
        del self._queue[s1]
    if s2 in self._queue:
        del self._queue[s2]

    return True</code></pre>
</details>
</dd>
<dt id="server.matchmaker.matchmaker_queue.MatchmakerQueue.push"><code class="name flex">
<span>def <span class="ident">push</span></span>(<span>self, search: <a title="server.matchmaker.search.Search" href="search.html#server.matchmaker.search.Search">Search</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Push the given search object onto the queue</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push(self, search: Search):
    &#34;&#34;&#34; Push the given search object onto the queue &#34;&#34;&#34;

    self._queue[search] = None
    self.game_service.mark_dirty(self)</code></pre>
</details>
</dd>
<dt id="server.matchmaker.matchmaker_queue.MatchmakerQueue.queue_pop_timer"><code class="name flex">
<span>async def <span class="ident">queue_pop_timer</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Periodically tries to match all Searches in the queue. The amount
of time until next queue 'pop' is determined by the number of players
in the queue.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def queue_pop_timer(self) -&gt; None:
    &#34;&#34;&#34; Periodically tries to match all Searches in the queue. The amount
    of time until next queue &#39;pop&#39; is determined by the number of players
    in the queue.
    &#34;&#34;&#34;
    self._logger.debug(&#34;MatchmakerQueue initialized for %s&#34;, self.name)
    while self._is_running:
        try:
            await self.timer.next_pop()

            await self.find_matches()

            number_of_unmatched_searches = len(self._queue)
            metrics.unmatched_searches.labels(self.name).set(
                number_of_unmatched_searches
            )

            # Any searches in the queue at this point were unable to find a
            # match this round and will have higher priority next round.

            self.game_service.mark_dirty(self)
        except Exception:
            self._logger.exception(
                &#34;Unexpected error during queue pop timer loop!&#34;
            )
            # To avoid potential busy loops
            await asyncio.sleep(1)</code></pre>
</details>
</dd>
<dt id="server.matchmaker.matchmaker_queue.MatchmakerQueue.search"><code class="name flex">
<span>async def <span class="ident">search</span></span>(<span>self, search: <a title="server.matchmaker.search.Search" href="search.html#server.matchmaker.search.Search">Search</a>) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Search for a match.</p>
<p>Puts a search object into the Queue and awaits completion.</p>
<p>:param player: Player to search for a matchup for</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def search(self, search: Search) -&gt; None:
    &#34;&#34;&#34;
    Search for a match.

    Puts a search object into the Queue and awaits completion.

    :param player: Player to search for a matchup for
    &#34;&#34;&#34;
    assert search is not None

    try:
        with MatchmakerSearchTimer(self.name):
            self.push(search)
            await search.await_match()
        self._logger.debug(&#34;Search complete: %s&#34;, search)
    except CancelledError:
        pass
    finally:
        # If the queue was cancelled, or some other error occurred,
        # make sure to clean up.
        self.game_service.mark_dirty(self)
        if search in self._queue:
            del self._queue[search]</code></pre>
</details>
</dd>
<dt id="server.matchmaker.matchmaker_queue.MatchmakerQueue.shutdown"><code class="name flex">
<span>def <span class="ident">shutdown</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shutdown(self):
    self._is_running = False</code></pre>
</details>
</dd>
<dt id="server.matchmaker.matchmaker_queue.MatchmakerQueue.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a fuzzy representation of the searches currently in the queue</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self):
    &#34;&#34;&#34;
    Return a fuzzy representation of the searches currently in the queue
    &#34;&#34;&#34;
    return {
        &#34;queue_name&#34;: self.name,
        &#34;queue_pop_time&#34;: datetime.fromtimestamp(
            self.timer.next_queue_pop, timezone.utc
        ).isoformat(),
        &#34;num_players&#34;: self.num_players,
        &#34;boundary_80s&#34;: [search.boundary_80 for search in self._queue.keys()],
        &#34;boundary_75s&#34;: [search.boundary_75 for search in self._queue.keys()],
        # TODO: Remove, the client should query the API for this
        &#34;team_size&#34;: self.team_size,
    }</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="server.matchmaker.matchmaker_queue.MatchmakerSearchTimer"><code class="flex name class">
<span>class <span class="ident">MatchmakerSearchTimer</span></span>
<span>(</span><span>queue_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MatchmakerSearchTimer:
    def __init__(self, queue_name):
        self.queue_name = queue_name

    def __enter__(self):
        self.start_time = time.monotonic()

    def __exit__(self, exc_type, exc_value, traceback):
        total_time = time.monotonic() - self.start_time
        if exc_type is None:
            status = &#34;successful&#34;
        elif exc_type is CancelledError:
            status = &#34;cancelled&#34;
        else:
            status = &#34;errored&#34;

        metric = metrics.matchmaker_searches.labels(self.queue_name, status)
        metric.observe(total_time)</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="server.matchmaker" href="index.html">server.matchmaker</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="server.matchmaker.matchmaker_queue.MatchmakerQueue" href="#server.matchmaker.matchmaker_queue.MatchmakerQueue">MatchmakerQueue</a></code></h4>
<ul class="">
<li><code><a title="server.matchmaker.matchmaker_queue.MatchmakerQueue.add_map_pool" href="#server.matchmaker.matchmaker_queue.MatchmakerQueue.add_map_pool">add_map_pool</a></code></li>
<li><code><a title="server.matchmaker.matchmaker_queue.MatchmakerQueue.find_matches" href="#server.matchmaker.matchmaker_queue.MatchmakerQueue.find_matches">find_matches</a></code></li>
<li><code><a title="server.matchmaker.matchmaker_queue.MatchmakerQueue.find_teams" href="#server.matchmaker.matchmaker_queue.MatchmakerQueue.find_teams">find_teams</a></code></li>
<li><code><a title="server.matchmaker.matchmaker_queue.MatchmakerQueue.get_map_pool_for_rating" href="#server.matchmaker.matchmaker_queue.MatchmakerQueue.get_map_pool_for_rating">get_map_pool_for_rating</a></code></li>
<li><code><a title="server.matchmaker.matchmaker_queue.MatchmakerQueue.initialize" href="#server.matchmaker.matchmaker_queue.MatchmakerQueue.initialize">initialize</a></code></li>
<li><code><a title="server.matchmaker.matchmaker_queue.MatchmakerQueue.match" href="#server.matchmaker.matchmaker_queue.MatchmakerQueue.match">match</a></code></li>
<li><code><a title="server.matchmaker.matchmaker_queue.MatchmakerQueue.num_players" href="#server.matchmaker.matchmaker_queue.MatchmakerQueue.num_players">num_players</a></code></li>
<li><code><a title="server.matchmaker.matchmaker_queue.MatchmakerQueue.push" href="#server.matchmaker.matchmaker_queue.MatchmakerQueue.push">push</a></code></li>
<li><code><a title="server.matchmaker.matchmaker_queue.MatchmakerQueue.queue_pop_timer" href="#server.matchmaker.matchmaker_queue.MatchmakerQueue.queue_pop_timer">queue_pop_timer</a></code></li>
<li><code><a title="server.matchmaker.matchmaker_queue.MatchmakerQueue.search" href="#server.matchmaker.matchmaker_queue.MatchmakerQueue.search">search</a></code></li>
<li><code><a title="server.matchmaker.matchmaker_queue.MatchmakerQueue.shutdown" href="#server.matchmaker.matchmaker_queue.MatchmakerQueue.shutdown">shutdown</a></code></li>
<li><code><a title="server.matchmaker.matchmaker_queue.MatchmakerQueue.to_dict" href="#server.matchmaker.matchmaker_queue.MatchmakerQueue.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="server.matchmaker.matchmaker_queue.MatchmakerSearchTimer" href="#server.matchmaker.matchmaker_queue.MatchmakerSearchTimer">MatchmakerSearchTimer</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>