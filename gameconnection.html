<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>server.gameconnection API documentation</title>
<meta name="description" content="Game communication over GpgNet" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>server.gameconnection</code></h1>
</header>
<section id="section-intro">
<p>Game communication over GpgNet</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Game communication over GpgNet
&#34;&#34;&#34;

import asyncio
import contextlib
import json
from typing import Any

from sqlalchemy import select

from server.db import FAFDatabase

from .config import TRACE
from .db.models import coop_leaderboard, coop_map, teamkills
from .decorators import with_logger
from .game_service import GameService
from .games import (
    CoopGame,
    Game,
    GameConnectionState,
    GameError,
    GameState,
    ValidityState,
    Victory
)
from .games.typedefs import FA
from .player_service import PlayerService
from .players import Player, PlayerState
from .protocol import DisconnectedError, GpgNetServerProtocol, Protocol


@with_logger
class GameConnection(GpgNetServerProtocol):
    &#34;&#34;&#34;
    Responsible for connections to the game, using the GPGNet protocol
    &#34;&#34;&#34;

    def __init__(
        self,
        database: FAFDatabase,
        game: Game,
        player: Player,
        protocol: Protocol,
        player_service: PlayerService,
        games: GameService,
        state: GameConnectionState = GameConnectionState.INITIALIZING
    ):
        &#34;&#34;&#34;
        Construct a new GameConnection
        &#34;&#34;&#34;
        super().__init__()
        self._db = database
        self._logger.debug(&#34;GameConnection initializing&#34;)

        self.protocol = protocol
        self._state = state
        self.game_service = games
        self.player_service = player_service

        self._player = player
        player.game_connection = self  # Set up weak reference to self
        self._game = game

        self.finished_sim = False

    @property
    def state(self) -&gt; GameConnectionState:
        return self._state

    @property
    def game(self) -&gt; Game:
        return self._game

    @game.setter
    def game(self, val: Game):
        self._game = val

    @property
    def player(self) -&gt; Player:
        return self._player

    @player.setter
    def player(self, val: Player):
        self._player = val

    def is_host(self) -&gt; bool:
        if not self.game or not self.player:
            return False

        return (
            self.player.state == PlayerState.HOSTING and
            self.player == self.game.host
        )

    async def send(self, message):
        &#34;&#34;&#34;
        Send a game message to the client.

        # Errors
        May raise `DisconnectedError`

        NOTE: When calling this on a connection other than `self` make sure to
        handle `DisconnectedError`, otherwise failure to send the message will
        cause the caller to be disconnected as well.
        &#34;&#34;&#34;
        message[&#34;target&#34;] = &#34;game&#34;

        self._logger.log(TRACE, &#34;&gt;&gt; %s: %s&#34;, self.player.login, message)
        await self.protocol.send_message(message)

    async def _handle_idle_state(self):
        &#34;&#34;&#34;
        This message is sent by FA when it doesn&#39;t know what to do.
        &#34;&#34;&#34;
        assert self.game

        if self.player == self.game.host:
            self.game.state = GameState.LOBBY
            self._state = GameConnectionState.CONNECTED_TO_HOST
            self.game.add_game_connection(self)
            self.player.state = PlayerState.HOSTING
        else:
            self.player.state = PlayerState.JOINING

    async def _handle_lobby_state(self):
        &#34;&#34;&#34;
        The game has told us it is ready and listening on
        self.player.game_port for UDP.
        We determine the connectivity of the peer and respond
        appropriately
        &#34;&#34;&#34;
        player_state = self.player.state
        if player_state == PlayerState.HOSTING:
            await self.send_HostGame(self.game.map_folder_name)
            self.game.set_hosted()
        # If the player is joining, we connect him to host
        # followed by the rest of the players.
        elif player_state == PlayerState.JOINING:
            await self.connect_to_host(self.game.host.game_connection)

            if self._state is GameConnectionState.ENDED:
                # We aborted while trying to connect
                return

            self._state = GameConnectionState.CONNECTED_TO_HOST

            try:
                self.game.add_game_connection(self)
            except GameError as e:
                await self.abort(f&#34;GameError while joining {self.game.id}: {e}&#34;)
                return

            tasks = []
            for peer in self.game.connections:
                if peer != self and peer.player != self.game.host:
                    self._logger.debug(&#34;%s connecting to %s&#34;, self.player, peer)
                    tasks.append(self.connect_to_peer(peer))
            await asyncio.gather(*tasks)

    async def connect_to_host(self, peer: &#34;GameConnection&#34;):
        &#34;&#34;&#34;
        Connect self to a given peer (host)
        &#34;&#34;&#34;
        if not peer or peer.player.state != PlayerState.HOSTING:
            await self.abort(&#34;The host left the lobby&#34;)
            return

        await self.send_JoinGame(peer.player.login, peer.player.id)

        if not peer:
            await self.abort(&#34;The host left the lobby&#34;)
            return

        await peer.send_ConnectToPeer(
            player_name=self.player.login,
            player_uid=self.player.id,
            offer=True
        )

    async def connect_to_peer(self, peer: &#34;GameConnection&#34;):
        &#34;&#34;&#34;
        Connect two peers
        &#34;&#34;&#34;
        if peer is not None:
            await self.send_ConnectToPeer(
                player_name=peer.player.login,
                player_uid=peer.player.id,
                offer=True
            )

        if peer is not None:
            with contextlib.suppress(DisconnectedError):
                await peer.send_ConnectToPeer(
                    player_name=self.player.login,
                    player_uid=self.player.id,
                    offer=False
                )

    async def handle_action(self, command: str, args: list[Any]):
        &#34;&#34;&#34;
        Handle GpgNetSend messages, wrapped in the JSON protocol
        &#34;&#34;&#34;
        try:
            await COMMAND_HANDLERS[command](self, *args)
        except KeyError:
            self._logger.warning(
                &#34;Unrecognized command %s: %s from player %s&#34;,
                command, args, self.player
            )
        except (TypeError, ValueError):
            self._logger.exception(&#34;Bad command arguments&#34;)
        except ConnectionError as e:
            raise e
        except Exception:  # pragma: no cover
            self._logger.exception(&#34;Something awful happened in a game thread!&#34;)
            await self.abort()

    async def handle_desync(self, *_args):  # pragma: no cover
        self.game.desyncs += 1

    async def handle_game_option(self, key: str, value: Any):
        if not self.is_host():
            return

        if key == &#34;Victory&#34;:
            self.game.gameOptions[&#34;Victory&#34;] = Victory.__members__.get(
                value.upper(), None
            )
        else:
            self.game.gameOptions[key] = value

        if key == &#34;Slots&#34;:
            self.game.max_players = int(value)
        elif key == &#34;ScenarioFile&#34;:
            raw = repr(value)
            self.game.map_scenario_path = \
                raw.replace(&#34;\\&#34;, &#34;/&#34;).replace(&#34;//&#34;, &#34;/&#34;).replace(&#34;&#39;&#34;, &#34;&#34;)
            self.game.map_file_path = &#34;maps/{}.zip&#34;.format(
                self.game.map_scenario_path.split(&#34;/&#34;)[2].lower()
            )
        elif key == &#34;Title&#34;:
            with contextlib.suppress(ValueError):
                self.game.name = value

        self._mark_dirty()

    async def handle_game_mods(self, mode: Any, args: list[Any]):
        if not self.is_host():
            return

        if mode == &#34;activated&#34;:
            # In this case args is the number of mods
            if int(args) == 0:
                self.game.mods = {}

        elif mode == &#34;uids&#34;:
            uids = str(args).split()
            self.game.mods = {uid: &#34;Unknown sim mod&#34; for uid in uids}
            async with self._db.acquire() as conn:
                rows = await conn.execute(
                    &#34;SELECT `uid`, `name` from `table_mod` WHERE `uid` in :ids&#34;,
                    ids=tuple(uids)
                )
                for row in rows:
                    self.game.mods[row.uid] = row.name
        else:
            self._logger.warning(&#34;Ignoring game mod: %s, %s&#34;, mode, args)
            return

        self._mark_dirty()

    async def handle_player_option(
        self, player_id: Any, key: Any, value: Any
    ):
        if not self.is_host():
            return

        self.game.set_player_option(int(player_id), key, value)
        self._mark_dirty()

    async def handle_ai_option(self, name: Any, key: Any, value: Any):
        if not self.is_host():
            return

        self.game.set_ai_option(str(name), key, value)
        self._mark_dirty()

    async def handle_clear_slot(self, slot: Any):
        if not self.is_host():
            return

        self.game.clear_slot(int(slot))
        self._mark_dirty()

    async def handle_game_result(self, army: Any, result: Any):
        army = int(army)
        result = str(result).lower()

        try:
            *metadata, result_type, score = result.split()
        except ValueError:
            self._logger.warning(&#34;Invalid result for %s reported: %s&#34;, army, result)
        else:
            await self.game.add_result(
                self.player.id, army, result_type, int(score), frozenset(metadata)
            )

    async def handle_operation_complete(
        self, primary: Any, secondary: Any, delta: str
    ):
        &#34;&#34;&#34;
        # Params
        - `primary`: are primary mission objectives complete?
        - `secondary`: are secondary mission objectives complete?
        - `delta`: the time it took to complete the mission
        &#34;&#34;&#34;
        primary = FA.ENABLED == primary
        secondary = FA.ENABLED == secondary

        if not primary:
            return

        if not isinstance(self.game, CoopGame):
            self._logger.warning(
                &#34;OperationComplete called for non-coop game: %s&#34;, self.game.id
            )
            return

        if self.game.validity != ValidityState.COOP_NOT_RANKED:
            return

        secondary, delta = secondary, str(delta)
        async with self._db.acquire() as conn:
            result = await conn.execute(
                select([coop_map.c.id]).where(
                    coop_map.c.filename == self.game.map_file_path
                )
            )
            row = result.fetchone()
            if not row:
                self._logger.debug(
                    &#34;can&#39;t find coop map: %s&#34;, self.game.map_file_path
                )
                return
            mission = row.id

            # Each player in a co-op game will send the OperationComplete
            # message but we only need to perform this insert once
            if not self.game.leaderboard_saved:
                await conn.execute(
                    coop_leaderboard.insert().values(
                        mission=mission,
                        gameuid=self.game.id,
                        secondary=secondary,
                        time=delta,
                        player_count=len(self.game.players),
                    )
                )
                self.game.leaderboard_saved = True

    async def handle_json_stats(self, stats: str):
        try:
            self.game.report_army_stats(stats)
        except json.JSONDecodeError:
            self._logger.warning(
                &#34;Malformed game stats reported by %s: &#39;...%s&#39;&#34;,
                self._player.login,
                stats[-20:]
            )

    async def handle_enforce_rating(self):
        self.game.enforce_rating = True

    async def handle_teamkill_report(
        self,
        gametime: Any,
        reporter_id: Any,
        reporter_name: str,
        teamkiller_id: Any,
        teamkiller_name: str,
    ):
        &#34;&#34;&#34;
        Sent when a player is teamkilled and clicks the &#39;Report&#39; button.

        # Params
        - `gametime`: seconds of gametime when kill happened
        - `reporter_id`: reporter id
        - `reporter_name`: reporter nickname (for debug purpose only)
        - `teamkiller_id`: teamkiller id
        - `teamkiller_name`: teamkiller nickname (for debug purpose only)
        &#34;&#34;&#34;
        pass

    async def handle_teamkill_happened(
        self,
        gametime: Any,
        victim_id: Any,
        victim_name: str,
        teamkiller_id: Any,
        teamkiller_name: str,
    ):
        &#34;&#34;&#34;
        Send automatically by the game whenever a teamkill happens. Takes
        the same parameters as TeamkillReport.

        # Params
        - `gametime`: seconds of gametime when kill happened
        - `victim_id`: victim id
        - `victim_name`: victim nickname (for debug purpose only)
        - `teamkiller_id`: teamkiller id
        - `teamkiller_name`: teamkiller nickname (for debug purpose only)
        &#34;&#34;&#34;
        victim_id = int(victim_id)
        teamkiller_id = int(teamkiller_id)

        if 0 in (victim_id, teamkiller_id):
            self._logger.debug(&#34;Ignoring teamkill for AI player&#34;)
            return

        async with self._db.acquire() as conn:
            await conn.execute(
                teamkills.insert().values(
                    teamkiller=teamkiller_id,
                    victim=victim_id,
                    game_id=self.game.id,
                    gametime=gametime,
                )
            )

    async def handle_ice_message(self, receiver_id: Any, ice_msg: str):
        receiver_id = int(receiver_id)
        peer = self.player_service.get_player(receiver_id)
        if not peer:
            self._logger.debug(
                &#34;Ignoring ICE message for unknown player: %s&#34;, receiver_id
            )
            return

        game_connection = peer.game_connection
        if not game_connection:
            self._logger.debug(
                &#34;Ignoring ICE message for player without game connection: %s&#34;, receiver_id
            )
            return

        try:
            await game_connection.send({
                &#34;command&#34;: &#34;IceMsg&#34;,
                &#34;args&#34;: [int(self.player.id), ice_msg]
            })
        except DisconnectedError:
            self._logger.debug(
                &#34;Failed to send ICE message to player due to a disconnect: %s&#34;,
                receiver_id
            )

    async def handle_game_state(self, state: str):
        &#34;&#34;&#34;
        Changes in game state
        &#34;&#34;&#34;

        if state == &#34;Idle&#34;:
            await self._handle_idle_state()
            # Don&#39;t mark as dirty
            return

        elif state == &#34;Lobby&#34;:
            # TODO: Do we still need to schedule with `ensure_future`?
            #
            # We do not yield from the task, since we
            # need to keep processing other commands while it runs
            await self._handle_lobby_state()

        elif state == &#34;Launching&#34;:
            if self.player.state != PlayerState.HOSTING:
                return

            if self.game.state is not GameState.LOBBY:
                self._logger.warning(
                    &#34;Trying to launch game %s in invalid state %s&#34;,
                    self.game,
                    self.game.state
                )
                return

            self._logger.info(&#34;Launching game %s&#34;, self.game)

            await self.game.launch()

            if len(self.game.mods.keys()) &gt; 0:
                async with self._db.acquire() as conn:
                    uids = list(self.game.mods.keys())
                    await conn.execute(
                        &#34;UPDATE mod_stats s JOIN mod_version v ON &#34;
                        &#34;v.mod_id = s.mod_id &#34;
                        &#34;SET s.times_played = s.times_played + 1 &#34;
                        &#34;WHERE v.uid in :ids&#34;,
                        ids=tuple(uids)
                    )
        # Signals that the FA executable has been closed
        elif state == &#34;Ended&#34;:
            await self.on_connection_lost()
        self._mark_dirty()

    async def handle_game_ended(self, *args:  list[Any]):
        &#34;&#34;&#34;
        Signals that the simulation has ended.
        &#34;&#34;&#34;
        self.finished_sim = True
        await self.game.check_game_finish(self.player)

    async def handle_rehost(self, *args: list[Any]):
        &#34;&#34;&#34;
        Signals that the user has rehosted the game. This is currently unused but
        included for documentation purposes.
        &#34;&#34;&#34;
        pass

    async def handle_launch_status(self, status: str):
        &#34;&#34;&#34;
        Currently is sent with status `Rejected` if a matchmaker game failed
        to start due to players using differing game settings.
        &#34;&#34;&#34;
        pass

    async def handle_bottleneck(self, *args: list[Any]):
        &#34;&#34;&#34;
        Not sure what this command means. This is currently unused but
        included for documentation purposes.
        &#34;&#34;&#34;
        pass

    async def handle_bottleneck_cleared(self, *args: list[Any]):
        &#34;&#34;&#34;
        Not sure what this command means. This is currently unused but
        included for documentation purposes.
        &#34;&#34;&#34;
        pass

    async def handle_disconnected(self, *args: list[Any]):
        &#34;&#34;&#34;
        Not sure what this command means. This is currently unused but
        included for documentation purposes.
        &#34;&#34;&#34;
        pass

    async def handle_chat(self, message: str):
        &#34;&#34;&#34;
        Whenever the player sends a chat message during the game lobby.
        &#34;&#34;&#34;
        pass

    async def handle_game_full(self):
        &#34;&#34;&#34;
        Sent when all game slots are full
        &#34;&#34;&#34;
        pass

    def _mark_dirty(self):
        if self.game:
            self.game_service.mark_dirty(self.game)

    async def abort(self, log_message: str = &#34;&#34;):
        &#34;&#34;&#34;
        Abort the connection

        Removes the GameConnection object from the any associated Game object,
        and deletes references to Player and Game held by this object.
        &#34;&#34;&#34;
        try:
            if self._state is GameConnectionState.ENDED:
                return

            self._logger.debug(&#34;%s.abort(%s)&#34;, self, log_message)

            if self.game.state is GameState.LOBBY:
                await self.disconnect_all_peers()

            self._state = GameConnectionState.ENDED
            await self.game.remove_game_connection(self)
            self._mark_dirty()
            self.player.state = PlayerState.IDLE
            if self.player.lobby_connection:
                self.player.lobby_connection.game_connection = None
            del self.player.game
            del self.player.game_connection
        except Exception as ex:  # pragma: no cover
            self._logger.debug(&#34;Exception in abort(): %s&#34;, ex)

    async def disconnect_all_peers(self):
        tasks = []
        for peer in self.game.connections:
            if peer == self:
                continue

            tasks.append(peer.send_DisconnectFromPeer(self.player.id))

        for fut in asyncio.as_completed(tasks):
            try:
                await fut
            except Exception:
                self._logger.debug(
                    &#34;peer_sendDisconnectFromPeer failed for player %i&#34;,
                    self.player.id,
                    exc_info=True
                )

    async def on_connection_lost(self):
        try:
            await self.game.remove_game_connection(self)
        except Exception as e:  # pragma: no cover
            self._logger.exception(e)
        finally:
            await self.abort()

    def __str__(self):
        return f&#34;GameConnection({self.player}, {self.game})&#34;


COMMAND_HANDLERS = {
    &#34;AIOption&#34;:             GameConnection.handle_ai_option,
    &#34;Bottleneck&#34;:           GameConnection.handle_bottleneck,
    &#34;BottleneckCleared&#34;:    GameConnection.handle_bottleneck_cleared,
    &#34;Chat&#34;:                 GameConnection.handle_chat,
    &#34;ClearSlot&#34;:            GameConnection.handle_clear_slot,
    &#34;Desync&#34;:               GameConnection.handle_desync,
    &#34;Disconnected&#34;:         GameConnection.handle_disconnected,
    &#34;EnforceRating&#34;:        GameConnection.handle_enforce_rating,
    &#34;GameEnded&#34;:            GameConnection.handle_game_ended,
    &#34;GameFull&#34;:             GameConnection.handle_game_full,
    &#34;GameMods&#34;:             GameConnection.handle_game_mods,
    &#34;GameOption&#34;:           GameConnection.handle_game_option,
    &#34;GameResult&#34;:           GameConnection.handle_game_result,
    &#34;GameState&#34;:            GameConnection.handle_game_state,
    &#34;IceMsg&#34;:               GameConnection.handle_ice_message,
    &#34;JsonStats&#34;:            GameConnection.handle_json_stats,
    &#34;LaunchStatus&#34;:         GameConnection.handle_launch_status,
    &#34;OperationComplete&#34;:    GameConnection.handle_operation_complete,
    &#34;PlayerOption&#34;:         GameConnection.handle_player_option,
    &#34;Rehost&#34;:               GameConnection.handle_rehost,
    &#34;TeamkillHappened&#34;:     GameConnection.handle_teamkill_happened,
    &#34;TeamkillReport&#34;:       GameConnection.handle_teamkill_report,
}</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="server.gameconnection.GameConnection"><code class="flex name class">
<span>class <span class="ident">GameConnection</span></span>
<span>(</span><span>database: <a title="server.db.FAFDatabase" href="db/index.html#server.db.FAFDatabase">FAFDatabase</a>, game: <a title="server.games.game.Game" href="games/game.html#server.games.game.Game">Game</a>, player: <a title="server.players.Player" href="players.html#server.players.Player">Player</a>, protocol: <a title="server.protocol.protocol.Protocol" href="protocol/protocol.html#server.protocol.protocol.Protocol">Protocol</a>, player_service: <a title="server.player_service.PlayerService" href="player_service.html#server.player_service.PlayerService">PlayerService</a>, games: <a title="server.game_service.GameService" href="game_service.html#server.game_service.GameService">GameService</a>, state: <a title="server.games.typedefs.GameConnectionState" href="games/typedefs.html#server.games.typedefs.GameConnectionState">GameConnectionState</a> = GameConnectionState.INITIALIZING)</span>
</code></dt>
<dd>
<div class="desc"><p>Responsible for connections to the game, using the GPGNet protocol</p>
<p>Construct a new GameConnection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@with_logger
class GameConnection(GpgNetServerProtocol):
    &#34;&#34;&#34;
    Responsible for connections to the game, using the GPGNet protocol
    &#34;&#34;&#34;

    def __init__(
        self,
        database: FAFDatabase,
        game: Game,
        player: Player,
        protocol: Protocol,
        player_service: PlayerService,
        games: GameService,
        state: GameConnectionState = GameConnectionState.INITIALIZING
    ):
        &#34;&#34;&#34;
        Construct a new GameConnection
        &#34;&#34;&#34;
        super().__init__()
        self._db = database
        self._logger.debug(&#34;GameConnection initializing&#34;)

        self.protocol = protocol
        self._state = state
        self.game_service = games
        self.player_service = player_service

        self._player = player
        player.game_connection = self  # Set up weak reference to self
        self._game = game

        self.finished_sim = False

    @property
    def state(self) -&gt; GameConnectionState:
        return self._state

    @property
    def game(self) -&gt; Game:
        return self._game

    @game.setter
    def game(self, val: Game):
        self._game = val

    @property
    def player(self) -&gt; Player:
        return self._player

    @player.setter
    def player(self, val: Player):
        self._player = val

    def is_host(self) -&gt; bool:
        if not self.game or not self.player:
            return False

        return (
            self.player.state == PlayerState.HOSTING and
            self.player == self.game.host
        )

    async def send(self, message):
        &#34;&#34;&#34;
        Send a game message to the client.

        # Errors
        May raise `DisconnectedError`

        NOTE: When calling this on a connection other than `self` make sure to
        handle `DisconnectedError`, otherwise failure to send the message will
        cause the caller to be disconnected as well.
        &#34;&#34;&#34;
        message[&#34;target&#34;] = &#34;game&#34;

        self._logger.log(TRACE, &#34;&gt;&gt; %s: %s&#34;, self.player.login, message)
        await self.protocol.send_message(message)

    async def _handle_idle_state(self):
        &#34;&#34;&#34;
        This message is sent by FA when it doesn&#39;t know what to do.
        &#34;&#34;&#34;
        assert self.game

        if self.player == self.game.host:
            self.game.state = GameState.LOBBY
            self._state = GameConnectionState.CONNECTED_TO_HOST
            self.game.add_game_connection(self)
            self.player.state = PlayerState.HOSTING
        else:
            self.player.state = PlayerState.JOINING

    async def _handle_lobby_state(self):
        &#34;&#34;&#34;
        The game has told us it is ready and listening on
        self.player.game_port for UDP.
        We determine the connectivity of the peer and respond
        appropriately
        &#34;&#34;&#34;
        player_state = self.player.state
        if player_state == PlayerState.HOSTING:
            await self.send_HostGame(self.game.map_folder_name)
            self.game.set_hosted()
        # If the player is joining, we connect him to host
        # followed by the rest of the players.
        elif player_state == PlayerState.JOINING:
            await self.connect_to_host(self.game.host.game_connection)

            if self._state is GameConnectionState.ENDED:
                # We aborted while trying to connect
                return

            self._state = GameConnectionState.CONNECTED_TO_HOST

            try:
                self.game.add_game_connection(self)
            except GameError as e:
                await self.abort(f&#34;GameError while joining {self.game.id}: {e}&#34;)
                return

            tasks = []
            for peer in self.game.connections:
                if peer != self and peer.player != self.game.host:
                    self._logger.debug(&#34;%s connecting to %s&#34;, self.player, peer)
                    tasks.append(self.connect_to_peer(peer))
            await asyncio.gather(*tasks)

    async def connect_to_host(self, peer: &#34;GameConnection&#34;):
        &#34;&#34;&#34;
        Connect self to a given peer (host)
        &#34;&#34;&#34;
        if not peer or peer.player.state != PlayerState.HOSTING:
            await self.abort(&#34;The host left the lobby&#34;)
            return

        await self.send_JoinGame(peer.player.login, peer.player.id)

        if not peer:
            await self.abort(&#34;The host left the lobby&#34;)
            return

        await peer.send_ConnectToPeer(
            player_name=self.player.login,
            player_uid=self.player.id,
            offer=True
        )

    async def connect_to_peer(self, peer: &#34;GameConnection&#34;):
        &#34;&#34;&#34;
        Connect two peers
        &#34;&#34;&#34;
        if peer is not None:
            await self.send_ConnectToPeer(
                player_name=peer.player.login,
                player_uid=peer.player.id,
                offer=True
            )

        if peer is not None:
            with contextlib.suppress(DisconnectedError):
                await peer.send_ConnectToPeer(
                    player_name=self.player.login,
                    player_uid=self.player.id,
                    offer=False
                )

    async def handle_action(self, command: str, args: list[Any]):
        &#34;&#34;&#34;
        Handle GpgNetSend messages, wrapped in the JSON protocol
        &#34;&#34;&#34;
        try:
            await COMMAND_HANDLERS[command](self, *args)
        except KeyError:
            self._logger.warning(
                &#34;Unrecognized command %s: %s from player %s&#34;,
                command, args, self.player
            )
        except (TypeError, ValueError):
            self._logger.exception(&#34;Bad command arguments&#34;)
        except ConnectionError as e:
            raise e
        except Exception:  # pragma: no cover
            self._logger.exception(&#34;Something awful happened in a game thread!&#34;)
            await self.abort()

    async def handle_desync(self, *_args):  # pragma: no cover
        self.game.desyncs += 1

    async def handle_game_option(self, key: str, value: Any):
        if not self.is_host():
            return

        if key == &#34;Victory&#34;:
            self.game.gameOptions[&#34;Victory&#34;] = Victory.__members__.get(
                value.upper(), None
            )
        else:
            self.game.gameOptions[key] = value

        if key == &#34;Slots&#34;:
            self.game.max_players = int(value)
        elif key == &#34;ScenarioFile&#34;:
            raw = repr(value)
            self.game.map_scenario_path = \
                raw.replace(&#34;\\&#34;, &#34;/&#34;).replace(&#34;//&#34;, &#34;/&#34;).replace(&#34;&#39;&#34;, &#34;&#34;)
            self.game.map_file_path = &#34;maps/{}.zip&#34;.format(
                self.game.map_scenario_path.split(&#34;/&#34;)[2].lower()
            )
        elif key == &#34;Title&#34;:
            with contextlib.suppress(ValueError):
                self.game.name = value

        self._mark_dirty()

    async def handle_game_mods(self, mode: Any, args: list[Any]):
        if not self.is_host():
            return

        if mode == &#34;activated&#34;:
            # In this case args is the number of mods
            if int(args) == 0:
                self.game.mods = {}

        elif mode == &#34;uids&#34;:
            uids = str(args).split()
            self.game.mods = {uid: &#34;Unknown sim mod&#34; for uid in uids}
            async with self._db.acquire() as conn:
                rows = await conn.execute(
                    &#34;SELECT `uid`, `name` from `table_mod` WHERE `uid` in :ids&#34;,
                    ids=tuple(uids)
                )
                for row in rows:
                    self.game.mods[row.uid] = row.name
        else:
            self._logger.warning(&#34;Ignoring game mod: %s, %s&#34;, mode, args)
            return

        self._mark_dirty()

    async def handle_player_option(
        self, player_id: Any, key: Any, value: Any
    ):
        if not self.is_host():
            return

        self.game.set_player_option(int(player_id), key, value)
        self._mark_dirty()

    async def handle_ai_option(self, name: Any, key: Any, value: Any):
        if not self.is_host():
            return

        self.game.set_ai_option(str(name), key, value)
        self._mark_dirty()

    async def handle_clear_slot(self, slot: Any):
        if not self.is_host():
            return

        self.game.clear_slot(int(slot))
        self._mark_dirty()

    async def handle_game_result(self, army: Any, result: Any):
        army = int(army)
        result = str(result).lower()

        try:
            *metadata, result_type, score = result.split()
        except ValueError:
            self._logger.warning(&#34;Invalid result for %s reported: %s&#34;, army, result)
        else:
            await self.game.add_result(
                self.player.id, army, result_type, int(score), frozenset(metadata)
            )

    async def handle_operation_complete(
        self, primary: Any, secondary: Any, delta: str
    ):
        &#34;&#34;&#34;
        # Params
        - `primary`: are primary mission objectives complete?
        - `secondary`: are secondary mission objectives complete?
        - `delta`: the time it took to complete the mission
        &#34;&#34;&#34;
        primary = FA.ENABLED == primary
        secondary = FA.ENABLED == secondary

        if not primary:
            return

        if not isinstance(self.game, CoopGame):
            self._logger.warning(
                &#34;OperationComplete called for non-coop game: %s&#34;, self.game.id
            )
            return

        if self.game.validity != ValidityState.COOP_NOT_RANKED:
            return

        secondary, delta = secondary, str(delta)
        async with self._db.acquire() as conn:
            result = await conn.execute(
                select([coop_map.c.id]).where(
                    coop_map.c.filename == self.game.map_file_path
                )
            )
            row = result.fetchone()
            if not row:
                self._logger.debug(
                    &#34;can&#39;t find coop map: %s&#34;, self.game.map_file_path
                )
                return
            mission = row.id

            # Each player in a co-op game will send the OperationComplete
            # message but we only need to perform this insert once
            if not self.game.leaderboard_saved:
                await conn.execute(
                    coop_leaderboard.insert().values(
                        mission=mission,
                        gameuid=self.game.id,
                        secondary=secondary,
                        time=delta,
                        player_count=len(self.game.players),
                    )
                )
                self.game.leaderboard_saved = True

    async def handle_json_stats(self, stats: str):
        try:
            self.game.report_army_stats(stats)
        except json.JSONDecodeError:
            self._logger.warning(
                &#34;Malformed game stats reported by %s: &#39;...%s&#39;&#34;,
                self._player.login,
                stats[-20:]
            )

    async def handle_enforce_rating(self):
        self.game.enforce_rating = True

    async def handle_teamkill_report(
        self,
        gametime: Any,
        reporter_id: Any,
        reporter_name: str,
        teamkiller_id: Any,
        teamkiller_name: str,
    ):
        &#34;&#34;&#34;
        Sent when a player is teamkilled and clicks the &#39;Report&#39; button.

        # Params
        - `gametime`: seconds of gametime when kill happened
        - `reporter_id`: reporter id
        - `reporter_name`: reporter nickname (for debug purpose only)
        - `teamkiller_id`: teamkiller id
        - `teamkiller_name`: teamkiller nickname (for debug purpose only)
        &#34;&#34;&#34;
        pass

    async def handle_teamkill_happened(
        self,
        gametime: Any,
        victim_id: Any,
        victim_name: str,
        teamkiller_id: Any,
        teamkiller_name: str,
    ):
        &#34;&#34;&#34;
        Send automatically by the game whenever a teamkill happens. Takes
        the same parameters as TeamkillReport.

        # Params
        - `gametime`: seconds of gametime when kill happened
        - `victim_id`: victim id
        - `victim_name`: victim nickname (for debug purpose only)
        - `teamkiller_id`: teamkiller id
        - `teamkiller_name`: teamkiller nickname (for debug purpose only)
        &#34;&#34;&#34;
        victim_id = int(victim_id)
        teamkiller_id = int(teamkiller_id)

        if 0 in (victim_id, teamkiller_id):
            self._logger.debug(&#34;Ignoring teamkill for AI player&#34;)
            return

        async with self._db.acquire() as conn:
            await conn.execute(
                teamkills.insert().values(
                    teamkiller=teamkiller_id,
                    victim=victim_id,
                    game_id=self.game.id,
                    gametime=gametime,
                )
            )

    async def handle_ice_message(self, receiver_id: Any, ice_msg: str):
        receiver_id = int(receiver_id)
        peer = self.player_service.get_player(receiver_id)
        if not peer:
            self._logger.debug(
                &#34;Ignoring ICE message for unknown player: %s&#34;, receiver_id
            )
            return

        game_connection = peer.game_connection
        if not game_connection:
            self._logger.debug(
                &#34;Ignoring ICE message for player without game connection: %s&#34;, receiver_id
            )
            return

        try:
            await game_connection.send({
                &#34;command&#34;: &#34;IceMsg&#34;,
                &#34;args&#34;: [int(self.player.id), ice_msg]
            })
        except DisconnectedError:
            self._logger.debug(
                &#34;Failed to send ICE message to player due to a disconnect: %s&#34;,
                receiver_id
            )

    async def handle_game_state(self, state: str):
        &#34;&#34;&#34;
        Changes in game state
        &#34;&#34;&#34;

        if state == &#34;Idle&#34;:
            await self._handle_idle_state()
            # Don&#39;t mark as dirty
            return

        elif state == &#34;Lobby&#34;:
            # TODO: Do we still need to schedule with `ensure_future`?
            #
            # We do not yield from the task, since we
            # need to keep processing other commands while it runs
            await self._handle_lobby_state()

        elif state == &#34;Launching&#34;:
            if self.player.state != PlayerState.HOSTING:
                return

            if self.game.state is not GameState.LOBBY:
                self._logger.warning(
                    &#34;Trying to launch game %s in invalid state %s&#34;,
                    self.game,
                    self.game.state
                )
                return

            self._logger.info(&#34;Launching game %s&#34;, self.game)

            await self.game.launch()

            if len(self.game.mods.keys()) &gt; 0:
                async with self._db.acquire() as conn:
                    uids = list(self.game.mods.keys())
                    await conn.execute(
                        &#34;UPDATE mod_stats s JOIN mod_version v ON &#34;
                        &#34;v.mod_id = s.mod_id &#34;
                        &#34;SET s.times_played = s.times_played + 1 &#34;
                        &#34;WHERE v.uid in :ids&#34;,
                        ids=tuple(uids)
                    )
        # Signals that the FA executable has been closed
        elif state == &#34;Ended&#34;:
            await self.on_connection_lost()
        self._mark_dirty()

    async def handle_game_ended(self, *args:  list[Any]):
        &#34;&#34;&#34;
        Signals that the simulation has ended.
        &#34;&#34;&#34;
        self.finished_sim = True
        await self.game.check_game_finish(self.player)

    async def handle_rehost(self, *args: list[Any]):
        &#34;&#34;&#34;
        Signals that the user has rehosted the game. This is currently unused but
        included for documentation purposes.
        &#34;&#34;&#34;
        pass

    async def handle_launch_status(self, status: str):
        &#34;&#34;&#34;
        Currently is sent with status `Rejected` if a matchmaker game failed
        to start due to players using differing game settings.
        &#34;&#34;&#34;
        pass

    async def handle_bottleneck(self, *args: list[Any]):
        &#34;&#34;&#34;
        Not sure what this command means. This is currently unused but
        included for documentation purposes.
        &#34;&#34;&#34;
        pass

    async def handle_bottleneck_cleared(self, *args: list[Any]):
        &#34;&#34;&#34;
        Not sure what this command means. This is currently unused but
        included for documentation purposes.
        &#34;&#34;&#34;
        pass

    async def handle_disconnected(self, *args: list[Any]):
        &#34;&#34;&#34;
        Not sure what this command means. This is currently unused but
        included for documentation purposes.
        &#34;&#34;&#34;
        pass

    async def handle_chat(self, message: str):
        &#34;&#34;&#34;
        Whenever the player sends a chat message during the game lobby.
        &#34;&#34;&#34;
        pass

    async def handle_game_full(self):
        &#34;&#34;&#34;
        Sent when all game slots are full
        &#34;&#34;&#34;
        pass

    def _mark_dirty(self):
        if self.game:
            self.game_service.mark_dirty(self.game)

    async def abort(self, log_message: str = &#34;&#34;):
        &#34;&#34;&#34;
        Abort the connection

        Removes the GameConnection object from the any associated Game object,
        and deletes references to Player and Game held by this object.
        &#34;&#34;&#34;
        try:
            if self._state is GameConnectionState.ENDED:
                return

            self._logger.debug(&#34;%s.abort(%s)&#34;, self, log_message)

            if self.game.state is GameState.LOBBY:
                await self.disconnect_all_peers()

            self._state = GameConnectionState.ENDED
            await self.game.remove_game_connection(self)
            self._mark_dirty()
            self.player.state = PlayerState.IDLE
            if self.player.lobby_connection:
                self.player.lobby_connection.game_connection = None
            del self.player.game
            del self.player.game_connection
        except Exception as ex:  # pragma: no cover
            self._logger.debug(&#34;Exception in abort(): %s&#34;, ex)

    async def disconnect_all_peers(self):
        tasks = []
        for peer in self.game.connections:
            if peer == self:
                continue

            tasks.append(peer.send_DisconnectFromPeer(self.player.id))

        for fut in asyncio.as_completed(tasks):
            try:
                await fut
            except Exception:
                self._logger.debug(
                    &#34;peer_sendDisconnectFromPeer failed for player %i&#34;,
                    self.player.id,
                    exc_info=True
                )

    async def on_connection_lost(self):
        try:
            await self.game.remove_game_connection(self)
        except Exception as e:  # pragma: no cover
            self._logger.exception(e)
        finally:
            await self.abort()

    def __str__(self):
        return f&#34;GameConnection({self.player}, {self.game})&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="server.protocol.gpgnet.GpgNetServerProtocol" href="protocol/gpgnet.html#server.protocol.gpgnet.GpgNetServerProtocol">GpgNetServerProtocol</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="server.gameconnection.GameConnection.game"><code class="name">var <span class="ident">game</span> : <a title="server.games.game.Game" href="games/game.html#server.games.game.Game">Game</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def game(self) -&gt; Game:
    return self._game</code></pre>
</details>
</dd>
<dt id="server.gameconnection.GameConnection.player"><code class="name">var <span class="ident">player</span> : <a title="server.players.Player" href="players.html#server.players.Player">Player</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def player(self) -&gt; Player:
    return self._player</code></pre>
</details>
</dd>
<dt id="server.gameconnection.GameConnection.state"><code class="name">var <span class="ident">state</span> : <a title="server.games.typedefs.GameConnectionState" href="games/typedefs.html#server.games.typedefs.GameConnectionState">GameConnectionState</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def state(self) -&gt; GameConnectionState:
    return self._state</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="server.gameconnection.GameConnection.abort"><code class="name flex">
<span>async def <span class="ident">abort</span></span>(<span>self, log_message: str = '')</span>
</code></dt>
<dd>
<div class="desc"><p>Abort the connection</p>
<p>Removes the GameConnection object from the any associated Game object,
and deletes references to Player and Game held by this object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def abort(self, log_message: str = &#34;&#34;):
    &#34;&#34;&#34;
    Abort the connection

    Removes the GameConnection object from the any associated Game object,
    and deletes references to Player and Game held by this object.
    &#34;&#34;&#34;
    try:
        if self._state is GameConnectionState.ENDED:
            return

        self._logger.debug(&#34;%s.abort(%s)&#34;, self, log_message)

        if self.game.state is GameState.LOBBY:
            await self.disconnect_all_peers()

        self._state = GameConnectionState.ENDED
        await self.game.remove_game_connection(self)
        self._mark_dirty()
        self.player.state = PlayerState.IDLE
        if self.player.lobby_connection:
            self.player.lobby_connection.game_connection = None
        del self.player.game
        del self.player.game_connection
    except Exception as ex:  # pragma: no cover
        self._logger.debug(&#34;Exception in abort(): %s&#34;, ex)</code></pre>
</details>
</dd>
<dt id="server.gameconnection.GameConnection.connect_to_host"><code class="name flex">
<span>async def <span class="ident">connect_to_host</span></span>(<span>self, peer: <a title="server.gameconnection.GameConnection" href="#server.gameconnection.GameConnection">GameConnection</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Connect self to a given peer (host)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def connect_to_host(self, peer: &#34;GameConnection&#34;):
    &#34;&#34;&#34;
    Connect self to a given peer (host)
    &#34;&#34;&#34;
    if not peer or peer.player.state != PlayerState.HOSTING:
        await self.abort(&#34;The host left the lobby&#34;)
        return

    await self.send_JoinGame(peer.player.login, peer.player.id)

    if not peer:
        await self.abort(&#34;The host left the lobby&#34;)
        return

    await peer.send_ConnectToPeer(
        player_name=self.player.login,
        player_uid=self.player.id,
        offer=True
    )</code></pre>
</details>
</dd>
<dt id="server.gameconnection.GameConnection.connect_to_peer"><code class="name flex">
<span>async def <span class="ident">connect_to_peer</span></span>(<span>self, peer: <a title="server.gameconnection.GameConnection" href="#server.gameconnection.GameConnection">GameConnection</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Connect two peers</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def connect_to_peer(self, peer: &#34;GameConnection&#34;):
    &#34;&#34;&#34;
    Connect two peers
    &#34;&#34;&#34;
    if peer is not None:
        await self.send_ConnectToPeer(
            player_name=peer.player.login,
            player_uid=peer.player.id,
            offer=True
        )

    if peer is not None:
        with contextlib.suppress(DisconnectedError):
            await peer.send_ConnectToPeer(
                player_name=self.player.login,
                player_uid=self.player.id,
                offer=False
            )</code></pre>
</details>
</dd>
<dt id="server.gameconnection.GameConnection.disconnect_all_peers"><code class="name flex">
<span>async def <span class="ident">disconnect_all_peers</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def disconnect_all_peers(self):
    tasks = []
    for peer in self.game.connections:
        if peer == self:
            continue

        tasks.append(peer.send_DisconnectFromPeer(self.player.id))

    for fut in asyncio.as_completed(tasks):
        try:
            await fut
        except Exception:
            self._logger.debug(
                &#34;peer_sendDisconnectFromPeer failed for player %i&#34;,
                self.player.id,
                exc_info=True
            )</code></pre>
</details>
</dd>
<dt id="server.gameconnection.GameConnection.handle_action"><code class="name flex">
<span>async def <span class="ident">handle_action</span></span>(<span>self, command: str, args: list[typing.Any])</span>
</code></dt>
<dd>
<div class="desc"><p>Handle GpgNetSend messages, wrapped in the JSON protocol</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_action(self, command: str, args: list[Any]):
    &#34;&#34;&#34;
    Handle GpgNetSend messages, wrapped in the JSON protocol
    &#34;&#34;&#34;
    try:
        await COMMAND_HANDLERS[command](self, *args)
    except KeyError:
        self._logger.warning(
            &#34;Unrecognized command %s: %s from player %s&#34;,
            command, args, self.player
        )
    except (TypeError, ValueError):
        self._logger.exception(&#34;Bad command arguments&#34;)
    except ConnectionError as e:
        raise e
    except Exception:  # pragma: no cover
        self._logger.exception(&#34;Something awful happened in a game thread!&#34;)
        await self.abort()</code></pre>
</details>
</dd>
<dt id="server.gameconnection.GameConnection.handle_ai_option"><code class="name flex">
<span>async def <span class="ident">handle_ai_option</span></span>(<span>self, name: Any, key: Any, value: Any)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_ai_option(self, name: Any, key: Any, value: Any):
    if not self.is_host():
        return

    self.game.set_ai_option(str(name), key, value)
    self._mark_dirty()</code></pre>
</details>
</dd>
<dt id="server.gameconnection.GameConnection.handle_bottleneck"><code class="name flex">
<span>async def <span class="ident">handle_bottleneck</span></span>(<span>self, *args: list[typing.Any])</span>
</code></dt>
<dd>
<div class="desc"><p>Not sure what this command means. This is currently unused but
included for documentation purposes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_bottleneck(self, *args: list[Any]):
    &#34;&#34;&#34;
    Not sure what this command means. This is currently unused but
    included for documentation purposes.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="server.gameconnection.GameConnection.handle_bottleneck_cleared"><code class="name flex">
<span>async def <span class="ident">handle_bottleneck_cleared</span></span>(<span>self, *args: list[typing.Any])</span>
</code></dt>
<dd>
<div class="desc"><p>Not sure what this command means. This is currently unused but
included for documentation purposes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_bottleneck_cleared(self, *args: list[Any]):
    &#34;&#34;&#34;
    Not sure what this command means. This is currently unused but
    included for documentation purposes.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="server.gameconnection.GameConnection.handle_chat"><code class="name flex">
<span>async def <span class="ident">handle_chat</span></span>(<span>self, message: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Whenever the player sends a chat message during the game lobby.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_chat(self, message: str):
    &#34;&#34;&#34;
    Whenever the player sends a chat message during the game lobby.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="server.gameconnection.GameConnection.handle_clear_slot"><code class="name flex">
<span>async def <span class="ident">handle_clear_slot</span></span>(<span>self, slot: Any)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_clear_slot(self, slot: Any):
    if not self.is_host():
        return

    self.game.clear_slot(int(slot))
    self._mark_dirty()</code></pre>
</details>
</dd>
<dt id="server.gameconnection.GameConnection.handle_desync"><code class="name flex">
<span>async def <span class="ident">handle_desync</span></span>(<span>self, *_args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_desync(self, *_args):  # pragma: no cover
    self.game.desyncs += 1</code></pre>
</details>
</dd>
<dt id="server.gameconnection.GameConnection.handle_disconnected"><code class="name flex">
<span>async def <span class="ident">handle_disconnected</span></span>(<span>self, *args: list[typing.Any])</span>
</code></dt>
<dd>
<div class="desc"><p>Not sure what this command means. This is currently unused but
included for documentation purposes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_disconnected(self, *args: list[Any]):
    &#34;&#34;&#34;
    Not sure what this command means. This is currently unused but
    included for documentation purposes.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="server.gameconnection.GameConnection.handle_enforce_rating"><code class="name flex">
<span>async def <span class="ident">handle_enforce_rating</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_enforce_rating(self):
    self.game.enforce_rating = True</code></pre>
</details>
</dd>
<dt id="server.gameconnection.GameConnection.handle_game_ended"><code class="name flex">
<span>async def <span class="ident">handle_game_ended</span></span>(<span>self, *args: list[typing.Any])</span>
</code></dt>
<dd>
<div class="desc"><p>Signals that the simulation has ended.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_game_ended(self, *args:  list[Any]):
    &#34;&#34;&#34;
    Signals that the simulation has ended.
    &#34;&#34;&#34;
    self.finished_sim = True
    await self.game.check_game_finish(self.player)</code></pre>
</details>
</dd>
<dt id="server.gameconnection.GameConnection.handle_game_full"><code class="name flex">
<span>async def <span class="ident">handle_game_full</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Sent when all game slots are full</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_game_full(self):
    &#34;&#34;&#34;
    Sent when all game slots are full
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="server.gameconnection.GameConnection.handle_game_mods"><code class="name flex">
<span>async def <span class="ident">handle_game_mods</span></span>(<span>self, mode: Any, args: list[typing.Any])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_game_mods(self, mode: Any, args: list[Any]):
    if not self.is_host():
        return

    if mode == &#34;activated&#34;:
        # In this case args is the number of mods
        if int(args) == 0:
            self.game.mods = {}

    elif mode == &#34;uids&#34;:
        uids = str(args).split()
        self.game.mods = {uid: &#34;Unknown sim mod&#34; for uid in uids}
        async with self._db.acquire() as conn:
            rows = await conn.execute(
                &#34;SELECT `uid`, `name` from `table_mod` WHERE `uid` in :ids&#34;,
                ids=tuple(uids)
            )
            for row in rows:
                self.game.mods[row.uid] = row.name
    else:
        self._logger.warning(&#34;Ignoring game mod: %s, %s&#34;, mode, args)
        return

    self._mark_dirty()</code></pre>
</details>
</dd>
<dt id="server.gameconnection.GameConnection.handle_game_option"><code class="name flex">
<span>async def <span class="ident">handle_game_option</span></span>(<span>self, key: str, value: Any)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_game_option(self, key: str, value: Any):
    if not self.is_host():
        return

    if key == &#34;Victory&#34;:
        self.game.gameOptions[&#34;Victory&#34;] = Victory.__members__.get(
            value.upper(), None
        )
    else:
        self.game.gameOptions[key] = value

    if key == &#34;Slots&#34;:
        self.game.max_players = int(value)
    elif key == &#34;ScenarioFile&#34;:
        raw = repr(value)
        self.game.map_scenario_path = \
            raw.replace(&#34;\\&#34;, &#34;/&#34;).replace(&#34;//&#34;, &#34;/&#34;).replace(&#34;&#39;&#34;, &#34;&#34;)
        self.game.map_file_path = &#34;maps/{}.zip&#34;.format(
            self.game.map_scenario_path.split(&#34;/&#34;)[2].lower()
        )
    elif key == &#34;Title&#34;:
        with contextlib.suppress(ValueError):
            self.game.name = value

    self._mark_dirty()</code></pre>
</details>
</dd>
<dt id="server.gameconnection.GameConnection.handle_game_result"><code class="name flex">
<span>async def <span class="ident">handle_game_result</span></span>(<span>self, army: Any, result: Any)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_game_result(self, army: Any, result: Any):
    army = int(army)
    result = str(result).lower()

    try:
        *metadata, result_type, score = result.split()
    except ValueError:
        self._logger.warning(&#34;Invalid result for %s reported: %s&#34;, army, result)
    else:
        await self.game.add_result(
            self.player.id, army, result_type, int(score), frozenset(metadata)
        )</code></pre>
</details>
</dd>
<dt id="server.gameconnection.GameConnection.handle_game_state"><code class="name flex">
<span>async def <span class="ident">handle_game_state</span></span>(<span>self, state: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Changes in game state</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_game_state(self, state: str):
    &#34;&#34;&#34;
    Changes in game state
    &#34;&#34;&#34;

    if state == &#34;Idle&#34;:
        await self._handle_idle_state()
        # Don&#39;t mark as dirty
        return

    elif state == &#34;Lobby&#34;:
        # TODO: Do we still need to schedule with `ensure_future`?
        #
        # We do not yield from the task, since we
        # need to keep processing other commands while it runs
        await self._handle_lobby_state()

    elif state == &#34;Launching&#34;:
        if self.player.state != PlayerState.HOSTING:
            return

        if self.game.state is not GameState.LOBBY:
            self._logger.warning(
                &#34;Trying to launch game %s in invalid state %s&#34;,
                self.game,
                self.game.state
            )
            return

        self._logger.info(&#34;Launching game %s&#34;, self.game)

        await self.game.launch()

        if len(self.game.mods.keys()) &gt; 0:
            async with self._db.acquire() as conn:
                uids = list(self.game.mods.keys())
                await conn.execute(
                    &#34;UPDATE mod_stats s JOIN mod_version v ON &#34;
                    &#34;v.mod_id = s.mod_id &#34;
                    &#34;SET s.times_played = s.times_played + 1 &#34;
                    &#34;WHERE v.uid in :ids&#34;,
                    ids=tuple(uids)
                )
    # Signals that the FA executable has been closed
    elif state == &#34;Ended&#34;:
        await self.on_connection_lost()
    self._mark_dirty()</code></pre>
</details>
</dd>
<dt id="server.gameconnection.GameConnection.handle_ice_message"><code class="name flex">
<span>async def <span class="ident">handle_ice_message</span></span>(<span>self, receiver_id: Any, ice_msg: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_ice_message(self, receiver_id: Any, ice_msg: str):
    receiver_id = int(receiver_id)
    peer = self.player_service.get_player(receiver_id)
    if not peer:
        self._logger.debug(
            &#34;Ignoring ICE message for unknown player: %s&#34;, receiver_id
        )
        return

    game_connection = peer.game_connection
    if not game_connection:
        self._logger.debug(
            &#34;Ignoring ICE message for player without game connection: %s&#34;, receiver_id
        )
        return

    try:
        await game_connection.send({
            &#34;command&#34;: &#34;IceMsg&#34;,
            &#34;args&#34;: [int(self.player.id), ice_msg]
        })
    except DisconnectedError:
        self._logger.debug(
            &#34;Failed to send ICE message to player due to a disconnect: %s&#34;,
            receiver_id
        )</code></pre>
</details>
</dd>
<dt id="server.gameconnection.GameConnection.handle_json_stats"><code class="name flex">
<span>async def <span class="ident">handle_json_stats</span></span>(<span>self, stats: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_json_stats(self, stats: str):
    try:
        self.game.report_army_stats(stats)
    except json.JSONDecodeError:
        self._logger.warning(
            &#34;Malformed game stats reported by %s: &#39;...%s&#39;&#34;,
            self._player.login,
            stats[-20:]
        )</code></pre>
</details>
</dd>
<dt id="server.gameconnection.GameConnection.handle_launch_status"><code class="name flex">
<span>async def <span class="ident">handle_launch_status</span></span>(<span>self, status: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Currently is sent with status <code>Rejected</code> if a matchmaker game failed
to start due to players using differing game settings.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_launch_status(self, status: str):
    &#34;&#34;&#34;
    Currently is sent with status `Rejected` if a matchmaker game failed
    to start due to players using differing game settings.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="server.gameconnection.GameConnection.handle_operation_complete"><code class="name flex">
<span>async def <span class="ident">handle_operation_complete</span></span>(<span>self, primary: Any, secondary: Any, delta: str)</span>
</code></dt>
<dd>
<div class="desc"><h1 id="params">Params</h1>
<ul>
<li><code>primary</code>: are primary mission objectives complete?</li>
<li><code>secondary</code>: are secondary mission objectives complete?</li>
<li><code>delta</code>: the time it took to complete the mission</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_operation_complete(
    self, primary: Any, secondary: Any, delta: str
):
    &#34;&#34;&#34;
    # Params
    - `primary`: are primary mission objectives complete?
    - `secondary`: are secondary mission objectives complete?
    - `delta`: the time it took to complete the mission
    &#34;&#34;&#34;
    primary = FA.ENABLED == primary
    secondary = FA.ENABLED == secondary

    if not primary:
        return

    if not isinstance(self.game, CoopGame):
        self._logger.warning(
            &#34;OperationComplete called for non-coop game: %s&#34;, self.game.id
        )
        return

    if self.game.validity != ValidityState.COOP_NOT_RANKED:
        return

    secondary, delta = secondary, str(delta)
    async with self._db.acquire() as conn:
        result = await conn.execute(
            select([coop_map.c.id]).where(
                coop_map.c.filename == self.game.map_file_path
            )
        )
        row = result.fetchone()
        if not row:
            self._logger.debug(
                &#34;can&#39;t find coop map: %s&#34;, self.game.map_file_path
            )
            return
        mission = row.id

        # Each player in a co-op game will send the OperationComplete
        # message but we only need to perform this insert once
        if not self.game.leaderboard_saved:
            await conn.execute(
                coop_leaderboard.insert().values(
                    mission=mission,
                    gameuid=self.game.id,
                    secondary=secondary,
                    time=delta,
                    player_count=len(self.game.players),
                )
            )
            self.game.leaderboard_saved = True</code></pre>
</details>
</dd>
<dt id="server.gameconnection.GameConnection.handle_player_option"><code class="name flex">
<span>async def <span class="ident">handle_player_option</span></span>(<span>self, player_id: Any, key: Any, value: Any)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_player_option(
    self, player_id: Any, key: Any, value: Any
):
    if not self.is_host():
        return

    self.game.set_player_option(int(player_id), key, value)
    self._mark_dirty()</code></pre>
</details>
</dd>
<dt id="server.gameconnection.GameConnection.handle_rehost"><code class="name flex">
<span>async def <span class="ident">handle_rehost</span></span>(<span>self, *args: list[typing.Any])</span>
</code></dt>
<dd>
<div class="desc"><p>Signals that the user has rehosted the game. This is currently unused but
included for documentation purposes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_rehost(self, *args: list[Any]):
    &#34;&#34;&#34;
    Signals that the user has rehosted the game. This is currently unused but
    included for documentation purposes.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="server.gameconnection.GameConnection.handle_teamkill_happened"><code class="name flex">
<span>async def <span class="ident">handle_teamkill_happened</span></span>(<span>self, gametime: Any, victim_id: Any, victim_name: str, teamkiller_id: Any, teamkiller_name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Send automatically by the game whenever a teamkill happens. Takes
the same parameters as TeamkillReport.</p>
<h1 id="params">Params</h1>
<ul>
<li><code>gametime</code>: seconds of gametime when kill happened</li>
<li><code>victim_id</code>: victim id</li>
<li><code>victim_name</code>: victim nickname (for debug purpose only)</li>
<li><code>teamkiller_id</code>: teamkiller id</li>
<li><code>teamkiller_name</code>: teamkiller nickname (for debug purpose only)</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_teamkill_happened(
    self,
    gametime: Any,
    victim_id: Any,
    victim_name: str,
    teamkiller_id: Any,
    teamkiller_name: str,
):
    &#34;&#34;&#34;
    Send automatically by the game whenever a teamkill happens. Takes
    the same parameters as TeamkillReport.

    # Params
    - `gametime`: seconds of gametime when kill happened
    - `victim_id`: victim id
    - `victim_name`: victim nickname (for debug purpose only)
    - `teamkiller_id`: teamkiller id
    - `teamkiller_name`: teamkiller nickname (for debug purpose only)
    &#34;&#34;&#34;
    victim_id = int(victim_id)
    teamkiller_id = int(teamkiller_id)

    if 0 in (victim_id, teamkiller_id):
        self._logger.debug(&#34;Ignoring teamkill for AI player&#34;)
        return

    async with self._db.acquire() as conn:
        await conn.execute(
            teamkills.insert().values(
                teamkiller=teamkiller_id,
                victim=victim_id,
                game_id=self.game.id,
                gametime=gametime,
            )
        )</code></pre>
</details>
</dd>
<dt id="server.gameconnection.GameConnection.handle_teamkill_report"><code class="name flex">
<span>async def <span class="ident">handle_teamkill_report</span></span>(<span>self, gametime: Any, reporter_id: Any, reporter_name: str, teamkiller_id: Any, teamkiller_name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Sent when a player is teamkilled and clicks the 'Report' button.</p>
<h1 id="params">Params</h1>
<ul>
<li><code>gametime</code>: seconds of gametime when kill happened</li>
<li><code>reporter_id</code>: reporter id</li>
<li><code>reporter_name</code>: reporter nickname (for debug purpose only)</li>
<li><code>teamkiller_id</code>: teamkiller id</li>
<li><code>teamkiller_name</code>: teamkiller nickname (for debug purpose only)</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_teamkill_report(
    self,
    gametime: Any,
    reporter_id: Any,
    reporter_name: str,
    teamkiller_id: Any,
    teamkiller_name: str,
):
    &#34;&#34;&#34;
    Sent when a player is teamkilled and clicks the &#39;Report&#39; button.

    # Params
    - `gametime`: seconds of gametime when kill happened
    - `reporter_id`: reporter id
    - `reporter_name`: reporter nickname (for debug purpose only)
    - `teamkiller_id`: teamkiller id
    - `teamkiller_name`: teamkiller nickname (for debug purpose only)
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="server.gameconnection.GameConnection.is_host"><code class="name flex">
<span>def <span class="ident">is_host</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_host(self) -&gt; bool:
    if not self.game or not self.player:
        return False

    return (
        self.player.state == PlayerState.HOSTING and
        self.player == self.game.host
    )</code></pre>
</details>
</dd>
<dt id="server.gameconnection.GameConnection.on_connection_lost"><code class="name flex">
<span>async def <span class="ident">on_connection_lost</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def on_connection_lost(self):
    try:
        await self.game.remove_game_connection(self)
    except Exception as e:  # pragma: no cover
        self._logger.exception(e)
    finally:
        await self.abort()</code></pre>
</details>
</dd>
<dt id="server.gameconnection.GameConnection.send"><code class="name flex">
<span>async def <span class="ident">send</span></span>(<span>self, message)</span>
</code></dt>
<dd>
<div class="desc"><p>Send a game message to the client.</p>
<h1 id="errors">Errors</h1>
<p>May raise <code>DisconnectedError</code></p>
<p>NOTE: When calling this on a connection other than <code>self</code> make sure to
handle <code>DisconnectedError</code>, otherwise failure to send the message will
cause the caller to be disconnected as well.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send(self, message):
    &#34;&#34;&#34;
    Send a game message to the client.

    # Errors
    May raise `DisconnectedError`

    NOTE: When calling this on a connection other than `self` make sure to
    handle `DisconnectedError`, otherwise failure to send the message will
    cause the caller to be disconnected as well.
    &#34;&#34;&#34;
    message[&#34;target&#34;] = &#34;game&#34;

    self._logger.log(TRACE, &#34;&gt;&gt; %s: %s&#34;, self.player.login, message)
    await self.protocol.send_message(message)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="server.protocol.gpgnet.GpgNetServerProtocol" href="protocol/gpgnet.html#server.protocol.gpgnet.GpgNetServerProtocol">GpgNetServerProtocol</a></b></code>:
<ul class="hlist">
<li><code><a title="server.protocol.gpgnet.GpgNetServerProtocol.send_ConnectToPeer" href="protocol/gpgnet.html#server.protocol.gpgnet.GpgNetServerProtocol.send_ConnectToPeer">send_ConnectToPeer</a></code></li>
<li><code><a title="server.protocol.gpgnet.GpgNetServerProtocol.send_DisconnectFromPeer" href="protocol/gpgnet.html#server.protocol.gpgnet.GpgNetServerProtocol.send_DisconnectFromPeer">send_DisconnectFromPeer</a></code></li>
<li><code><a title="server.protocol.gpgnet.GpgNetServerProtocol.send_HostGame" href="protocol/gpgnet.html#server.protocol.gpgnet.GpgNetServerProtocol.send_HostGame">send_HostGame</a></code></li>
<li><code><a title="server.protocol.gpgnet.GpgNetServerProtocol.send_JoinGame" href="protocol/gpgnet.html#server.protocol.gpgnet.GpgNetServerProtocol.send_JoinGame">send_JoinGame</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="server" href="index.html">server</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="server.gameconnection.GameConnection" href="#server.gameconnection.GameConnection">GameConnection</a></code></h4>
<ul class="">
<li><code><a title="server.gameconnection.GameConnection.abort" href="#server.gameconnection.GameConnection.abort">abort</a></code></li>
<li><code><a title="server.gameconnection.GameConnection.connect_to_host" href="#server.gameconnection.GameConnection.connect_to_host">connect_to_host</a></code></li>
<li><code><a title="server.gameconnection.GameConnection.connect_to_peer" href="#server.gameconnection.GameConnection.connect_to_peer">connect_to_peer</a></code></li>
<li><code><a title="server.gameconnection.GameConnection.disconnect_all_peers" href="#server.gameconnection.GameConnection.disconnect_all_peers">disconnect_all_peers</a></code></li>
<li><code><a title="server.gameconnection.GameConnection.game" href="#server.gameconnection.GameConnection.game">game</a></code></li>
<li><code><a title="server.gameconnection.GameConnection.handle_action" href="#server.gameconnection.GameConnection.handle_action">handle_action</a></code></li>
<li><code><a title="server.gameconnection.GameConnection.handle_ai_option" href="#server.gameconnection.GameConnection.handle_ai_option">handle_ai_option</a></code></li>
<li><code><a title="server.gameconnection.GameConnection.handle_bottleneck" href="#server.gameconnection.GameConnection.handle_bottleneck">handle_bottleneck</a></code></li>
<li><code><a title="server.gameconnection.GameConnection.handle_bottleneck_cleared" href="#server.gameconnection.GameConnection.handle_bottleneck_cleared">handle_bottleneck_cleared</a></code></li>
<li><code><a title="server.gameconnection.GameConnection.handle_chat" href="#server.gameconnection.GameConnection.handle_chat">handle_chat</a></code></li>
<li><code><a title="server.gameconnection.GameConnection.handle_clear_slot" href="#server.gameconnection.GameConnection.handle_clear_slot">handle_clear_slot</a></code></li>
<li><code><a title="server.gameconnection.GameConnection.handle_desync" href="#server.gameconnection.GameConnection.handle_desync">handle_desync</a></code></li>
<li><code><a title="server.gameconnection.GameConnection.handle_disconnected" href="#server.gameconnection.GameConnection.handle_disconnected">handle_disconnected</a></code></li>
<li><code><a title="server.gameconnection.GameConnection.handle_enforce_rating" href="#server.gameconnection.GameConnection.handle_enforce_rating">handle_enforce_rating</a></code></li>
<li><code><a title="server.gameconnection.GameConnection.handle_game_ended" href="#server.gameconnection.GameConnection.handle_game_ended">handle_game_ended</a></code></li>
<li><code><a title="server.gameconnection.GameConnection.handle_game_full" href="#server.gameconnection.GameConnection.handle_game_full">handle_game_full</a></code></li>
<li><code><a title="server.gameconnection.GameConnection.handle_game_mods" href="#server.gameconnection.GameConnection.handle_game_mods">handle_game_mods</a></code></li>
<li><code><a title="server.gameconnection.GameConnection.handle_game_option" href="#server.gameconnection.GameConnection.handle_game_option">handle_game_option</a></code></li>
<li><code><a title="server.gameconnection.GameConnection.handle_game_result" href="#server.gameconnection.GameConnection.handle_game_result">handle_game_result</a></code></li>
<li><code><a title="server.gameconnection.GameConnection.handle_game_state" href="#server.gameconnection.GameConnection.handle_game_state">handle_game_state</a></code></li>
<li><code><a title="server.gameconnection.GameConnection.handle_ice_message" href="#server.gameconnection.GameConnection.handle_ice_message">handle_ice_message</a></code></li>
<li><code><a title="server.gameconnection.GameConnection.handle_json_stats" href="#server.gameconnection.GameConnection.handle_json_stats">handle_json_stats</a></code></li>
<li><code><a title="server.gameconnection.GameConnection.handle_launch_status" href="#server.gameconnection.GameConnection.handle_launch_status">handle_launch_status</a></code></li>
<li><code><a title="server.gameconnection.GameConnection.handle_operation_complete" href="#server.gameconnection.GameConnection.handle_operation_complete">handle_operation_complete</a></code></li>
<li><code><a title="server.gameconnection.GameConnection.handle_player_option" href="#server.gameconnection.GameConnection.handle_player_option">handle_player_option</a></code></li>
<li><code><a title="server.gameconnection.GameConnection.handle_rehost" href="#server.gameconnection.GameConnection.handle_rehost">handle_rehost</a></code></li>
<li><code><a title="server.gameconnection.GameConnection.handle_teamkill_happened" href="#server.gameconnection.GameConnection.handle_teamkill_happened">handle_teamkill_happened</a></code></li>
<li><code><a title="server.gameconnection.GameConnection.handle_teamkill_report" href="#server.gameconnection.GameConnection.handle_teamkill_report">handle_teamkill_report</a></code></li>
<li><code><a title="server.gameconnection.GameConnection.is_host" href="#server.gameconnection.GameConnection.is_host">is_host</a></code></li>
<li><code><a title="server.gameconnection.GameConnection.on_connection_lost" href="#server.gameconnection.GameConnection.on_connection_lost">on_connection_lost</a></code></li>
<li><code><a title="server.gameconnection.GameConnection.player" href="#server.gameconnection.GameConnection.player">player</a></code></li>
<li><code><a title="server.gameconnection.GameConnection.send" href="#server.gameconnection.GameConnection.send">send</a></code></li>
<li><code><a title="server.gameconnection.GameConnection.state" href="#server.gameconnection.GameConnection.state">state</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>