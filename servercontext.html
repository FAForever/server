<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>server.servercontext API documentation</title>
<meta name="description" content="Manages a group of connections using the same protocol over the same port" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>server.servercontext</code></h1>
</header>
<section id="section-intro">
<p>Manages a group of connections using the same protocol over the same port</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Manages a group of connections using the same protocol over the same port
&#34;&#34;&#34;

import asyncio
import socket
from asyncio import StreamReader, StreamWriter
from contextlib import contextmanager
from typing import Callable, Iterable, Optional

import humanize
from proxyprotocol.detect import ProxyProtocolDetect
from proxyprotocol.reader import ProxyProtocolReader
from proxyprotocol.sock import SocketInfo

import server.metrics as metrics

from .core import Service
from .decorators import with_logger
from .lobbyconnection import LobbyConnection
from .protocol import DisconnectedError, Protocol, QDataStreamProtocol
from .types import Address

MiB = 2 ** 20
LIMIT = 10 * MiB


@with_logger
class ServerContext:
    &#34;&#34;&#34;
    Base class for managing connections and holding state about them.
    &#34;&#34;&#34;

    def __init__(
        self,
        name: str,
        connection_factory: Callable[[], LobbyConnection],
        services: Iterable[Service],
        protocol_class: type[Protocol] = QDataStreamProtocol,
    ):
        super().__init__()
        self.name = name
        self._server = None
        self._drain_event = None
        self._connection_factory = connection_factory
        self._services = services
        self.connections: dict[LobbyConnection, Protocol] = {}
        self.protocol_class = protocol_class

    def __repr__(self):
        return f&#34;ServerContext({self.name})&#34;

    async def listen(
        self,
        host: str,
        port: Optional[int],
        proxy: bool = False
    ):
        self._logger.debug(
            &#34;%s: listen(%r, %r, proxy=%r)&#34;,
            self.name,
            host,
            port,
            proxy
        )

        callback = self.client_connected_callback
        if proxy:
            pp_detect = ProxyProtocolDetect()
            pp_reader = ProxyProtocolReader(pp_detect)
            callback = pp_reader.get_callback(callback)

        self._server = await asyncio.start_server(
            callback,
            host=host,
            port=port,
            limit=LIMIT,
        )

        for sock in self.sockets:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            host, port, *_ = sock.getsockname()
            self._logger.info(&#34;%s: listening on %s:%s&#34;, self.name, host, port)

        return self._server

    @property
    def sockets(self):
        return self._server.sockets

    async def shutdown(self, timeout: Optional[float] = 5):
        async def close_or_abort(conn, proto):
            try:
                await asyncio.wait_for(proto.close(), timeout)
            except asyncio.TimeoutError:
                proto.abort()
                self._logger.warning(
                    &#34;%s: Protocol did not terminate cleanly for &#39;%s&#39;&#34;,
                    self.name,
                    conn.get_user_identifier()
                )
        self._logger.debug(
            &#34;%s: Waiting up to %s for connections to close&#34;,
            self.name,
            humanize.naturaldelta(timeout)
        )
        for fut in asyncio.as_completed([
            close_or_abort(conn, proto)
            for conn, proto in self.connections.items()
        ]):
            await fut
        self._logger.debug(&#34;%s: All connections closed&#34;, self.name)

    async def stop(self):
        self._logger.debug(&#34;%s: stop()&#34;, self.name)
        if self._server:
            self._server.close()
            await self._server.wait_closed()

    async def drain_connections(self):
        &#34;&#34;&#34;
        Wait for all connections to terminate.
        &#34;&#34;&#34;
        if not self.connections:
            return

        if not self._drain_event:
            self._drain_event = asyncio.Event()

        await self._drain_event.wait()

    def write_broadcast(self, message, validate_fn=lambda _: True):
        self.write_broadcast_raw(
            self.protocol_class.encode_message(message),
            validate_fn
        )

    def write_broadcast_raw(self, data, validate_fn=lambda _: True):
        for conn, proto in self.connections.items():
            try:
                if proto.is_connected() and validate_fn(conn):
                    proto.write_raw(data)
            except Exception:
                self._logger.exception(
                    &#34;%s: Encountered error in broadcast: %s&#34;,
                    self.name,
                    conn
                )

    async def client_connected_callback(
        self,
        reader: StreamReader,
        writer: StreamWriter,
        proxy_info: Optional[SocketInfo] = None,
    ):
        if proxy_info:
            peername_writer = Address(*writer.get_extra_info(&#34;peername&#34;))

            if not proxy_info.peername:
                # See security considerations:
                # https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt
                self._logger.warning(
                    &#34;%s: Client connected from %s:%s to a context in proxy &#34;
                    &#34;mode! The connection will be ignored, however this may &#34;
                    &#34;indicate a misconfiguration in your firewall.&#34;,
                    self.name,
                    peername_writer.host,
                    peername_writer.port
                )
                writer.close()
                return

            peername = Address(*proxy_info.peername)
            self._logger.info(
                &#34;%s: Client connected from %s:%s via proxy %s:%s&#34;,
                self.name,
                peername.host,
                peername.port,
                peername_writer.host,
                peername_writer.port
            )
        else:
            peername = Address(*writer.get_extra_info(&#34;peername&#34;))
            self._logger.info(
                &#34;%s: Client connected from %s:%s&#34;,
                self.name,
                peername.host,
                peername.port
            )

        await self.handle_client_connected(reader, writer, peername)

    async def handle_client_connected(
        self,
        reader: StreamReader,
        writer: StreamWriter,
        peername: Address,
    ):
        protocol = self.protocol_class(reader, writer)
        connection = self._connection_factory()
        self.connections[connection] = protocol

        try:
            await connection.on_connection_made(protocol, peername)
            metrics.user_connections.labels(&#34;None&#34;, &#34;None&#34;).inc()
            while protocol.is_connected():
                message = await protocol.read_message()
                with metrics.connection_on_message_received.time():
                    await connection.on_message_received(message)
        except (
            ConnectionError,
            DisconnectedError,
            TimeoutError,
            asyncio.CancelledError,
        ):
            pass
        except UnicodeDecodeError as e:
            self._logger.exception(
                &#34;%s: Unicode error in protocol for &#39;%s&#39;: %s &#39;...%s...&#39;&#34;,
                self.name,
                connection.get_user_identifier(),
                e,
                e.object[e.start-20:e.end+20]
            )
        except Exception as e:
            self._logger.exception(
                &#34;%s: Exception in protocol for &#39;%s&#39;: %s&#34;,
                self.name,
                connection.get_user_identifier(),
                e
            )
        finally:
            del self.connections[connection]
            # Do not wait for buffers to empty here. This could stop the process
            # from exiting if the client isn&#39;t reading data.
            protocol.abort()
            for service in self._services:
                with self.suppress_and_log(service.on_connection_lost, Exception):
                    service.on_connection_lost(connection)

            with self.suppress_and_log(connection.on_connection_lost, Exception):
                await connection.on_connection_lost()

            self._logger.info(
                &#34;%s: Client disconnected for &#39;%s&#39;&#34;,
                self.name,
                connection.get_user_identifier()
            )

            if (
                self._drain_event is not None
                and not self._drain_event.is_set()
                and not self.connections
            ):
                self._drain_event.set()

            metrics.user_connections.labels(
                connection.user_agent,
                connection.version
            ).dec()

    @contextmanager
    def suppress_and_log(self, func, *exceptions: type[BaseException]):
        try:
            yield
        except exceptions:
            if hasattr(func, &#34;__self__&#34;):
                desc = f&#34;{func.__self__.__class__.__name__}.{func.__name__}&#34;
            else:
                desc = func.__name__
            self._logger.warning(
                &#34;Unexpected exception in %s&#34;,
                desc,
                exc_info=True
            )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="server.servercontext.ServerContext"><code class="flex name class">
<span>class <span class="ident">ServerContext</span></span>
<span>(</span><span>name: str, connection_factory: Callable[[], <a title="server.lobbyconnection.LobbyConnection" href="lobbyconnection.html#server.lobbyconnection.LobbyConnection">LobbyConnection</a>], services: Iterable[<a title="server.core.service.Service" href="core/service.html#server.core.service.Service">Service</a>], protocol_class: type[<a title="server.protocol.protocol.Protocol" href="protocol/protocol.html#server.protocol.protocol.Protocol">Protocol</a>] = server.protocol.qdatastream.QDataStreamProtocol)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for managing connections and holding state about them.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@with_logger
class ServerContext:
    &#34;&#34;&#34;
    Base class for managing connections and holding state about them.
    &#34;&#34;&#34;

    def __init__(
        self,
        name: str,
        connection_factory: Callable[[], LobbyConnection],
        services: Iterable[Service],
        protocol_class: type[Protocol] = QDataStreamProtocol,
    ):
        super().__init__()
        self.name = name
        self._server = None
        self._drain_event = None
        self._connection_factory = connection_factory
        self._services = services
        self.connections: dict[LobbyConnection, Protocol] = {}
        self.protocol_class = protocol_class

    def __repr__(self):
        return f&#34;ServerContext({self.name})&#34;

    async def listen(
        self,
        host: str,
        port: Optional[int],
        proxy: bool = False
    ):
        self._logger.debug(
            &#34;%s: listen(%r, %r, proxy=%r)&#34;,
            self.name,
            host,
            port,
            proxy
        )

        callback = self.client_connected_callback
        if proxy:
            pp_detect = ProxyProtocolDetect()
            pp_reader = ProxyProtocolReader(pp_detect)
            callback = pp_reader.get_callback(callback)

        self._server = await asyncio.start_server(
            callback,
            host=host,
            port=port,
            limit=LIMIT,
        )

        for sock in self.sockets:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            host, port, *_ = sock.getsockname()
            self._logger.info(&#34;%s: listening on %s:%s&#34;, self.name, host, port)

        return self._server

    @property
    def sockets(self):
        return self._server.sockets

    async def shutdown(self, timeout: Optional[float] = 5):
        async def close_or_abort(conn, proto):
            try:
                await asyncio.wait_for(proto.close(), timeout)
            except asyncio.TimeoutError:
                proto.abort()
                self._logger.warning(
                    &#34;%s: Protocol did not terminate cleanly for &#39;%s&#39;&#34;,
                    self.name,
                    conn.get_user_identifier()
                )
        self._logger.debug(
            &#34;%s: Waiting up to %s for connections to close&#34;,
            self.name,
            humanize.naturaldelta(timeout)
        )
        for fut in asyncio.as_completed([
            close_or_abort(conn, proto)
            for conn, proto in self.connections.items()
        ]):
            await fut
        self._logger.debug(&#34;%s: All connections closed&#34;, self.name)

    async def stop(self):
        self._logger.debug(&#34;%s: stop()&#34;, self.name)
        if self._server:
            self._server.close()
            await self._server.wait_closed()

    async def drain_connections(self):
        &#34;&#34;&#34;
        Wait for all connections to terminate.
        &#34;&#34;&#34;
        if not self.connections:
            return

        if not self._drain_event:
            self._drain_event = asyncio.Event()

        await self._drain_event.wait()

    def write_broadcast(self, message, validate_fn=lambda _: True):
        self.write_broadcast_raw(
            self.protocol_class.encode_message(message),
            validate_fn
        )

    def write_broadcast_raw(self, data, validate_fn=lambda _: True):
        for conn, proto in self.connections.items():
            try:
                if proto.is_connected() and validate_fn(conn):
                    proto.write_raw(data)
            except Exception:
                self._logger.exception(
                    &#34;%s: Encountered error in broadcast: %s&#34;,
                    self.name,
                    conn
                )

    async def client_connected_callback(
        self,
        reader: StreamReader,
        writer: StreamWriter,
        proxy_info: Optional[SocketInfo] = None,
    ):
        if proxy_info:
            peername_writer = Address(*writer.get_extra_info(&#34;peername&#34;))

            if not proxy_info.peername:
                # See security considerations:
                # https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt
                self._logger.warning(
                    &#34;%s: Client connected from %s:%s to a context in proxy &#34;
                    &#34;mode! The connection will be ignored, however this may &#34;
                    &#34;indicate a misconfiguration in your firewall.&#34;,
                    self.name,
                    peername_writer.host,
                    peername_writer.port
                )
                writer.close()
                return

            peername = Address(*proxy_info.peername)
            self._logger.info(
                &#34;%s: Client connected from %s:%s via proxy %s:%s&#34;,
                self.name,
                peername.host,
                peername.port,
                peername_writer.host,
                peername_writer.port
            )
        else:
            peername = Address(*writer.get_extra_info(&#34;peername&#34;))
            self._logger.info(
                &#34;%s: Client connected from %s:%s&#34;,
                self.name,
                peername.host,
                peername.port
            )

        await self.handle_client_connected(reader, writer, peername)

    async def handle_client_connected(
        self,
        reader: StreamReader,
        writer: StreamWriter,
        peername: Address,
    ):
        protocol = self.protocol_class(reader, writer)
        connection = self._connection_factory()
        self.connections[connection] = protocol

        try:
            await connection.on_connection_made(protocol, peername)
            metrics.user_connections.labels(&#34;None&#34;, &#34;None&#34;).inc()
            while protocol.is_connected():
                message = await protocol.read_message()
                with metrics.connection_on_message_received.time():
                    await connection.on_message_received(message)
        except (
            ConnectionError,
            DisconnectedError,
            TimeoutError,
            asyncio.CancelledError,
        ):
            pass
        except UnicodeDecodeError as e:
            self._logger.exception(
                &#34;%s: Unicode error in protocol for &#39;%s&#39;: %s &#39;...%s...&#39;&#34;,
                self.name,
                connection.get_user_identifier(),
                e,
                e.object[e.start-20:e.end+20]
            )
        except Exception as e:
            self._logger.exception(
                &#34;%s: Exception in protocol for &#39;%s&#39;: %s&#34;,
                self.name,
                connection.get_user_identifier(),
                e
            )
        finally:
            del self.connections[connection]
            # Do not wait for buffers to empty here. This could stop the process
            # from exiting if the client isn&#39;t reading data.
            protocol.abort()
            for service in self._services:
                with self.suppress_and_log(service.on_connection_lost, Exception):
                    service.on_connection_lost(connection)

            with self.suppress_and_log(connection.on_connection_lost, Exception):
                await connection.on_connection_lost()

            self._logger.info(
                &#34;%s: Client disconnected for &#39;%s&#39;&#34;,
                self.name,
                connection.get_user_identifier()
            )

            if (
                self._drain_event is not None
                and not self._drain_event.is_set()
                and not self.connections
            ):
                self._drain_event.set()

            metrics.user_connections.labels(
                connection.user_agent,
                connection.version
            ).dec()

    @contextmanager
    def suppress_and_log(self, func, *exceptions: type[BaseException]):
        try:
            yield
        except exceptions:
            if hasattr(func, &#34;__self__&#34;):
                desc = f&#34;{func.__self__.__class__.__name__}.{func.__name__}&#34;
            else:
                desc = func.__name__
            self._logger.warning(
                &#34;Unexpected exception in %s&#34;,
                desc,
                exc_info=True
            )</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="server.servercontext.ServerContext.sockets"><code class="name">var <span class="ident">sockets</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sockets(self):
    return self._server.sockets</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="server.servercontext.ServerContext.client_connected_callback"><code class="name flex">
<span>async def <span class="ident">client_connected_callback</span></span>(<span>self, reader: asyncio.streams.StreamReader, writer: asyncio.streams.StreamWriter, proxy_info: Optional[proxyprotocol.sock.SocketInfo] = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def client_connected_callback(
    self,
    reader: StreamReader,
    writer: StreamWriter,
    proxy_info: Optional[SocketInfo] = None,
):
    if proxy_info:
        peername_writer = Address(*writer.get_extra_info(&#34;peername&#34;))

        if not proxy_info.peername:
            # See security considerations:
            # https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt
            self._logger.warning(
                &#34;%s: Client connected from %s:%s to a context in proxy &#34;
                &#34;mode! The connection will be ignored, however this may &#34;
                &#34;indicate a misconfiguration in your firewall.&#34;,
                self.name,
                peername_writer.host,
                peername_writer.port
            )
            writer.close()
            return

        peername = Address(*proxy_info.peername)
        self._logger.info(
            &#34;%s: Client connected from %s:%s via proxy %s:%s&#34;,
            self.name,
            peername.host,
            peername.port,
            peername_writer.host,
            peername_writer.port
        )
    else:
        peername = Address(*writer.get_extra_info(&#34;peername&#34;))
        self._logger.info(
            &#34;%s: Client connected from %s:%s&#34;,
            self.name,
            peername.host,
            peername.port
        )

    await self.handle_client_connected(reader, writer, peername)</code></pre>
</details>
</dd>
<dt id="server.servercontext.ServerContext.drain_connections"><code class="name flex">
<span>async def <span class="ident">drain_connections</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Wait for all connections to terminate.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def drain_connections(self):
    &#34;&#34;&#34;
    Wait for all connections to terminate.
    &#34;&#34;&#34;
    if not self.connections:
        return

    if not self._drain_event:
        self._drain_event = asyncio.Event()

    await self._drain_event.wait()</code></pre>
</details>
</dd>
<dt id="server.servercontext.ServerContext.handle_client_connected"><code class="name flex">
<span>async def <span class="ident">handle_client_connected</span></span>(<span>self, reader: asyncio.streams.StreamReader, writer: asyncio.streams.StreamWriter, peername: <a title="server.types.Address" href="types.html#server.types.Address">Address</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_client_connected(
    self,
    reader: StreamReader,
    writer: StreamWriter,
    peername: Address,
):
    protocol = self.protocol_class(reader, writer)
    connection = self._connection_factory()
    self.connections[connection] = protocol

    try:
        await connection.on_connection_made(protocol, peername)
        metrics.user_connections.labels(&#34;None&#34;, &#34;None&#34;).inc()
        while protocol.is_connected():
            message = await protocol.read_message()
            with metrics.connection_on_message_received.time():
                await connection.on_message_received(message)
    except (
        ConnectionError,
        DisconnectedError,
        TimeoutError,
        asyncio.CancelledError,
    ):
        pass
    except UnicodeDecodeError as e:
        self._logger.exception(
            &#34;%s: Unicode error in protocol for &#39;%s&#39;: %s &#39;...%s...&#39;&#34;,
            self.name,
            connection.get_user_identifier(),
            e,
            e.object[e.start-20:e.end+20]
        )
    except Exception as e:
        self._logger.exception(
            &#34;%s: Exception in protocol for &#39;%s&#39;: %s&#34;,
            self.name,
            connection.get_user_identifier(),
            e
        )
    finally:
        del self.connections[connection]
        # Do not wait for buffers to empty here. This could stop the process
        # from exiting if the client isn&#39;t reading data.
        protocol.abort()
        for service in self._services:
            with self.suppress_and_log(service.on_connection_lost, Exception):
                service.on_connection_lost(connection)

        with self.suppress_and_log(connection.on_connection_lost, Exception):
            await connection.on_connection_lost()

        self._logger.info(
            &#34;%s: Client disconnected for &#39;%s&#39;&#34;,
            self.name,
            connection.get_user_identifier()
        )

        if (
            self._drain_event is not None
            and not self._drain_event.is_set()
            and not self.connections
        ):
            self._drain_event.set()

        metrics.user_connections.labels(
            connection.user_agent,
            connection.version
        ).dec()</code></pre>
</details>
</dd>
<dt id="server.servercontext.ServerContext.listen"><code class="name flex">
<span>async def <span class="ident">listen</span></span>(<span>self, host: str, port: Optional[int], proxy: bool = False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def listen(
    self,
    host: str,
    port: Optional[int],
    proxy: bool = False
):
    self._logger.debug(
        &#34;%s: listen(%r, %r, proxy=%r)&#34;,
        self.name,
        host,
        port,
        proxy
    )

    callback = self.client_connected_callback
    if proxy:
        pp_detect = ProxyProtocolDetect()
        pp_reader = ProxyProtocolReader(pp_detect)
        callback = pp_reader.get_callback(callback)

    self._server = await asyncio.start_server(
        callback,
        host=host,
        port=port,
        limit=LIMIT,
    )

    for sock in self.sockets:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
        host, port, *_ = sock.getsockname()
        self._logger.info(&#34;%s: listening on %s:%s&#34;, self.name, host, port)

    return self._server</code></pre>
</details>
</dd>
<dt id="server.servercontext.ServerContext.shutdown"><code class="name flex">
<span>async def <span class="ident">shutdown</span></span>(<span>self, timeout: Optional[float] = 5)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def shutdown(self, timeout: Optional[float] = 5):
    async def close_or_abort(conn, proto):
        try:
            await asyncio.wait_for(proto.close(), timeout)
        except asyncio.TimeoutError:
            proto.abort()
            self._logger.warning(
                &#34;%s: Protocol did not terminate cleanly for &#39;%s&#39;&#34;,
                self.name,
                conn.get_user_identifier()
            )
    self._logger.debug(
        &#34;%s: Waiting up to %s for connections to close&#34;,
        self.name,
        humanize.naturaldelta(timeout)
    )
    for fut in asyncio.as_completed([
        close_or_abort(conn, proto)
        for conn, proto in self.connections.items()
    ]):
        await fut
    self._logger.debug(&#34;%s: All connections closed&#34;, self.name)</code></pre>
</details>
</dd>
<dt id="server.servercontext.ServerContext.stop"><code class="name flex">
<span>async def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def stop(self):
    self._logger.debug(&#34;%s: stop()&#34;, self.name)
    if self._server:
        self._server.close()
        await self._server.wait_closed()</code></pre>
</details>
</dd>
<dt id="server.servercontext.ServerContext.suppress_and_log"><code class="name flex">
<span>def <span class="ident">suppress_and_log</span></span>(<span>self, func, *exceptions: type[BaseException])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextmanager
def suppress_and_log(self, func, *exceptions: type[BaseException]):
    try:
        yield
    except exceptions:
        if hasattr(func, &#34;__self__&#34;):
            desc = f&#34;{func.__self__.__class__.__name__}.{func.__name__}&#34;
        else:
            desc = func.__name__
        self._logger.warning(
            &#34;Unexpected exception in %s&#34;,
            desc,
            exc_info=True
        )</code></pre>
</details>
</dd>
<dt id="server.servercontext.ServerContext.write_broadcast"><code class="name flex">
<span>def <span class="ident">write_broadcast</span></span>(<span>self, message, validate_fn=&lt;function ServerContext.&lt;lambda&gt;&gt;)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_broadcast(self, message, validate_fn=lambda _: True):
    self.write_broadcast_raw(
        self.protocol_class.encode_message(message),
        validate_fn
    )</code></pre>
</details>
</dd>
<dt id="server.servercontext.ServerContext.write_broadcast_raw"><code class="name flex">
<span>def <span class="ident">write_broadcast_raw</span></span>(<span>self, data, validate_fn=&lt;function ServerContext.&lt;lambda&gt;&gt;)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_broadcast_raw(self, data, validate_fn=lambda _: True):
    for conn, proto in self.connections.items():
        try:
            if proto.is_connected() and validate_fn(conn):
                proto.write_raw(data)
        except Exception:
            self._logger.exception(
                &#34;%s: Encountered error in broadcast: %s&#34;,
                self.name,
                conn
            )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="server" href="index.html">server</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="server.servercontext.ServerContext" href="#server.servercontext.ServerContext">ServerContext</a></code></h4>
<ul class="">
<li><code><a title="server.servercontext.ServerContext.client_connected_callback" href="#server.servercontext.ServerContext.client_connected_callback">client_connected_callback</a></code></li>
<li><code><a title="server.servercontext.ServerContext.drain_connections" href="#server.servercontext.ServerContext.drain_connections">drain_connections</a></code></li>
<li><code><a title="server.servercontext.ServerContext.handle_client_connected" href="#server.servercontext.ServerContext.handle_client_connected">handle_client_connected</a></code></li>
<li><code><a title="server.servercontext.ServerContext.listen" href="#server.servercontext.ServerContext.listen">listen</a></code></li>
<li><code><a title="server.servercontext.ServerContext.shutdown" href="#server.servercontext.ServerContext.shutdown">shutdown</a></code></li>
<li><code><a title="server.servercontext.ServerContext.sockets" href="#server.servercontext.ServerContext.sockets">sockets</a></code></li>
<li><code><a title="server.servercontext.ServerContext.stop" href="#server.servercontext.ServerContext.stop">stop</a></code></li>
<li><code><a title="server.servercontext.ServerContext.suppress_and_log" href="#server.servercontext.ServerContext.suppress_and_log">suppress_and_log</a></code></li>
<li><code><a title="server.servercontext.ServerContext.write_broadcast" href="#server.servercontext.ServerContext.write_broadcast">write_broadcast</a></code></li>
<li><code><a title="server.servercontext.ServerContext.write_broadcast_raw" href="#server.servercontext.ServerContext.write_broadcast_raw">write_broadcast_raw</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>