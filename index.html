<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>server API documentation</title>
<meta name="description" content="Forged Alliance Forever lobby server …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>server</code></h1>
</header>
<section id="section-intro">
<p>Forged Alliance Forever lobby server.</p>
<h1 id="overview">Overview</h1>
<p>The lobby server handles live state information for the FAF ecosystem. This
includes maintaining a list of online players, a list of hosted and ongoing
games, and a number of matchmakers. It also performs certain post-game actions
like computing and persisting rating changes and updating achievements. Every
online player maintains an active TCP connection to the server through which
the server syncronizes the current state.</p>
<h2 id="social">Social</h2>
<p>The social components of the lobby server are relatively limited, as the
primary social element, chat, is handled by a separate server. The social
features handled by the lobby server are therefore limited to:</p>
<ul>
<li>Syncronizing online player state</li>
<li>Enforcing global bans</li>
<li>Modifying a list of friends and a list of foes</li>
<li>Modifying the currently selected avatar</li>
</ul>
<h2 id="games">Games</h2>
<p>The server supports two ways of discovering games with other players: custom
lobbies and matchmakers. Ultimately however, the lobby server is only able to
help players discover eachother, and maintain certain meta information about
games. Game simulation happens entirely on the client side, and is completely
un-controlled by the server. Certain messages sent between clients throughout
the course of a game will also be relayed to the server. These can be used to
determine if clients were able to connect to eachother, and what the outcome of
the game was.</p>
<h3 id="custom-games">Custom Games</h3>
<p>Historically, the standard way to play FAF has been for one player to host a
game lobby, setup the desired map and game settings, and for other players to
voluntarily join that lobby until the host is satisfied with the players and
launches the game. The lobby server facilitates sending certain information
about these custom lobbies to all online players (subject to friend/foe rules)
as well as managing a game id that can be used to join a specific lobby. This
information includes, but is not necessarily limited to:</p>
<ul>
<li>Auto generated game uid</li>
<li>Host specified game name</li>
<li>Host selected map</li>
<li>List of connected players (non-AI only) and their team setup</li>
</ul>
<h3 id="matchmaker-games">Matchmaker games</h3>
<p>Players may also choose to join a matchmaker queue, instead of hosting a game
and finding people to play with manually. The matchmaker will attempt to create
balanced games using players TrueSkill rating, and choose a game host for
hosting an automatch lobby. From the server perspective, automatch games behave
virtually identical to custom games, the exception being that players may not
request to join them by game id. The exchange of game messages and connectivity
establishment happens identically to custom games.</p>
<h3 id="connectivity-establishment">Connectivity Establishment</h3>
<p>When a player requests to join a game, the lobby server initiates connection
establishment between the joining player and the host, and then the joining
player and all other players in the match. Connections are then established
using the Interactive Connectivity Establishment (ICE) protocol, using the
lobby server as a medium of exchanging candidate addresses between clients. If
clients require a relay in order to connect to eachother, they will
authenticate with a separate coturn server using credentials supplied by the
lobby server.</p>
<h2 id="achievements">Achievements</h2>
<p>When a game ends, each client will report a summary of the game in the form of
a stat report. These stats are then parsed to extract information about events
that occurred during the game, like units built, units killed, etc. and used to
unlock or progress achievements for the players.</p>
<h1 id="technical-overview">Technical Overview</h1>
<p>This section is intended for developers and will outline technical details of
how to interact with the server. It will remain relatively high level and
implementation agnostic, instead linking to other sections of the documentation
that go into more detail.</p>
<h2 id="protocol">Protocol</h2>
<p>TODO</p>
<h1 id="legal">Legal</h1>
<ul>
<li>Copyright © 2012-2014 Gael Honorez</li>
<li>Copyright © 2015-2016 Michael Søndergaard <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#104;&#101;&#101;&#111;&#64;&#102;&#97;&#102;&#111;&#114;&#101;&#118;&#101;&#114;&#46;&#99;&#111;&#109;">&#115;&#104;&#101;&#101;&#111;&#64;&#102;&#97;&#102;&#111;&#114;&#101;&#118;&#101;&#114;&#46;&#99;&#111;&#109;</a></li>
<li>Copyright © 2021 Forged Alliance Forever</li>
</ul>
<p>Distributed under GPLv3, see license.txt</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Forged Alliance Forever lobby server.

# Overview
The lobby server handles live state information for the FAF ecosystem. This
includes maintaining a list of online players, a list of hosted and ongoing
games, and a number of matchmakers. It also performs certain post-game actions
like computing and persisting rating changes and updating achievements. Every
online player maintains an active TCP connection to the server through which
the server syncronizes the current state.

## Social
The social components of the lobby server are relatively limited, as the
primary social element, chat, is handled by a separate server. The social
features handled by the lobby server are therefore limited to:

- Syncronizing online player state
- Enforcing global bans
- Modifying a list of friends and a list of foes
- Modifying the currently selected avatar

## Games
The server supports two ways of discovering games with other players: custom
lobbies and matchmakers. Ultimately however, the lobby server is only able to
help players discover eachother, and maintain certain meta information about
games. Game simulation happens entirely on the client side, and is completely
un-controlled by the server. Certain messages sent between clients throughout
the course of a game will also be relayed to the server. These can be used to
determine if clients were able to connect to eachother, and what the outcome of
the game was.

### Custom Games
Historically, the standard way to play FAF has been for one player to host a
game lobby, setup the desired map and game settings, and for other players to
voluntarily join that lobby until the host is satisfied with the players and
launches the game. The lobby server facilitates sending certain information
about these custom lobbies to all online players (subject to friend/foe rules)
as well as managing a game id that can be used to join a specific lobby. This
information includes, but is not necessarily limited to:

- Auto generated game uid
- Host specified game name
- Host selected map
- List of connected players (non-AI only) and their team setup

### Matchmaker games
Players may also choose to join a matchmaker queue, instead of hosting a game
and finding people to play with manually. The matchmaker will attempt to create
balanced games using players TrueSkill rating, and choose a game host for
hosting an automatch lobby. From the server perspective, automatch games behave
virtually identical to custom games, the exception being that players may not
request to join them by game id. The exchange of game messages and connectivity
establishment happens identically to custom games.

### Connectivity Establishment
When a player requests to join a game, the lobby server initiates connection
establishment between the joining player and the host, and then the joining
player and all other players in the match. Connections are then established
using the Interactive Connectivity Establishment (ICE) protocol, using the
lobby server as a medium of exchanging candidate addresses between clients. If
clients require a relay in order to connect to eachother, they will
authenticate with a separate coturn server using credentials supplied by the
lobby server.

## Achievements
When a game ends, each client will report a summary of the game in the form of
a stat report. These stats are then parsed to extract information about events
that occurred during the game, like units built, units killed, etc. and used to
unlock or progress achievements for the players.

# Technical Overview
This section is intended for developers and will outline technical details of
how to interact with the server. It will remain relatively high level and
implementation agnostic, instead linking to other sections of the documentation
that go into more detail.

## Protocol
TODO

# Legal
- Copyright © 2012-2014 Gael Honorez
- Copyright © 2015-2016 Michael Søndergaard &lt;sheeo@faforever.com&gt;
- Copyright © 2021 Forged Alliance Forever

Distributed under GPLv3, see license.txt
&#34;&#34;&#34;

import asyncio
import logging
import time
from typing import Optional

from prometheus_client import start_http_server

import server.metrics as metrics

from .api.api_accessor import ApiAccessor
from .asyncio_extensions import synchronizedmethod
from .broadcast_service import BroadcastService
from .config import TRACE, config
from .configuration_service import ConfigurationService
from .control import run_control_server
from .core import Service, create_services
from .db import FAFDatabase
from .game_service import GameService
from .gameconnection import GameConnection
from .geoip_service import GeoIpService
from .ice_servers.nts import TwilioNTS
from .ladder_service import LadderService
from .ladder_service.violation_service import ViolationService
from .lobbyconnection import LobbyConnection
from .message_queue_service import MessageQueueService
from .oauth_service import OAuthService
from .party_service import PartyService
from .player_service import PlayerService
from .protocol import Protocol, QDataStreamProtocol
from .rating_service.rating_service import RatingService
from .servercontext import ServerContext
from .stats.game_stats_service import GameStatsService

__author__ = &#34;Askaholic, Chris Kitching, Dragonfire, Gael Honorez, Jeroen De Dauw, Crotalus, Michael Søndergaard, Michel Jung&#34;
__contact__ = &#34;admin@faforever.com&#34;
__license__ = &#34;GPLv3&#34;
__copyright__ = &#34;Copyright (c) 2011-2015 &#34; + __author__

__all__ = (
    &#34;BroadcastService&#34;,
    &#34;ConfigurationService&#34;,
    &#34;GameConnection&#34;,
    &#34;GameService&#34;,
    &#34;GameStatsService&#34;,
    &#34;GeoIpService&#34;,
    &#34;LadderService&#34;,
    &#34;MessageQueueService&#34;,
    &#34;OAuthService&#34;,
    &#34;PartyService&#34;,
    &#34;PlayerService&#34;,
    &#34;RatingService&#34;,
    &#34;RatingService&#34;,
    &#34;ServerInstance&#34;,
    &#34;ViolationService&#34;,
    &#34;control&#34;,
    &#34;game_service&#34;,
    &#34;protocol&#34;,
    &#34;run_control_server&#34;,
)

logger = logging.getLogger(&#34;server&#34;)

if config.ENABLE_METRICS:
    logger.info(&#34;Using prometheus on port: %i&#34;, config.METRICS_PORT)
    start_http_server(config.METRICS_PORT)


class ServerInstance(object):
    &#34;&#34;&#34;
    A class representing a shared server state. Each `ServerInstance` may be
    exposed on multiple ports, but each port will share the same internal server
    state, i.e. the same players, games, etc.
    &#34;&#34;&#34;

    def __init__(
        self,
        name: str,
        database: FAFDatabase,
        api_accessor: Optional[ApiAccessor],
        twilio_nts: Optional[TwilioNTS],
        loop: asyncio.BaseEventLoop,
        # For testing
        _override_services: Optional[dict[str, Service]] = None
    ):
        self.name = name
        self._logger = logging.getLogger(self.name)
        self.database = database
        self.api_accessor = api_accessor
        self.twilio_nts = twilio_nts
        self.loop = loop

        self.started = False

        self.contexts: set[ServerContext] = set()

        self.services = _override_services or create_services({
            &#34;server&#34;: self,
            &#34;database&#34;: self.database,
            &#34;api_accessor&#34;: self.api_accessor,
            &#34;loop&#34;: self.loop,
        })

        self.connection_factory = lambda: LobbyConnection(
            database=database,
            geoip=self.services[&#34;geo_ip_service&#34;],
            game_service=self.services[&#34;game_service&#34;],
            nts_client=twilio_nts,
            players=self.services[&#34;player_service&#34;],
            ladder_service=self.services[&#34;ladder_service&#34;],
            party_service=self.services[&#34;party_service&#34;],
            rating_service=self.services[&#34;rating_service&#34;],
            oauth_service=self.services[&#34;oauth_service&#34;],
        )

    def write_broadcast(
        self,
        message,
        predicate=lambda conn: conn.authenticated
    ):
        &#34;&#34;&#34;
        Queue a message to be sent to all connected clients.
        &#34;&#34;&#34;
        self._logger.log(TRACE, &#34;]]: %s&#34;, message)
        metrics.server_broadcasts.inc()

        for ctx in self.contexts:
            try:
                ctx.write_broadcast(message, predicate)
            except Exception:
                self._logger.exception(
                    &#34;Error writing &#39;%s&#39;&#34;,
                    message.get(&#34;command&#34;, message)
                )

    @synchronizedmethod
    async def start_services(self) -&gt; None:
        if self.started:
            return

        num_services = len(self.services)
        self._logger.debug(&#34;Initializing %s services&#34;, num_services)

        async def initialize(service):
            start = time.perf_counter()
            await service.initialize()
            service._logger.debug(
                &#34;%s initialized in %0.2f seconds&#34;,
                service.__class__.__name__,
                time.perf_counter() - start
            )

        await asyncio.gather(*[
            initialize(service) for service in self.services.values()
        ])

        self._logger.debug(&#34;Initialized %s services&#34;, num_services)

        self.started = True

    async def listen(
        self,
        address: tuple[str, int],
        protocol_class: type[Protocol] = QDataStreamProtocol
    ) -&gt; ServerContext:
        &#34;&#34;&#34;
        Start listening on a new address.
        &#34;&#34;&#34;
        if not self.started:
            await self.start_services()

        ctx = ServerContext(
            f&#34;{self.name}[{protocol_class.__name__}]&#34;,
            self.connection_factory,
            list(self.services.values()),
            protocol_class
        )
        self.contexts.add(ctx)

        await ctx.listen(*address)

        return ctx

    async def shutdown(self):
        results = await asyncio.gather(
            *(ctx.stop() for ctx in self.contexts),
            return_exceptions=True
        )
        for result, ctx in zip(results, self.contexts):
            if isinstance(result, BaseException):
                self._logger.error(
                    &#34;Unexpected error when stopping context %s&#34;,
                    ctx
                )

        results = await asyncio.gather(
            *(service.shutdown() for service in self.services.values()),
            return_exceptions=True
        )
        for result, service in zip(results, self.services.values()):
            if isinstance(result, BaseException):
                self._logger.error(
                    &#34;Unexpected error when shutting down service %s&#34;,
                    service
                )

        results = await asyncio.gather(
            *(ctx.shutdown() for ctx in self.contexts),
            return_exceptions=True
        )
        for result, ctx in zip(results, self.contexts):
            if isinstance(result, BaseException):
                self._logger.error(
                    &#34;Unexpected error when shutting down context %s&#34;,
                    ctx
                )

        self.contexts.clear()
        self.started = False</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="server.api" href="api/index.html">server.api</a></code></dt>
<dd>
<div class="desc"><p>API connector</p></div>
</dd>
<dt><code class="name"><a title="server.asyncio_extensions" href="asyncio_extensions.html">server.asyncio_extensions</a></code></dt>
<dd>
<div class="desc"><p>Some helper functions for common async tasks</p></div>
</dd>
<dt><code class="name"><a title="server.broadcast_service" href="broadcast_service.html">server.broadcast_service</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="server.config" href="config.html">server.config</a></code></dt>
<dd>
<div class="desc"><p>Server config variables</p></div>
</dd>
<dt><code class="name"><a title="server.configuration_service" href="configuration_service.html">server.configuration_service</a></code></dt>
<dd>
<div class="desc"><p>Manages periodic reloading of config variables</p></div>
</dd>
<dt><code class="name"><a title="server.control" href="control.html">server.control</a></code></dt>
<dd>
<div class="desc"><p>Tiny http server for introspecting state</p></div>
</dd>
<dt><code class="name"><a title="server.core" href="core/index.html">server.core</a></code></dt>
<dd>
<div class="desc"><p>Server framework …</p></div>
</dd>
<dt><code class="name"><a title="server.db" href="db/index.html">server.db</a></code></dt>
<dd>
<div class="desc"><p>Database interaction</p></div>
</dd>
<dt><code class="name"><a title="server.decorators" href="decorators.html">server.decorators</a></code></dt>
<dd>
<div class="desc"><p>Helper decorators</p></div>
</dd>
<dt><code class="name"><a title="server.exceptions" href="exceptions.html">server.exceptions</a></code></dt>
<dd>
<div class="desc"><p>Common exception definitions</p></div>
</dd>
<dt><code class="name"><a title="server.factions" href="factions.html">server.factions</a></code></dt>
<dd>
<div class="desc"><p>Supreme Commander known faction definitions</p></div>
</dd>
<dt><code class="name"><a title="server.game_service" href="game_service.html">server.game_service</a></code></dt>
<dd>
<div class="desc"><p>Manages the lifecycle of active games</p></div>
</dd>
<dt><code class="name"><a title="server.gameconnection" href="gameconnection.html">server.gameconnection</a></code></dt>
<dd>
<div class="desc"><p>Game communication over GpgNet</p></div>
</dd>
<dt><code class="name"><a title="server.games" href="games/index.html">server.games</a></code></dt>
<dd>
<div class="desc"><p>Type definitions for game objects</p></div>
</dd>
<dt><code class="name"><a title="server.geoip_service" href="geoip_service.html">server.geoip_service</a></code></dt>
<dd>
<div class="desc"><p>Manages the GeoIP database</p></div>
</dd>
<dt><code class="name"><a title="server.ice_servers" href="ice_servers/index.html">server.ice_servers</a></code></dt>
<dd>
<div class="desc"><p>ICE server configuration</p></div>
</dd>
<dt><code class="name"><a title="server.ladder_service" href="ladder_service/index.html">server.ladder_service</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="server.lobbyconnection" href="lobbyconnection.html">server.lobbyconnection</a></code></dt>
<dd>
<div class="desc"><p>Handles requests from connected clients</p></div>
</dd>
<dt><code class="name"><a title="server.matchmaker" href="matchmaker/index.html">server.matchmaker</a></code></dt>
<dd>
<div class="desc"><p>The matchmaker system …</p></div>
</dd>
<dt><code class="name"><a title="server.message_queue_service" href="message_queue_service.html">server.message_queue_service</a></code></dt>
<dd>
<div class="desc"><p>Interfaces with RabbitMQ</p></div>
</dd>
<dt><code class="name"><a title="server.metrics" href="metrics.html">server.metrics</a></code></dt>
<dd>
<div class="desc"><p>Prometheus metric definitions</p></div>
</dd>
<dt><code class="name"><a title="server.oauth_service" href="oauth_service.html">server.oauth_service</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="server.party_service" href="party_service.html">server.party_service</a></code></dt>
<dd>
<div class="desc"><p>Manages interactions between players and parties</p></div>
</dd>
<dt><code class="name"><a title="server.player_service" href="player_service.html">server.player_service</a></code></dt>
<dd>
<div class="desc"><p>Manages connected and authenticated players</p></div>
</dd>
<dt><code class="name"><a title="server.players" href="players.html">server.players</a></code></dt>
<dd>
<div class="desc"><p>Player type definitions</p></div>
</dd>
<dt><code class="name"><a title="server.profiler" href="profiler.html">server.profiler</a></code></dt>
<dd>
<div class="desc"><p>Analysis of application performance</p></div>
</dd>
<dt><code class="name"><a title="server.protocol" href="protocol/index.html">server.protocol</a></code></dt>
<dd>
<div class="desc"><p>Protocol format definitions</p></div>
</dd>
<dt><code class="name"><a title="server.rating" href="rating.html">server.rating</a></code></dt>
<dd>
<div class="desc"><p>Type definitions for player ratings</p></div>
</dd>
<dt><code class="name"><a title="server.rating_service" href="rating_service/index.html">server.rating_service</a></code></dt>
<dd>
<div class="desc"><p>Post-game rating functionality</p></div>
</dd>
<dt><code class="name"><a title="server.servercontext" href="servercontext.html">server.servercontext</a></code></dt>
<dd>
<div class="desc"><p>Manages a group of connections using the same protocol over the same port</p></div>
</dd>
<dt><code class="name"><a title="server.stats" href="stats/index.html">server.stats</a></code></dt>
<dd>
<div class="desc"><p>Achievements and events</p></div>
</dd>
<dt><code class="name"><a title="server.team_matchmaker" href="team_matchmaker/index.html">server.team_matchmaker</a></code></dt>
<dd>
<div class="desc"><p>The team matchmaking system …</p></div>
</dd>
<dt><code class="name"><a title="server.timing" href="timing/index.html">server.timing</a></code></dt>
<dd>
<div class="desc"><p>Helpers for executing async functions on a timer</p></div>
</dd>
<dt><code class="name"><a title="server.types" href="types.html">server.types</a></code></dt>
<dd>
<div class="desc"><p>General type definitions</p></div>
</dd>
<dt><code class="name"><a title="server.weakattr" href="weakattr.html">server.weakattr</a></code></dt>
<dd>
<div class="desc"><p>Helpers for non-owned object attributes</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="server.run_control_server"><code class="name flex">
<span>async def <span class="ident">run_control_server</span></span>(<span>player_service: <a title="server.player_service.PlayerService" href="player_service.html#server.player_service.PlayerService">PlayerService</a>, game_service: <a title="server.game_service.GameService" href="game_service.html#server.game_service.GameService">GameService</a>) ‑> <a title="server.control.ControlServer" href="control.html#server.control.ControlServer">ControlServer</a></span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the http control server</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def run_control_server(
    player_service: PlayerService,
    game_service: GameService
) -&gt; ControlServer:
    &#34;&#34;&#34;
    Initialize the http control server
    &#34;&#34;&#34;
    host = socket.gethostbyname(socket.gethostname())
    port = config.CONTROL_SERVER_PORT

    ctrl_server = ControlServer(game_service, player_service, host, port)
    await ctrl_server.start()

    return ctrl_server</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="server.BroadcastService"><code class="flex name class">
<span>class <span class="ident">BroadcastService</span></span>
<span>(</span><span>server: <a title="server.ServerInstance" href="#server.ServerInstance">ServerInstance</a>, message_queue_service: <a title="server.message_queue_service.MessageQueueService" href="message_queue_service.html#server.message_queue_service.MessageQueueService">MessageQueueService</a>, game_service: <a title="server.game_service.GameService" href="game_service.html#server.game_service.GameService">GameService</a>, player_service: <a title="server.player_service.PlayerService" href="player_service.html#server.player_service.PlayerService">PlayerService</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Broadcast updates about changed entities.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@with_logger
class BroadcastService(Service):
    &#34;&#34;&#34;
    Broadcast updates about changed entities.
    &#34;&#34;&#34;

    def __init__(
        self,
        server: &#34;ServerInstance&#34;,
        message_queue_service: MessageQueueService,
        game_service: GameService,
        player_service: PlayerService,
    ):
        self.server = server
        self.message_queue_service = message_queue_service
        self.game_service = game_service
        self.player_service = player_service

    async def initialize(self):
        # Using a lazy interval timer so that the intervals can be changed
        # without restarting the server.
        self._broadcast_dirties_timer = LazyIntervalTimer(
            lambda: config.DIRTY_REPORT_INTERVAL,
            self.report_dirties,
            start=True
        )
        self._broadcast_ping_timer = LazyIntervalTimer(
            lambda: config.PING_INTERVAL,
            self.broadcast_ping,
            start=True
        )

    async def report_dirties(self):
        &#34;&#34;&#34;
        Send updates about any dirty (changed) entities to connected players.
        This function is called at a fixed interval, which guarantees that any
        given object will not be written out to the clients more than once per
        interval.
        &#34;&#34;&#34;
        self.game_service.update_active_game_metrics()
        dirty_games = self.game_service.pop_dirty_games()
        dirty_queues = self.game_service.pop_dirty_queues()
        dirty_players = self.player_service.pop_dirty_players()

        if dirty_queues:
            matchmaker_info = {
                &#34;command&#34;: &#34;matchmaker_info&#34;,
                &#34;queues&#34;: [queue.to_dict() for queue in dirty_queues]
            }
            self.server.write_broadcast(matchmaker_info)

        if dirty_players:
            player_info = {
                &#34;command&#34;: &#34;player_info&#34;,
                &#34;players&#34;: [player.to_dict() for player in dirty_players]
            }
            self.server.write_broadcast(player_info)

        game_info = {
            &#34;command&#34;: &#34;game_info&#34;,
            &#34;games&#34;: []
        }
        # TODO: This spams squillions of messages: we should implement per-
        # connection message aggregation at the next abstraction layer down :P
        for game in dirty_games:
            if game.state == GameState.ENDED:
                self.game_service.remove_game(game)

            # So we&#39;re going to be broadcasting this to _somebody_...
            message = game.to_dict()
            game_info[&#34;games&#34;].append(message)

            self.server.write_broadcast(
                message,
                lambda conn: (
                    conn.authenticated
                    and game.is_visible_to_player(conn.player)
                )
            )

        if dirty_queues:
            await self.message_queue_service.publish(
                config.MQ_EXCHANGE_NAME,
                &#34;broadcast.matchmakerInfo.update&#34;,
                matchmaker_info,
                delivery_mode=DeliveryMode.NOT_PERSISTENT
            )

        if dirty_players:
            await self.message_queue_service.publish(
                config.MQ_EXCHANGE_NAME,
                &#34;broadcast.playerInfo.update&#34;,
                player_info,
                delivery_mode=DeliveryMode.NOT_PERSISTENT
            )

        if dirty_games:
            await self.message_queue_service.publish(
                config.MQ_EXCHANGE_NAME,
                &#34;broadcast.gameInfo.update&#34;,
                game_info,
                delivery_mode=DeliveryMode.NOT_PERSISTENT
            )

    def broadcast_ping(self):
        self.server.write_broadcast({&#34;command&#34;: &#34;ping&#34;})</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="server.core.service.Service" href="core/service.html#server.core.service.Service">Service</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="server.BroadcastService.broadcast_ping"><code class="name flex">
<span>def <span class="ident">broadcast_ping</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def broadcast_ping(self):
    self.server.write_broadcast({&#34;command&#34;: &#34;ping&#34;})</code></pre>
</details>
</dd>
<dt id="server.BroadcastService.report_dirties"><code class="name flex">
<span>async def <span class="ident">report_dirties</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Send updates about any dirty (changed) entities to connected players.
This function is called at a fixed interval, which guarantees that any
given object will not be written out to the clients more than once per
interval.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def report_dirties(self):
    &#34;&#34;&#34;
    Send updates about any dirty (changed) entities to connected players.
    This function is called at a fixed interval, which guarantees that any
    given object will not be written out to the clients more than once per
    interval.
    &#34;&#34;&#34;
    self.game_service.update_active_game_metrics()
    dirty_games = self.game_service.pop_dirty_games()
    dirty_queues = self.game_service.pop_dirty_queues()
    dirty_players = self.player_service.pop_dirty_players()

    if dirty_queues:
        matchmaker_info = {
            &#34;command&#34;: &#34;matchmaker_info&#34;,
            &#34;queues&#34;: [queue.to_dict() for queue in dirty_queues]
        }
        self.server.write_broadcast(matchmaker_info)

    if dirty_players:
        player_info = {
            &#34;command&#34;: &#34;player_info&#34;,
            &#34;players&#34;: [player.to_dict() for player in dirty_players]
        }
        self.server.write_broadcast(player_info)

    game_info = {
        &#34;command&#34;: &#34;game_info&#34;,
        &#34;games&#34;: []
    }
    # TODO: This spams squillions of messages: we should implement per-
    # connection message aggregation at the next abstraction layer down :P
    for game in dirty_games:
        if game.state == GameState.ENDED:
            self.game_service.remove_game(game)

        # So we&#39;re going to be broadcasting this to _somebody_...
        message = game.to_dict()
        game_info[&#34;games&#34;].append(message)

        self.server.write_broadcast(
            message,
            lambda conn: (
                conn.authenticated
                and game.is_visible_to_player(conn.player)
            )
        )

    if dirty_queues:
        await self.message_queue_service.publish(
            config.MQ_EXCHANGE_NAME,
            &#34;broadcast.matchmakerInfo.update&#34;,
            matchmaker_info,
            delivery_mode=DeliveryMode.NOT_PERSISTENT
        )

    if dirty_players:
        await self.message_queue_service.publish(
            config.MQ_EXCHANGE_NAME,
            &#34;broadcast.playerInfo.update&#34;,
            player_info,
            delivery_mode=DeliveryMode.NOT_PERSISTENT
        )

    if dirty_games:
        await self.message_queue_service.publish(
            config.MQ_EXCHANGE_NAME,
            &#34;broadcast.gameInfo.update&#34;,
            game_info,
            delivery_mode=DeliveryMode.NOT_PERSISTENT
        )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="server.core.service.Service" href="core/service.html#server.core.service.Service">Service</a></b></code>:
<ul class="hlist">
<li><code><a title="server.core.service.Service.initialize" href="core/service.html#server.core.service.Service.initialize">initialize</a></code></li>
<li><code><a title="server.core.service.Service.on_connection_lost" href="core/service.html#server.core.service.Service.on_connection_lost">on_connection_lost</a></code></li>
<li><code><a title="server.core.service.Service.shutdown" href="core/service.html#server.core.service.Service.shutdown">shutdown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="server.ConfigurationService"><code class="flex name class">
<span>class <span class="ident">ConfigurationService</span></span>
</code></dt>
<dd>
<div class="desc"><p>All services should inherit from this class.</p>
<p>Services are singleton objects which manage some server task.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@with_logger
class ConfigurationService(Service):
    def __init__(self) -&gt; None:
        self._store = config
        self._task = None

    async def initialize(self) -&gt; None:
        self._task = asyncio.create_task(self._worker_loop())
        self._logger.info(&#34;Configuration service initialized&#34;)

    async def _worker_loop(self) -&gt; None:
        while True:
            self._logger.debug(&#34;Refreshing configuration variables&#34;)
            self._store.refresh()
            await asyncio.sleep(self._store.CONFIGURATION_REFRESH_TIME)

    async def shutdown(self) -&gt; None:
        if self._task is not None:
            self._logger.info(&#34;Configuration service stopping.&#34;)
            self._task.cancel()
        self._task = None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="server.core.service.Service" href="core/service.html#server.core.service.Service">Service</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="server.core.service.Service" href="core/service.html#server.core.service.Service">Service</a></b></code>:
<ul class="hlist">
<li><code><a title="server.core.service.Service.initialize" href="core/service.html#server.core.service.Service.initialize">initialize</a></code></li>
<li><code><a title="server.core.service.Service.on_connection_lost" href="core/service.html#server.core.service.Service.on_connection_lost">on_connection_lost</a></code></li>
<li><code><a title="server.core.service.Service.shutdown" href="core/service.html#server.core.service.Service.shutdown">shutdown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="server.GameConnection"><code class="flex name class">
<span>class <span class="ident">GameConnection</span></span>
<span>(</span><span>database: <a title="server.db.FAFDatabase" href="db/index.html#server.db.FAFDatabase">FAFDatabase</a>, game: <a title="server.games.game.Game" href="games/game.html#server.games.game.Game">Game</a>, player: <a title="server.players.Player" href="players.html#server.players.Player">Player</a>, protocol: <a title="server.protocol.protocol.Protocol" href="protocol/protocol.html#server.protocol.protocol.Protocol">Protocol</a>, player_service: <a title="server.player_service.PlayerService" href="player_service.html#server.player_service.PlayerService">PlayerService</a>, games: <a title="server.game_service.GameService" href="game_service.html#server.game_service.GameService">GameService</a>, state: <a title="server.games.typedefs.GameConnectionState" href="games/typedefs.html#server.games.typedefs.GameConnectionState">GameConnectionState</a> = GameConnectionState.INITIALIZING)</span>
</code></dt>
<dd>
<div class="desc"><p>Responsible for connections to the game, using the GPGNet protocol</p>
<p>Construct a new GameConnection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@with_logger
class GameConnection(GpgNetServerProtocol):
    &#34;&#34;&#34;
    Responsible for connections to the game, using the GPGNet protocol
    &#34;&#34;&#34;

    def __init__(
        self,
        database: FAFDatabase,
        game: Game,
        player: Player,
        protocol: Protocol,
        player_service: PlayerService,
        games: GameService,
        state: GameConnectionState = GameConnectionState.INITIALIZING
    ):
        &#34;&#34;&#34;
        Construct a new GameConnection
        &#34;&#34;&#34;
        super().__init__()
        self._db = database
        self._logger.debug(&#34;GameConnection initializing&#34;)

        self.protocol = protocol
        self._state = state
        self.game_service = games
        self.player_service = player_service

        self._player = player
        player.game_connection = self  # Set up weak reference to self
        self._game = game

        self.finished_sim = False

    @property
    def state(self) -&gt; GameConnectionState:
        return self._state

    @property
    def game(self) -&gt; Game:
        return self._game

    @game.setter
    def game(self, val: Game):
        self._game = val

    @property
    def player(self) -&gt; Player:
        return self._player

    @player.setter
    def player(self, val: Player):
        self._player = val

    def is_host(self) -&gt; bool:
        if not self.game or not self.player:
            return False

        return (
            self.player.state == PlayerState.HOSTING and
            self.player == self.game.host
        )

    async def send(self, message):
        &#34;&#34;&#34;
        Send a game message to the client.

        # Errors
        May raise `DisconnectedError`

        NOTE: When calling this on a connection other than `self` make sure to
        handle `DisconnectedError`, otherwise failure to send the message will
        cause the caller to be disconnected as well.
        &#34;&#34;&#34;
        message[&#34;target&#34;] = &#34;game&#34;

        self._logger.log(TRACE, &#34;&gt;&gt; %s: %s&#34;, self.player.login, message)
        await self.protocol.send_message(message)

    async def _handle_idle_state(self):
        &#34;&#34;&#34;
        This message is sent by FA when it doesn&#39;t know what to do.
        &#34;&#34;&#34;
        assert self.game

        if self.player == self.game.host:
            self.game.state = GameState.LOBBY
            self._state = GameConnectionState.CONNECTED_TO_HOST
            self.game.add_game_connection(self)
            self.player.state = PlayerState.HOSTING
        else:
            self.player.state = PlayerState.JOINING

    async def _handle_lobby_state(self):
        &#34;&#34;&#34;
        The game has told us it is ready and listening on
        self.player.game_port for UDP.
        We determine the connectivity of the peer and respond
        appropriately
        &#34;&#34;&#34;
        player_state = self.player.state
        if player_state == PlayerState.HOSTING:
            await self.send_HostGame(self.game.map_folder_name)
            self.game.set_hosted()
        # If the player is joining, we connect him to host
        # followed by the rest of the players.
        elif player_state == PlayerState.JOINING:
            await self.connect_to_host(self.game.host.game_connection)

            if self._state is GameConnectionState.ENDED:
                # We aborted while trying to connect
                return

            self._state = GameConnectionState.CONNECTED_TO_HOST

            try:
                self.game.add_game_connection(self)
            except GameError as e:
                await self.abort(f&#34;GameError while joining {self.game.id}: {e}&#34;)
                return

            tasks = []
            for peer in self.game.connections:
                if peer != self and peer.player != self.game.host:
                    self._logger.debug(&#34;%s connecting to %s&#34;, self.player, peer)
                    tasks.append(self.connect_to_peer(peer))
            await asyncio.gather(*tasks)

    async def connect_to_host(self, peer: &#34;GameConnection&#34;):
        &#34;&#34;&#34;
        Connect self to a given peer (host)
        &#34;&#34;&#34;
        if not peer or peer.player.state != PlayerState.HOSTING:
            await self.abort(&#34;The host left the lobby&#34;)
            return

        await self.send_JoinGame(peer.player.login, peer.player.id)

        if not peer:
            await self.abort(&#34;The host left the lobby&#34;)
            return

        await peer.send_ConnectToPeer(
            player_name=self.player.login,
            player_uid=self.player.id,
            offer=True
        )

    async def connect_to_peer(self, peer: &#34;GameConnection&#34;):
        &#34;&#34;&#34;
        Connect two peers
        &#34;&#34;&#34;
        if peer is not None:
            await self.send_ConnectToPeer(
                player_name=peer.player.login,
                player_uid=peer.player.id,
                offer=True
            )

        if peer is not None:
            with contextlib.suppress(DisconnectedError):
                await peer.send_ConnectToPeer(
                    player_name=self.player.login,
                    player_uid=self.player.id,
                    offer=False
                )

    async def handle_action(self, command: str, args: list[Any]):
        &#34;&#34;&#34;
        Handle GpgNetSend messages, wrapped in the JSON protocol
        &#34;&#34;&#34;
        try:
            await COMMAND_HANDLERS[command](self, *args)
        except KeyError:
            self._logger.warning(
                &#34;Unrecognized command %s: %s from player %s&#34;,
                command, args, self.player
            )
        except (TypeError, ValueError):
            self._logger.exception(&#34;Bad command arguments&#34;)
        except ConnectionError as e:
            raise e
        except Exception:  # pragma: no cover
            self._logger.exception(&#34;Something awful happened in a game thread!&#34;)
            await self.abort()

    async def handle_desync(self, *_args):  # pragma: no cover
        self.game.desyncs += 1

    async def handle_game_option(self, key: str, value: Any):
        if not self.is_host():
            return

        if key == &#34;Victory&#34;:
            self.game.gameOptions[&#34;Victory&#34;] = Victory.__members__.get(
                value.upper(), None
            )
        else:
            self.game.gameOptions[key] = value

        if key == &#34;Slots&#34;:
            self.game.max_players = int(value)
        elif key == &#34;ScenarioFile&#34;:
            raw = repr(value)
            self.game.map_scenario_path = \
                raw.replace(&#34;\\&#34;, &#34;/&#34;).replace(&#34;//&#34;, &#34;/&#34;).replace(&#34;&#39;&#34;, &#34;&#34;)
            self.game.map_file_path = &#34;maps/{}.zip&#34;.format(
                self.game.map_scenario_path.split(&#34;/&#34;)[2].lower()
            )
        elif key == &#34;Title&#34;:
            with contextlib.suppress(ValueError):
                self.game.name = value

        self._mark_dirty()

    async def handle_game_mods(self, mode: Any, args: list[Any]):
        if not self.is_host():
            return

        if mode == &#34;activated&#34;:
            # In this case args is the number of mods
            if int(args) == 0:
                self.game.mods = {}

        elif mode == &#34;uids&#34;:
            uids = str(args).split()
            self.game.mods = {uid: &#34;Unknown sim mod&#34; for uid in uids}
            async with self._db.acquire() as conn:
                rows = await conn.execute(
                    &#34;SELECT `uid`, `name` from `table_mod` WHERE `uid` in :ids&#34;,
                    ids=tuple(uids)
                )
                for row in rows:
                    self.game.mods[row.uid] = row.name
        else:
            self._logger.warning(&#34;Ignoring game mod: %s, %s&#34;, mode, args)
            return

        self._mark_dirty()

    async def handle_player_option(
        self, player_id: Any, key: Any, value: Any
    ):
        if not self.is_host():
            return

        self.game.set_player_option(int(player_id), key, value)
        self._mark_dirty()

    async def handle_ai_option(self, name: Any, key: Any, value: Any):
        if not self.is_host():
            return

        self.game.set_ai_option(str(name), key, value)
        self._mark_dirty()

    async def handle_clear_slot(self, slot: Any):
        if not self.is_host():
            return

        self.game.clear_slot(int(slot))
        self._mark_dirty()

    async def handle_game_result(self, army: Any, result: Any):
        army = int(army)
        result = str(result).lower()

        try:
            *metadata, result_type, score = result.split()
        except ValueError:
            self._logger.warning(&#34;Invalid result for %s reported: %s&#34;, army, result)
        else:
            await self.game.add_result(
                self.player.id, army, result_type, int(score), frozenset(metadata)
            )

    async def handle_operation_complete(
        self, primary: Any, secondary: Any, delta: str
    ):
        &#34;&#34;&#34;
        # Params
        - `primary`: are primary mission objectives complete?
        - `secondary`: are secondary mission objectives complete?
        - `delta`: the time it took to complete the mission
        &#34;&#34;&#34;
        primary = FA.ENABLED == primary
        secondary = FA.ENABLED == secondary

        if not primary:
            return

        if not isinstance(self.game, CoopGame):
            self._logger.warning(
                &#34;OperationComplete called for non-coop game: %s&#34;, self.game.id
            )
            return

        if self.game.validity != ValidityState.COOP_NOT_RANKED:
            return

        secondary, delta = secondary, str(delta)
        async with self._db.acquire() as conn:
            result = await conn.execute(
                select([coop_map.c.id]).where(
                    coop_map.c.filename == self.game.map_file_path
                )
            )
            row = result.fetchone()
            if not row:
                self._logger.debug(
                    &#34;can&#39;t find coop map: %s&#34;, self.game.map_file_path
                )
                return
            mission = row.id

            # Each player in a co-op game will send the OperationComplete
            # message but we only need to perform this insert once
            if not self.game.leaderboard_saved:
                await conn.execute(
                    coop_leaderboard.insert().values(
                        mission=mission,
                        gameuid=self.game.id,
                        secondary=secondary,
                        time=delta,
                        player_count=len(self.game.players),
                    )
                )
                self.game.leaderboard_saved = True

    async def handle_json_stats(self, stats: str):
        try:
            self.game.report_army_stats(stats)
        except json.JSONDecodeError:
            self._logger.warning(
                &#34;Malformed game stats reported by %s: &#39;...%s&#39;&#34;,
                self._player.login,
                stats[-20:]
            )

    async def handle_enforce_rating(self):
        self.game.enforce_rating = True

    async def handle_teamkill_report(
        self,
        gametime: Any,
        reporter_id: Any,
        reporter_name: str,
        teamkiller_id: Any,
        teamkiller_name: str,
    ):
        &#34;&#34;&#34;
        Sent when a player is teamkilled and clicks the &#39;Report&#39; button.

        # Params
        - `gametime`: seconds of gametime when kill happened
        - `reporter_id`: reporter id
        - `reporter_name`: reporter nickname (for debug purpose only)
        - `teamkiller_id`: teamkiller id
        - `teamkiller_name`: teamkiller nickname (for debug purpose only)
        &#34;&#34;&#34;
        pass

    async def handle_teamkill_happened(
        self,
        gametime: Any,
        victim_id: Any,
        victim_name: str,
        teamkiller_id: Any,
        teamkiller_name: str,
    ):
        &#34;&#34;&#34;
        Send automatically by the game whenever a teamkill happens. Takes
        the same parameters as TeamkillReport.

        # Params
        - `gametime`: seconds of gametime when kill happened
        - `victim_id`: victim id
        - `victim_name`: victim nickname (for debug purpose only)
        - `teamkiller_id`: teamkiller id
        - `teamkiller_name`: teamkiller nickname (for debug purpose only)
        &#34;&#34;&#34;
        victim_id = int(victim_id)
        teamkiller_id = int(teamkiller_id)

        if 0 in (victim_id, teamkiller_id):
            self._logger.debug(&#34;Ignoring teamkill for AI player&#34;)
            return

        async with self._db.acquire() as conn:
            await conn.execute(
                teamkills.insert().values(
                    teamkiller=teamkiller_id,
                    victim=victim_id,
                    game_id=self.game.id,
                    gametime=gametime,
                )
            )

    async def handle_ice_message(self, receiver_id: Any, ice_msg: str):
        receiver_id = int(receiver_id)
        peer = self.player_service.get_player(receiver_id)
        if not peer:
            self._logger.debug(
                &#34;Ignoring ICE message for unknown player: %s&#34;, receiver_id
            )
            return

        game_connection = peer.game_connection
        if not game_connection:
            self._logger.debug(
                &#34;Ignoring ICE message for player without game connection: %s&#34;, receiver_id
            )
            return

        try:
            await game_connection.send({
                &#34;command&#34;: &#34;IceMsg&#34;,
                &#34;args&#34;: [int(self.player.id), ice_msg]
            })
        except DisconnectedError:
            self._logger.debug(
                &#34;Failed to send ICE message to player due to a disconnect: %s&#34;,
                receiver_id
            )

    async def handle_game_state(self, state: str):
        &#34;&#34;&#34;
        Changes in game state
        &#34;&#34;&#34;

        if state == &#34;Idle&#34;:
            await self._handle_idle_state()
            # Don&#39;t mark as dirty
            return

        elif state == &#34;Lobby&#34;:
            # TODO: Do we still need to schedule with `ensure_future`?
            #
            # We do not yield from the task, since we
            # need to keep processing other commands while it runs
            await self._handle_lobby_state()

        elif state == &#34;Launching&#34;:
            if self.player.state != PlayerState.HOSTING:
                return

            if self.game.state is not GameState.LOBBY:
                self._logger.warning(
                    &#34;Trying to launch game %s in invalid state %s&#34;,
                    self.game,
                    self.game.state
                )
                return

            self._logger.info(&#34;Launching game %s&#34;, self.game)

            await self.game.launch()

            if len(self.game.mods.keys()) &gt; 0:
                async with self._db.acquire() as conn:
                    uids = list(self.game.mods.keys())
                    await conn.execute(
                        &#34;UPDATE mod_stats s JOIN mod_version v ON &#34;
                        &#34;v.mod_id = s.mod_id &#34;
                        &#34;SET s.times_played = s.times_played + 1 &#34;
                        &#34;WHERE v.uid in :ids&#34;,
                        ids=tuple(uids)
                    )
        # Signals that the FA executable has been closed
        elif state == &#34;Ended&#34;:
            await self.on_connection_lost()
        self._mark_dirty()

    async def handle_game_ended(self, *args:  list[Any]):
        &#34;&#34;&#34;
        Signals that the simulation has ended.
        &#34;&#34;&#34;
        self.finished_sim = True
        await self.game.check_game_finish(self.player)

    async def handle_rehost(self, *args: list[Any]):
        &#34;&#34;&#34;
        Signals that the user has rehosted the game. This is currently unused but
        included for documentation purposes.
        &#34;&#34;&#34;
        pass

    async def handle_launch_status(self, status: str):
        &#34;&#34;&#34;
        Currently is sent with status `Rejected` if a matchmaker game failed
        to start due to players using differing game settings.
        &#34;&#34;&#34;
        pass

    async def handle_bottleneck(self, *args: list[Any]):
        &#34;&#34;&#34;
        Not sure what this command means. This is currently unused but
        included for documentation purposes.
        &#34;&#34;&#34;
        pass

    async def handle_bottleneck_cleared(self, *args: list[Any]):
        &#34;&#34;&#34;
        Not sure what this command means. This is currently unused but
        included for documentation purposes.
        &#34;&#34;&#34;
        pass

    async def handle_disconnected(self, *args: list[Any]):
        &#34;&#34;&#34;
        Not sure what this command means. This is currently unused but
        included for documentation purposes.
        &#34;&#34;&#34;
        pass

    async def handle_chat(self, message: str):
        &#34;&#34;&#34;
        Whenever the player sends a chat message during the game lobby.
        &#34;&#34;&#34;
        pass

    async def handle_game_full(self):
        &#34;&#34;&#34;
        Sent when all game slots are full
        &#34;&#34;&#34;
        pass

    def _mark_dirty(self):
        if self.game:
            self.game_service.mark_dirty(self.game)

    async def abort(self, log_message: str = &#34;&#34;):
        &#34;&#34;&#34;
        Abort the connection

        Removes the GameConnection object from the any associated Game object,
        and deletes references to Player and Game held by this object.
        &#34;&#34;&#34;
        try:
            if self._state is GameConnectionState.ENDED:
                return

            self._logger.debug(&#34;%s.abort(%s)&#34;, self, log_message)

            if self.game.state is GameState.LOBBY:
                await self.disconnect_all_peers()

            self._state = GameConnectionState.ENDED
            await self.game.remove_game_connection(self)
            self._mark_dirty()
            self.player.state = PlayerState.IDLE
            if self.player.lobby_connection:
                self.player.lobby_connection.game_connection = None
            del self.player.game
            del self.player.game_connection
        except Exception as ex:  # pragma: no cover
            self._logger.debug(&#34;Exception in abort(): %s&#34;, ex)

    async def disconnect_all_peers(self):
        tasks = []
        for peer in self.game.connections:
            if peer == self:
                continue

            tasks.append(peer.send_DisconnectFromPeer(self.player.id))

        for fut in asyncio.as_completed(tasks):
            try:
                await fut
            except Exception:
                self._logger.debug(
                    &#34;peer_sendDisconnectFromPeer failed for player %i&#34;,
                    self.player.id,
                    exc_info=True
                )

    async def on_connection_lost(self):
        try:
            await self.game.remove_game_connection(self)
        except Exception as e:  # pragma: no cover
            self._logger.exception(e)
        finally:
            await self.abort()

    def __str__(self):
        return f&#34;GameConnection({self.player}, {self.game})&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="server.protocol.gpgnet.GpgNetServerProtocol" href="protocol/gpgnet.html#server.protocol.gpgnet.GpgNetServerProtocol">GpgNetServerProtocol</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="server.GameConnection.game"><code class="name">var <span class="ident">game</span> : <a title="server.games.game.Game" href="games/game.html#server.games.game.Game">Game</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def game(self) -&gt; Game:
    return self._game</code></pre>
</details>
</dd>
<dt id="server.GameConnection.player"><code class="name">var <span class="ident">player</span> : <a title="server.players.Player" href="players.html#server.players.Player">Player</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def player(self) -&gt; Player:
    return self._player</code></pre>
</details>
</dd>
<dt id="server.GameConnection.state"><code class="name">var <span class="ident">state</span> : <a title="server.games.typedefs.GameConnectionState" href="games/typedefs.html#server.games.typedefs.GameConnectionState">GameConnectionState</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def state(self) -&gt; GameConnectionState:
    return self._state</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="server.GameConnection.abort"><code class="name flex">
<span>async def <span class="ident">abort</span></span>(<span>self, log_message: str = '')</span>
</code></dt>
<dd>
<div class="desc"><p>Abort the connection</p>
<p>Removes the GameConnection object from the any associated Game object,
and deletes references to Player and Game held by this object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def abort(self, log_message: str = &#34;&#34;):
    &#34;&#34;&#34;
    Abort the connection

    Removes the GameConnection object from the any associated Game object,
    and deletes references to Player and Game held by this object.
    &#34;&#34;&#34;
    try:
        if self._state is GameConnectionState.ENDED:
            return

        self._logger.debug(&#34;%s.abort(%s)&#34;, self, log_message)

        if self.game.state is GameState.LOBBY:
            await self.disconnect_all_peers()

        self._state = GameConnectionState.ENDED
        await self.game.remove_game_connection(self)
        self._mark_dirty()
        self.player.state = PlayerState.IDLE
        if self.player.lobby_connection:
            self.player.lobby_connection.game_connection = None
        del self.player.game
        del self.player.game_connection
    except Exception as ex:  # pragma: no cover
        self._logger.debug(&#34;Exception in abort(): %s&#34;, ex)</code></pre>
</details>
</dd>
<dt id="server.GameConnection.connect_to_host"><code class="name flex">
<span>async def <span class="ident">connect_to_host</span></span>(<span>self, peer: <a title="server.GameConnection" href="#server.GameConnection">GameConnection</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Connect self to a given peer (host)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def connect_to_host(self, peer: &#34;GameConnection&#34;):
    &#34;&#34;&#34;
    Connect self to a given peer (host)
    &#34;&#34;&#34;
    if not peer or peer.player.state != PlayerState.HOSTING:
        await self.abort(&#34;The host left the lobby&#34;)
        return

    await self.send_JoinGame(peer.player.login, peer.player.id)

    if not peer:
        await self.abort(&#34;The host left the lobby&#34;)
        return

    await peer.send_ConnectToPeer(
        player_name=self.player.login,
        player_uid=self.player.id,
        offer=True
    )</code></pre>
</details>
</dd>
<dt id="server.GameConnection.connect_to_peer"><code class="name flex">
<span>async def <span class="ident">connect_to_peer</span></span>(<span>self, peer: <a title="server.GameConnection" href="#server.GameConnection">GameConnection</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Connect two peers</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def connect_to_peer(self, peer: &#34;GameConnection&#34;):
    &#34;&#34;&#34;
    Connect two peers
    &#34;&#34;&#34;
    if peer is not None:
        await self.send_ConnectToPeer(
            player_name=peer.player.login,
            player_uid=peer.player.id,
            offer=True
        )

    if peer is not None:
        with contextlib.suppress(DisconnectedError):
            await peer.send_ConnectToPeer(
                player_name=self.player.login,
                player_uid=self.player.id,
                offer=False
            )</code></pre>
</details>
</dd>
<dt id="server.GameConnection.disconnect_all_peers"><code class="name flex">
<span>async def <span class="ident">disconnect_all_peers</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def disconnect_all_peers(self):
    tasks = []
    for peer in self.game.connections:
        if peer == self:
            continue

        tasks.append(peer.send_DisconnectFromPeer(self.player.id))

    for fut in asyncio.as_completed(tasks):
        try:
            await fut
        except Exception:
            self._logger.debug(
                &#34;peer_sendDisconnectFromPeer failed for player %i&#34;,
                self.player.id,
                exc_info=True
            )</code></pre>
</details>
</dd>
<dt id="server.GameConnection.handle_action"><code class="name flex">
<span>async def <span class="ident">handle_action</span></span>(<span>self, command: str, args: list[typing.Any])</span>
</code></dt>
<dd>
<div class="desc"><p>Handle GpgNetSend messages, wrapped in the JSON protocol</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_action(self, command: str, args: list[Any]):
    &#34;&#34;&#34;
    Handle GpgNetSend messages, wrapped in the JSON protocol
    &#34;&#34;&#34;
    try:
        await COMMAND_HANDLERS[command](self, *args)
    except KeyError:
        self._logger.warning(
            &#34;Unrecognized command %s: %s from player %s&#34;,
            command, args, self.player
        )
    except (TypeError, ValueError):
        self._logger.exception(&#34;Bad command arguments&#34;)
    except ConnectionError as e:
        raise e
    except Exception:  # pragma: no cover
        self._logger.exception(&#34;Something awful happened in a game thread!&#34;)
        await self.abort()</code></pre>
</details>
</dd>
<dt id="server.GameConnection.handle_ai_option"><code class="name flex">
<span>async def <span class="ident">handle_ai_option</span></span>(<span>self, name: Any, key: Any, value: Any)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_ai_option(self, name: Any, key: Any, value: Any):
    if not self.is_host():
        return

    self.game.set_ai_option(str(name), key, value)
    self._mark_dirty()</code></pre>
</details>
</dd>
<dt id="server.GameConnection.handle_bottleneck"><code class="name flex">
<span>async def <span class="ident">handle_bottleneck</span></span>(<span>self, *args: list[typing.Any])</span>
</code></dt>
<dd>
<div class="desc"><p>Not sure what this command means. This is currently unused but
included for documentation purposes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_bottleneck(self, *args: list[Any]):
    &#34;&#34;&#34;
    Not sure what this command means. This is currently unused but
    included for documentation purposes.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="server.GameConnection.handle_bottleneck_cleared"><code class="name flex">
<span>async def <span class="ident">handle_bottleneck_cleared</span></span>(<span>self, *args: list[typing.Any])</span>
</code></dt>
<dd>
<div class="desc"><p>Not sure what this command means. This is currently unused but
included for documentation purposes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_bottleneck_cleared(self, *args: list[Any]):
    &#34;&#34;&#34;
    Not sure what this command means. This is currently unused but
    included for documentation purposes.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="server.GameConnection.handle_chat"><code class="name flex">
<span>async def <span class="ident">handle_chat</span></span>(<span>self, message: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Whenever the player sends a chat message during the game lobby.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_chat(self, message: str):
    &#34;&#34;&#34;
    Whenever the player sends a chat message during the game lobby.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="server.GameConnection.handle_clear_slot"><code class="name flex">
<span>async def <span class="ident">handle_clear_slot</span></span>(<span>self, slot: Any)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_clear_slot(self, slot: Any):
    if not self.is_host():
        return

    self.game.clear_slot(int(slot))
    self._mark_dirty()</code></pre>
</details>
</dd>
<dt id="server.GameConnection.handle_desync"><code class="name flex">
<span>async def <span class="ident">handle_desync</span></span>(<span>self, *_args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_desync(self, *_args):  # pragma: no cover
    self.game.desyncs += 1</code></pre>
</details>
</dd>
<dt id="server.GameConnection.handle_disconnected"><code class="name flex">
<span>async def <span class="ident">handle_disconnected</span></span>(<span>self, *args: list[typing.Any])</span>
</code></dt>
<dd>
<div class="desc"><p>Not sure what this command means. This is currently unused but
included for documentation purposes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_disconnected(self, *args: list[Any]):
    &#34;&#34;&#34;
    Not sure what this command means. This is currently unused but
    included for documentation purposes.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="server.GameConnection.handle_enforce_rating"><code class="name flex">
<span>async def <span class="ident">handle_enforce_rating</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_enforce_rating(self):
    self.game.enforce_rating = True</code></pre>
</details>
</dd>
<dt id="server.GameConnection.handle_game_ended"><code class="name flex">
<span>async def <span class="ident">handle_game_ended</span></span>(<span>self, *args: list[typing.Any])</span>
</code></dt>
<dd>
<div class="desc"><p>Signals that the simulation has ended.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_game_ended(self, *args:  list[Any]):
    &#34;&#34;&#34;
    Signals that the simulation has ended.
    &#34;&#34;&#34;
    self.finished_sim = True
    await self.game.check_game_finish(self.player)</code></pre>
</details>
</dd>
<dt id="server.GameConnection.handle_game_full"><code class="name flex">
<span>async def <span class="ident">handle_game_full</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Sent when all game slots are full</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_game_full(self):
    &#34;&#34;&#34;
    Sent when all game slots are full
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="server.GameConnection.handle_game_mods"><code class="name flex">
<span>async def <span class="ident">handle_game_mods</span></span>(<span>self, mode: Any, args: list[typing.Any])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_game_mods(self, mode: Any, args: list[Any]):
    if not self.is_host():
        return

    if mode == &#34;activated&#34;:
        # In this case args is the number of mods
        if int(args) == 0:
            self.game.mods = {}

    elif mode == &#34;uids&#34;:
        uids = str(args).split()
        self.game.mods = {uid: &#34;Unknown sim mod&#34; for uid in uids}
        async with self._db.acquire() as conn:
            rows = await conn.execute(
                &#34;SELECT `uid`, `name` from `table_mod` WHERE `uid` in :ids&#34;,
                ids=tuple(uids)
            )
            for row in rows:
                self.game.mods[row.uid] = row.name
    else:
        self._logger.warning(&#34;Ignoring game mod: %s, %s&#34;, mode, args)
        return

    self._mark_dirty()</code></pre>
</details>
</dd>
<dt id="server.GameConnection.handle_game_option"><code class="name flex">
<span>async def <span class="ident">handle_game_option</span></span>(<span>self, key: str, value: Any)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_game_option(self, key: str, value: Any):
    if not self.is_host():
        return

    if key == &#34;Victory&#34;:
        self.game.gameOptions[&#34;Victory&#34;] = Victory.__members__.get(
            value.upper(), None
        )
    else:
        self.game.gameOptions[key] = value

    if key == &#34;Slots&#34;:
        self.game.max_players = int(value)
    elif key == &#34;ScenarioFile&#34;:
        raw = repr(value)
        self.game.map_scenario_path = \
            raw.replace(&#34;\\&#34;, &#34;/&#34;).replace(&#34;//&#34;, &#34;/&#34;).replace(&#34;&#39;&#34;, &#34;&#34;)
        self.game.map_file_path = &#34;maps/{}.zip&#34;.format(
            self.game.map_scenario_path.split(&#34;/&#34;)[2].lower()
        )
    elif key == &#34;Title&#34;:
        with contextlib.suppress(ValueError):
            self.game.name = value

    self._mark_dirty()</code></pre>
</details>
</dd>
<dt id="server.GameConnection.handle_game_result"><code class="name flex">
<span>async def <span class="ident">handle_game_result</span></span>(<span>self, army: Any, result: Any)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_game_result(self, army: Any, result: Any):
    army = int(army)
    result = str(result).lower()

    try:
        *metadata, result_type, score = result.split()
    except ValueError:
        self._logger.warning(&#34;Invalid result for %s reported: %s&#34;, army, result)
    else:
        await self.game.add_result(
            self.player.id, army, result_type, int(score), frozenset(metadata)
        )</code></pre>
</details>
</dd>
<dt id="server.GameConnection.handle_game_state"><code class="name flex">
<span>async def <span class="ident">handle_game_state</span></span>(<span>self, state: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Changes in game state</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_game_state(self, state: str):
    &#34;&#34;&#34;
    Changes in game state
    &#34;&#34;&#34;

    if state == &#34;Idle&#34;:
        await self._handle_idle_state()
        # Don&#39;t mark as dirty
        return

    elif state == &#34;Lobby&#34;:
        # TODO: Do we still need to schedule with `ensure_future`?
        #
        # We do not yield from the task, since we
        # need to keep processing other commands while it runs
        await self._handle_lobby_state()

    elif state == &#34;Launching&#34;:
        if self.player.state != PlayerState.HOSTING:
            return

        if self.game.state is not GameState.LOBBY:
            self._logger.warning(
                &#34;Trying to launch game %s in invalid state %s&#34;,
                self.game,
                self.game.state
            )
            return

        self._logger.info(&#34;Launching game %s&#34;, self.game)

        await self.game.launch()

        if len(self.game.mods.keys()) &gt; 0:
            async with self._db.acquire() as conn:
                uids = list(self.game.mods.keys())
                await conn.execute(
                    &#34;UPDATE mod_stats s JOIN mod_version v ON &#34;
                    &#34;v.mod_id = s.mod_id &#34;
                    &#34;SET s.times_played = s.times_played + 1 &#34;
                    &#34;WHERE v.uid in :ids&#34;,
                    ids=tuple(uids)
                )
    # Signals that the FA executable has been closed
    elif state == &#34;Ended&#34;:
        await self.on_connection_lost()
    self._mark_dirty()</code></pre>
</details>
</dd>
<dt id="server.GameConnection.handle_ice_message"><code class="name flex">
<span>async def <span class="ident">handle_ice_message</span></span>(<span>self, receiver_id: Any, ice_msg: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_ice_message(self, receiver_id: Any, ice_msg: str):
    receiver_id = int(receiver_id)
    peer = self.player_service.get_player(receiver_id)
    if not peer:
        self._logger.debug(
            &#34;Ignoring ICE message for unknown player: %s&#34;, receiver_id
        )
        return

    game_connection = peer.game_connection
    if not game_connection:
        self._logger.debug(
            &#34;Ignoring ICE message for player without game connection: %s&#34;, receiver_id
        )
        return

    try:
        await game_connection.send({
            &#34;command&#34;: &#34;IceMsg&#34;,
            &#34;args&#34;: [int(self.player.id), ice_msg]
        })
    except DisconnectedError:
        self._logger.debug(
            &#34;Failed to send ICE message to player due to a disconnect: %s&#34;,
            receiver_id
        )</code></pre>
</details>
</dd>
<dt id="server.GameConnection.handle_json_stats"><code class="name flex">
<span>async def <span class="ident">handle_json_stats</span></span>(<span>self, stats: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_json_stats(self, stats: str):
    try:
        self.game.report_army_stats(stats)
    except json.JSONDecodeError:
        self._logger.warning(
            &#34;Malformed game stats reported by %s: &#39;...%s&#39;&#34;,
            self._player.login,
            stats[-20:]
        )</code></pre>
</details>
</dd>
<dt id="server.GameConnection.handle_launch_status"><code class="name flex">
<span>async def <span class="ident">handle_launch_status</span></span>(<span>self, status: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Currently is sent with status <code>Rejected</code> if a matchmaker game failed
to start due to players using differing game settings.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_launch_status(self, status: str):
    &#34;&#34;&#34;
    Currently is sent with status `Rejected` if a matchmaker game failed
    to start due to players using differing game settings.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="server.GameConnection.handle_operation_complete"><code class="name flex">
<span>async def <span class="ident">handle_operation_complete</span></span>(<span>self, primary: Any, secondary: Any, delta: str)</span>
</code></dt>
<dd>
<div class="desc"><h1 id="params">Params</h1>
<ul>
<li><code>primary</code>: are primary mission objectives complete?</li>
<li><code>secondary</code>: are secondary mission objectives complete?</li>
<li><code>delta</code>: the time it took to complete the mission</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_operation_complete(
    self, primary: Any, secondary: Any, delta: str
):
    &#34;&#34;&#34;
    # Params
    - `primary`: are primary mission objectives complete?
    - `secondary`: are secondary mission objectives complete?
    - `delta`: the time it took to complete the mission
    &#34;&#34;&#34;
    primary = FA.ENABLED == primary
    secondary = FA.ENABLED == secondary

    if not primary:
        return

    if not isinstance(self.game, CoopGame):
        self._logger.warning(
            &#34;OperationComplete called for non-coop game: %s&#34;, self.game.id
        )
        return

    if self.game.validity != ValidityState.COOP_NOT_RANKED:
        return

    secondary, delta = secondary, str(delta)
    async with self._db.acquire() as conn:
        result = await conn.execute(
            select([coop_map.c.id]).where(
                coop_map.c.filename == self.game.map_file_path
            )
        )
        row = result.fetchone()
        if not row:
            self._logger.debug(
                &#34;can&#39;t find coop map: %s&#34;, self.game.map_file_path
            )
            return
        mission = row.id

        # Each player in a co-op game will send the OperationComplete
        # message but we only need to perform this insert once
        if not self.game.leaderboard_saved:
            await conn.execute(
                coop_leaderboard.insert().values(
                    mission=mission,
                    gameuid=self.game.id,
                    secondary=secondary,
                    time=delta,
                    player_count=len(self.game.players),
                )
            )
            self.game.leaderboard_saved = True</code></pre>
</details>
</dd>
<dt id="server.GameConnection.handle_player_option"><code class="name flex">
<span>async def <span class="ident">handle_player_option</span></span>(<span>self, player_id: Any, key: Any, value: Any)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_player_option(
    self, player_id: Any, key: Any, value: Any
):
    if not self.is_host():
        return

    self.game.set_player_option(int(player_id), key, value)
    self._mark_dirty()</code></pre>
</details>
</dd>
<dt id="server.GameConnection.handle_rehost"><code class="name flex">
<span>async def <span class="ident">handle_rehost</span></span>(<span>self, *args: list[typing.Any])</span>
</code></dt>
<dd>
<div class="desc"><p>Signals that the user has rehosted the game. This is currently unused but
included for documentation purposes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_rehost(self, *args: list[Any]):
    &#34;&#34;&#34;
    Signals that the user has rehosted the game. This is currently unused but
    included for documentation purposes.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="server.GameConnection.handle_teamkill_happened"><code class="name flex">
<span>async def <span class="ident">handle_teamkill_happened</span></span>(<span>self, gametime: Any, victim_id: Any, victim_name: str, teamkiller_id: Any, teamkiller_name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Send automatically by the game whenever a teamkill happens. Takes
the same parameters as TeamkillReport.</p>
<h1 id="params">Params</h1>
<ul>
<li><code>gametime</code>: seconds of gametime when kill happened</li>
<li><code>victim_id</code>: victim id</li>
<li><code>victim_name</code>: victim nickname (for debug purpose only)</li>
<li><code>teamkiller_id</code>: teamkiller id</li>
<li><code>teamkiller_name</code>: teamkiller nickname (for debug purpose only)</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_teamkill_happened(
    self,
    gametime: Any,
    victim_id: Any,
    victim_name: str,
    teamkiller_id: Any,
    teamkiller_name: str,
):
    &#34;&#34;&#34;
    Send automatically by the game whenever a teamkill happens. Takes
    the same parameters as TeamkillReport.

    # Params
    - `gametime`: seconds of gametime when kill happened
    - `victim_id`: victim id
    - `victim_name`: victim nickname (for debug purpose only)
    - `teamkiller_id`: teamkiller id
    - `teamkiller_name`: teamkiller nickname (for debug purpose only)
    &#34;&#34;&#34;
    victim_id = int(victim_id)
    teamkiller_id = int(teamkiller_id)

    if 0 in (victim_id, teamkiller_id):
        self._logger.debug(&#34;Ignoring teamkill for AI player&#34;)
        return

    async with self._db.acquire() as conn:
        await conn.execute(
            teamkills.insert().values(
                teamkiller=teamkiller_id,
                victim=victim_id,
                game_id=self.game.id,
                gametime=gametime,
            )
        )</code></pre>
</details>
</dd>
<dt id="server.GameConnection.handle_teamkill_report"><code class="name flex">
<span>async def <span class="ident">handle_teamkill_report</span></span>(<span>self, gametime: Any, reporter_id: Any, reporter_name: str, teamkiller_id: Any, teamkiller_name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Sent when a player is teamkilled and clicks the 'Report' button.</p>
<h1 id="params">Params</h1>
<ul>
<li><code>gametime</code>: seconds of gametime when kill happened</li>
<li><code>reporter_id</code>: reporter id</li>
<li><code>reporter_name</code>: reporter nickname (for debug purpose only)</li>
<li><code>teamkiller_id</code>: teamkiller id</li>
<li><code>teamkiller_name</code>: teamkiller nickname (for debug purpose only)</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_teamkill_report(
    self,
    gametime: Any,
    reporter_id: Any,
    reporter_name: str,
    teamkiller_id: Any,
    teamkiller_name: str,
):
    &#34;&#34;&#34;
    Sent when a player is teamkilled and clicks the &#39;Report&#39; button.

    # Params
    - `gametime`: seconds of gametime when kill happened
    - `reporter_id`: reporter id
    - `reporter_name`: reporter nickname (for debug purpose only)
    - `teamkiller_id`: teamkiller id
    - `teamkiller_name`: teamkiller nickname (for debug purpose only)
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="server.GameConnection.is_host"><code class="name flex">
<span>def <span class="ident">is_host</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_host(self) -&gt; bool:
    if not self.game or not self.player:
        return False

    return (
        self.player.state == PlayerState.HOSTING and
        self.player == self.game.host
    )</code></pre>
</details>
</dd>
<dt id="server.GameConnection.on_connection_lost"><code class="name flex">
<span>async def <span class="ident">on_connection_lost</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def on_connection_lost(self):
    try:
        await self.game.remove_game_connection(self)
    except Exception as e:  # pragma: no cover
        self._logger.exception(e)
    finally:
        await self.abort()</code></pre>
</details>
</dd>
<dt id="server.GameConnection.send"><code class="name flex">
<span>async def <span class="ident">send</span></span>(<span>self, message)</span>
</code></dt>
<dd>
<div class="desc"><p>Send a game message to the client.</p>
<h1 id="errors">Errors</h1>
<p>May raise <code>DisconnectedError</code></p>
<p>NOTE: When calling this on a connection other than <code>self</code> make sure to
handle <code>DisconnectedError</code>, otherwise failure to send the message will
cause the caller to be disconnected as well.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send(self, message):
    &#34;&#34;&#34;
    Send a game message to the client.

    # Errors
    May raise `DisconnectedError`

    NOTE: When calling this on a connection other than `self` make sure to
    handle `DisconnectedError`, otherwise failure to send the message will
    cause the caller to be disconnected as well.
    &#34;&#34;&#34;
    message[&#34;target&#34;] = &#34;game&#34;

    self._logger.log(TRACE, &#34;&gt;&gt; %s: %s&#34;, self.player.login, message)
    await self.protocol.send_message(message)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="server.protocol.gpgnet.GpgNetServerProtocol" href="protocol/gpgnet.html#server.protocol.gpgnet.GpgNetServerProtocol">GpgNetServerProtocol</a></b></code>:
<ul class="hlist">
<li><code><a title="server.protocol.gpgnet.GpgNetServerProtocol.send_ConnectToPeer" href="protocol/gpgnet.html#server.protocol.gpgnet.GpgNetServerProtocol.send_ConnectToPeer">send_ConnectToPeer</a></code></li>
<li><code><a title="server.protocol.gpgnet.GpgNetServerProtocol.send_DisconnectFromPeer" href="protocol/gpgnet.html#server.protocol.gpgnet.GpgNetServerProtocol.send_DisconnectFromPeer">send_DisconnectFromPeer</a></code></li>
<li><code><a title="server.protocol.gpgnet.GpgNetServerProtocol.send_HostGame" href="protocol/gpgnet.html#server.protocol.gpgnet.GpgNetServerProtocol.send_HostGame">send_HostGame</a></code></li>
<li><code><a title="server.protocol.gpgnet.GpgNetServerProtocol.send_JoinGame" href="protocol/gpgnet.html#server.protocol.gpgnet.GpgNetServerProtocol.send_JoinGame">send_JoinGame</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="server.GameService"><code class="flex name class">
<span>class <span class="ident">GameService</span></span>
<span>(</span><span>database: <a title="server.db.FAFDatabase" href="db/index.html#server.db.FAFDatabase">FAFDatabase</a>, player_service, game_stats_service, rating_service: <a title="server.rating_service.rating_service.RatingService" href="rating_service/rating_service.html#server.rating_service.rating_service.RatingService">RatingService</a>, message_queue_service: <a title="server.message_queue_service.MessageQueueService" href="message_queue_service.html#server.message_queue_service.MessageQueueService">MessageQueueService</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Utility class for maintaining lifecycle of games</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@with_logger
class GameService(Service):
    &#34;&#34;&#34;
    Utility class for maintaining lifecycle of games
    &#34;&#34;&#34;

    def __init__(
        self,
        database: FAFDatabase,
        player_service,
        game_stats_service,
        rating_service: RatingService,
        message_queue_service: MessageQueueService
    ):
        self._db = database
        self._dirty_games: set[Game] = set()
        self._dirty_queues: set[MatchmakerQueue] = set()
        self.player_service = player_service
        self.game_stats_service = game_stats_service
        self._rating_service = rating_service
        self._message_queue_service = message_queue_service
        self.game_id_counter = 0

        # Populated below in really_update_static_ish_data.
        self.featured_mods = dict()

        # A set of mod ids that are allowed in ranked games
        self.ranked_mods: set[str] = set()

        # The set of active games
        self._games: dict[int, Game] = dict()

    async def initialize(self) -&gt; None:
        await self.initialise_game_counter()
        await self.update_data()
        self._update_cron = aiocron.crontab(
            &#34;*/10 * * * *&#34;, func=self.update_data
        )

    async def initialise_game_counter(self):
        async with self._db.acquire() as conn:
            # InnoDB, unusually, doesn&#39;t allow insertion of values greater than the next expected
            # value into an auto_increment field. We&#39;d like to do that, because we no longer insert
            # games into the database when they don&#39;t start, so game ids aren&#39;t contiguous (as
            # unstarted games consume ids that never get written out).
            # So, id has to just be an integer primary key, no auto-increment: we handle its
            # incrementing here in game service, but have to do this slightly expensive query on
            # startup (though the primary key index probably makes it super fast anyway).
            # This is definitely a better choice than inserting useless rows when games are created,
            # doing LAST_UPDATE_ID to get the id number, and then doing an UPDATE when the actual
            # data to go into the row becomes available: we now only do a single insert for each
            # game, and don&#39;t end up with 800,000 junk rows in the database.
            self.game_id_counter = await conn.scalar(&#34;SELECT MAX(id) FROM game_stats&#34;)

    async def update_data(self):
        &#34;&#34;&#34;
        Loads from the database the mostly-constant things that it doesn&#39;t make sense to query every
        time we need, but which can in principle change over time.
        &#34;&#34;&#34;
        async with self._db.acquire() as conn:
            rows = await conn.execute(select([
                game_featuredMods.c.id,
                game_featuredMods.c.gamemod,
                game_featuredMods.c.name,
                game_featuredMods.c.description,
                game_featuredMods.c.publish,
                game_featuredMods.c.order
            ]).select_from(game_featuredMods))

            for row in rows:
                self.featured_mods[row.gamemod] = FeaturedMod(
                    row.id,
                    row.gamemod,
                    row.name,
                    row.description,
                    row.publish,
                    row.order
                )

            result = await conn.execute(&#34;SELECT uid FROM table_mod WHERE ranked = 1&#34;)

            # Turn resultset into a list of uids
            self.ranked_mods = {row.uid for row in result}

    def mark_dirty(self, obj: Union[Game, MatchmakerQueue]):
        if isinstance(obj, Game):
            self._dirty_games.add(obj)
        elif isinstance(obj, MatchmakerQueue):
            self._dirty_queues.add(obj)

    def pop_dirty_games(self) -&gt; set[Game]:
        dirty_games = self._dirty_games
        self._dirty_games = set()

        return dirty_games

    def pop_dirty_queues(self) -&gt; set[MatchmakerQueue]:
        dirty_queues = self._dirty_queues
        self._dirty_queues = set()

        return dirty_queues

    def create_uid(self) -&gt; int:
        self.game_id_counter += 1

        return self.game_id_counter

    def create_game(
        self,
        game_mode: str,
        game_class: type[Game] = CustomGame,
        visibility=VisibilityState.PUBLIC,
        host: Optional[Player] = None,
        name: Optional[str] = None,
        mapname: Optional[str] = None,
        password: Optional[str] = None,
        matchmaker_queue_id: Optional[int] = None,
        **kwargs
    ):
        &#34;&#34;&#34;
        Main entrypoint for creating new games
        &#34;&#34;&#34;
        game_id = self.create_uid()
        game_args = {
            &#34;database&#34;: self._db,
            &#34;id_&#34;: game_id,
            &#34;host&#34;: host,
            &#34;name&#34;: name,
            &#34;map_&#34;: mapname,
            &#34;game_mode&#34;: game_mode,
            &#34;game_service&#34;: self,
            &#34;game_stats_service&#34;: self.game_stats_service,
            &#34;matchmaker_queue_id&#34;: matchmaker_queue_id,
        }
        game_args.update(kwargs)
        game = game_class(**game_args)

        self._games[game_id] = game

        game.visibility = visibility
        game.password = password

        self.mark_dirty(game)
        return game

    def update_active_game_metrics(self):
        modes = list(self.featured_mods.keys())

        game_counter = Counter(
            (
                game.game_mode if game.game_mode in modes else &#34;other&#34;,
                game.state
            )
            for game in self._games.values()
        )

        for state in GameState:
            for mode in modes + [&#34;other&#34;]:
                metrics.active_games.labels(mode, state.name).set(
                    game_counter[(mode, state)]
                )

    @property
    def live_games(self) -&gt; list[Game]:
        return [game for game in self._games.values()
                if game.state is GameState.LIVE]

    @property
    def open_games(self) -&gt; list[Game]:
        &#34;&#34;&#34;
        Return all games that meet the client&#39;s definition of &#34;not closed&#34;.
        Server game states are mapped to client game states as follows:

            GameState.LOBBY: &#34;open&#34;,
            GameState.LIVE: &#34;playing&#34;,
            GameState.ENDED: &#34;closed&#34;,
            GameState.INITIALIZING: &#34;closed&#34;,

        The client ignores everything &#34;closed&#34;. This property fetches all such not-closed games.
        &#34;&#34;&#34;
        return [game for game in self._games.values()
                if game.state is GameState.LOBBY or game.state is GameState.LIVE]

    @property
    def all_games(self) -&gt; ValuesView[Game]:
        return self._games.values()

    @property
    def pending_games(self) -&gt; list[Game]:
        return [game for game in self._games.values()
                if game.state is GameState.LOBBY or game.state is GameState.INITIALIZING]

    def remove_game(self, game: Game):
        if game.id in self._games:
            del self._games[game.id]

    def __getitem__(self, item: int) -&gt; Game:
        return self._games[item]

    def __contains__(self, item):
        return item in self._games

    async def publish_game_results(self, game_results: EndedGameInfo):
        result_dict = game_results.to_dict()
        await self._message_queue_service.publish(
            config.MQ_EXCHANGE_NAME,
            &#34;success.gameResults.create&#34;,
            result_dict,
        )

        if (
            game_results.validity is ValidityState.VALID
            and game_results.rating_type is not None
        ):
            metrics.rated_games.labels(game_results.rating_type).inc()
            # TODO: Remove when rating service starts listening to message queue
            await self._rating_service.enqueue(result_dict)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="server.core.service.Service" href="core/service.html#server.core.service.Service">Service</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="server.GameService.all_games"><code class="name">var <span class="ident">all_games</span> : ValuesView[<a title="server.games.game.Game" href="games/game.html#server.games.game.Game">Game</a>]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def all_games(self) -&gt; ValuesView[Game]:
    return self._games.values()</code></pre>
</details>
</dd>
<dt id="server.GameService.live_games"><code class="name">var <span class="ident">live_games</span> : list[<a title="server.games.game.Game" href="games/game.html#server.games.game.Game">Game</a>]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def live_games(self) -&gt; list[Game]:
    return [game for game in self._games.values()
            if game.state is GameState.LIVE]</code></pre>
</details>
</dd>
<dt id="server.GameService.open_games"><code class="name">var <span class="ident">open_games</span> : list[<a title="server.games.game.Game" href="games/game.html#server.games.game.Game">Game</a>]</code></dt>
<dd>
<div class="desc"><p>Return all games that meet the client's definition of "not closed".
Server game states are mapped to client game states as follows:</p>
<pre><code>GameState.LOBBY: "open",
GameState.LIVE: "playing",
GameState.ENDED: "closed",
GameState.INITIALIZING: "closed",
</code></pre>
<p>The client ignores everything "closed". This property fetches all such not-closed games.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def open_games(self) -&gt; list[Game]:
    &#34;&#34;&#34;
    Return all games that meet the client&#39;s definition of &#34;not closed&#34;.
    Server game states are mapped to client game states as follows:

        GameState.LOBBY: &#34;open&#34;,
        GameState.LIVE: &#34;playing&#34;,
        GameState.ENDED: &#34;closed&#34;,
        GameState.INITIALIZING: &#34;closed&#34;,

    The client ignores everything &#34;closed&#34;. This property fetches all such not-closed games.
    &#34;&#34;&#34;
    return [game for game in self._games.values()
            if game.state is GameState.LOBBY or game.state is GameState.LIVE]</code></pre>
</details>
</dd>
<dt id="server.GameService.pending_games"><code class="name">var <span class="ident">pending_games</span> : list[<a title="server.games.game.Game" href="games/game.html#server.games.game.Game">Game</a>]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def pending_games(self) -&gt; list[Game]:
    return [game for game in self._games.values()
            if game.state is GameState.LOBBY or game.state is GameState.INITIALIZING]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="server.GameService.create_game"><code class="name flex">
<span>def <span class="ident">create_game</span></span>(<span>self, game_mode: str, game_class: type[<a title="server.games.game.Game" href="games/game.html#server.games.game.Game">Game</a>] = server.games.custom_game.CustomGame, visibility=VisibilityState.PUBLIC, host: Optional[<a title="server.players.Player" href="players.html#server.players.Player">Player</a>] = None, name: Optional[str] = None, mapname: Optional[str] = None, password: Optional[str] = None, matchmaker_queue_id: Optional[int] = None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Main entrypoint for creating new games</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_game(
    self,
    game_mode: str,
    game_class: type[Game] = CustomGame,
    visibility=VisibilityState.PUBLIC,
    host: Optional[Player] = None,
    name: Optional[str] = None,
    mapname: Optional[str] = None,
    password: Optional[str] = None,
    matchmaker_queue_id: Optional[int] = None,
    **kwargs
):
    &#34;&#34;&#34;
    Main entrypoint for creating new games
    &#34;&#34;&#34;
    game_id = self.create_uid()
    game_args = {
        &#34;database&#34;: self._db,
        &#34;id_&#34;: game_id,
        &#34;host&#34;: host,
        &#34;name&#34;: name,
        &#34;map_&#34;: mapname,
        &#34;game_mode&#34;: game_mode,
        &#34;game_service&#34;: self,
        &#34;game_stats_service&#34;: self.game_stats_service,
        &#34;matchmaker_queue_id&#34;: matchmaker_queue_id,
    }
    game_args.update(kwargs)
    game = game_class(**game_args)

    self._games[game_id] = game

    game.visibility = visibility
    game.password = password

    self.mark_dirty(game)
    return game</code></pre>
</details>
</dd>
<dt id="server.GameService.create_uid"><code class="name flex">
<span>def <span class="ident">create_uid</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_uid(self) -&gt; int:
    self.game_id_counter += 1

    return self.game_id_counter</code></pre>
</details>
</dd>
<dt id="server.GameService.initialise_game_counter"><code class="name flex">
<span>async def <span class="ident">initialise_game_counter</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def initialise_game_counter(self):
    async with self._db.acquire() as conn:
        # InnoDB, unusually, doesn&#39;t allow insertion of values greater than the next expected
        # value into an auto_increment field. We&#39;d like to do that, because we no longer insert
        # games into the database when they don&#39;t start, so game ids aren&#39;t contiguous (as
        # unstarted games consume ids that never get written out).
        # So, id has to just be an integer primary key, no auto-increment: we handle its
        # incrementing here in game service, but have to do this slightly expensive query on
        # startup (though the primary key index probably makes it super fast anyway).
        # This is definitely a better choice than inserting useless rows when games are created,
        # doing LAST_UPDATE_ID to get the id number, and then doing an UPDATE when the actual
        # data to go into the row becomes available: we now only do a single insert for each
        # game, and don&#39;t end up with 800,000 junk rows in the database.
        self.game_id_counter = await conn.scalar(&#34;SELECT MAX(id) FROM game_stats&#34;)</code></pre>
</details>
</dd>
<dt id="server.GameService.mark_dirty"><code class="name flex">
<span>def <span class="ident">mark_dirty</span></span>(<span>self, obj: Union[<a title="server.games.game.Game" href="games/game.html#server.games.game.Game">Game</a>, <a title="server.matchmaker.matchmaker_queue.MatchmakerQueue" href="matchmaker/matchmaker_queue.html#server.matchmaker.matchmaker_queue.MatchmakerQueue">MatchmakerQueue</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mark_dirty(self, obj: Union[Game, MatchmakerQueue]):
    if isinstance(obj, Game):
        self._dirty_games.add(obj)
    elif isinstance(obj, MatchmakerQueue):
        self._dirty_queues.add(obj)</code></pre>
</details>
</dd>
<dt id="server.GameService.pop_dirty_games"><code class="name flex">
<span>def <span class="ident">pop_dirty_games</span></span>(<span>self) ‑> set[<a title="server.games.game.Game" href="games/game.html#server.games.game.Game">Game</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop_dirty_games(self) -&gt; set[Game]:
    dirty_games = self._dirty_games
    self._dirty_games = set()

    return dirty_games</code></pre>
</details>
</dd>
<dt id="server.GameService.pop_dirty_queues"><code class="name flex">
<span>def <span class="ident">pop_dirty_queues</span></span>(<span>self) ‑> set[<a title="server.matchmaker.matchmaker_queue.MatchmakerQueue" href="matchmaker/matchmaker_queue.html#server.matchmaker.matchmaker_queue.MatchmakerQueue">MatchmakerQueue</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop_dirty_queues(self) -&gt; set[MatchmakerQueue]:
    dirty_queues = self._dirty_queues
    self._dirty_queues = set()

    return dirty_queues</code></pre>
</details>
</dd>
<dt id="server.GameService.publish_game_results"><code class="name flex">
<span>async def <span class="ident">publish_game_results</span></span>(<span>self, game_results: <a title="server.games.typedefs.EndedGameInfo" href="games/typedefs.html#server.games.typedefs.EndedGameInfo">EndedGameInfo</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def publish_game_results(self, game_results: EndedGameInfo):
    result_dict = game_results.to_dict()
    await self._message_queue_service.publish(
        config.MQ_EXCHANGE_NAME,
        &#34;success.gameResults.create&#34;,
        result_dict,
    )

    if (
        game_results.validity is ValidityState.VALID
        and game_results.rating_type is not None
    ):
        metrics.rated_games.labels(game_results.rating_type).inc()
        # TODO: Remove when rating service starts listening to message queue
        await self._rating_service.enqueue(result_dict)</code></pre>
</details>
</dd>
<dt id="server.GameService.remove_game"><code class="name flex">
<span>def <span class="ident">remove_game</span></span>(<span>self, game: <a title="server.games.game.Game" href="games/game.html#server.games.game.Game">Game</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_game(self, game: Game):
    if game.id in self._games:
        del self._games[game.id]</code></pre>
</details>
</dd>
<dt id="server.GameService.update_active_game_metrics"><code class="name flex">
<span>def <span class="ident">update_active_game_metrics</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_active_game_metrics(self):
    modes = list(self.featured_mods.keys())

    game_counter = Counter(
        (
            game.game_mode if game.game_mode in modes else &#34;other&#34;,
            game.state
        )
        for game in self._games.values()
    )

    for state in GameState:
        for mode in modes + [&#34;other&#34;]:
            metrics.active_games.labels(mode, state.name).set(
                game_counter[(mode, state)]
            )</code></pre>
</details>
</dd>
<dt id="server.GameService.update_data"><code class="name flex">
<span>async def <span class="ident">update_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads from the database the mostly-constant things that it doesn't make sense to query every
time we need, but which can in principle change over time.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def update_data(self):
    &#34;&#34;&#34;
    Loads from the database the mostly-constant things that it doesn&#39;t make sense to query every
    time we need, but which can in principle change over time.
    &#34;&#34;&#34;
    async with self._db.acquire() as conn:
        rows = await conn.execute(select([
            game_featuredMods.c.id,
            game_featuredMods.c.gamemod,
            game_featuredMods.c.name,
            game_featuredMods.c.description,
            game_featuredMods.c.publish,
            game_featuredMods.c.order
        ]).select_from(game_featuredMods))

        for row in rows:
            self.featured_mods[row.gamemod] = FeaturedMod(
                row.id,
                row.gamemod,
                row.name,
                row.description,
                row.publish,
                row.order
            )

        result = await conn.execute(&#34;SELECT uid FROM table_mod WHERE ranked = 1&#34;)

        # Turn resultset into a list of uids
        self.ranked_mods = {row.uid for row in result}</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="server.core.service.Service" href="core/service.html#server.core.service.Service">Service</a></b></code>:
<ul class="hlist">
<li><code><a title="server.core.service.Service.initialize" href="core/service.html#server.core.service.Service.initialize">initialize</a></code></li>
<li><code><a title="server.core.service.Service.on_connection_lost" href="core/service.html#server.core.service.Service.on_connection_lost">on_connection_lost</a></code></li>
<li><code><a title="server.core.service.Service.shutdown" href="core/service.html#server.core.service.Service.shutdown">shutdown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="server.GameStatsService"><code class="flex name class">
<span>class <span class="ident">GameStatsService</span></span>
<span>(</span><span>event_service: <a title="server.stats.event_service.EventService" href="stats/event_service.html#server.stats.event_service.EventService">EventService</a>, achievement_service: <a title="server.stats.achievement_service.AchievementService" href="stats/achievement_service.html#server.stats.achievement_service.AchievementService">AchievementService</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>All services should inherit from this class.</p>
<p>Services are singleton objects which manage some server task.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@with_logger
class GameStatsService(Service):
    def __init__(self, event_service: EventService, achievement_service: AchievementService):
        self._event_service = event_service
        self._achievement_service = achievement_service

    async def process_game_stats(
        self,
        player: Player,
        game: Game,
        army_stats_list: list
    ):
        try:
            await self._process_game_stats(player, game, army_stats_list)
        except KeyError as e:
            self._logger.info(&#34;Malformed game stats. KeyError: %s&#34;, e)
        except Exception:
            self._logger.exception(
                &#34;Error processing game stats for %s in game %d&#34;,
                player.login,
                game.id
            )

    async def _process_game_stats(
        self,
        player: Player,
        game: Game,
        army_stats_list: list
    ):
        stats = None
        number_of_humans = 0
        highest_score = 0
        highest_scorer = None

        for army_stats in army_stats_list:
            if army_stats[&#34;type&#34;] == &#34;AI&#34; and army_stats[&#34;name&#34;] != &#34;civilian&#34;:
                self._logger.debug(&#34;Ignoring AI game reported by %s&#34;, player.login)
                return

            if army_stats[&#34;type&#34;] == &#34;Human&#34;:
                number_of_humans += 1

                if highest_score &lt; army_stats[&#34;general&#34;][&#34;score&#34;]:
                    highest_score = army_stats[&#34;general&#34;][&#34;score&#34;]
                    highest_scorer = army_stats[&#34;name&#34;]

            if army_stats[&#34;name&#34;] == player.login:
                stats = army_stats

        if number_of_humans &lt; 2:
            self._logger.debug(&#34;Ignoring single player game reported by %s&#34;, player.login)
            return

        if stats is None:
            self._logger.warning(&#34;Player %s reported stats of a game he was not part of&#34;, player.login)
            return

        army_result = game.get_player_outcome(player)
        if army_result is ArmyOutcome.UNKNOWN:
            self._logger.warning(&#34;No army result available for player %s&#34;, player.login)
            return

        self._logger.debug(&#34;Processing game stats for player: %s&#34;, player.login)

        faction = stats[&#34;faction&#34;]
        # Stores achievements to batch update
        a_queue = []
        # Stores events to batch update
        e_queue = []
        self._logger.debug(&#34;Army result for %s =&gt; %s &#34;, player, army_result)

        survived = army_result is ArmyOutcome.VICTORY
        blueprint_stats = stats[&#34;blueprints&#34;]
        unit_stats = stats[&#34;units&#34;]
        scored_highest = highest_scorer == player.login

        if survived and game.game_mode == FeaturedModType.LADDER_1V1:
            self._unlock(ACH_FIRST_SUCCESS, a_queue)

        self._increment(ACH_NOVICE, 1, a_queue)
        self._increment(ACH_JUNIOR, 1, a_queue)
        self._increment(ACH_SENIOR, 1, a_queue)
        self._increment(ACH_VETERAN, 1, a_queue)
        self._increment(ACH_ADDICT, 1, a_queue)

        self._faction_played(faction, survived, a_queue, e_queue)
        self._category_stats(unit_stats, survived, a_queue, e_queue)
        self._killed_acus(unit_stats, survived, a_queue)
        self._built_mercies(_count_built_units(blueprint_stats, Unit.MERCY), a_queue)
        self._built_fire_beetles(_count_built_units(blueprint_stats, Unit.FIRE_BEETLE), a_queue)
        self._built_salvations(_count_built_units(blueprint_stats, Unit.SALVATION), survived, a_queue)
        self._built_yolona_oss(_count_built_units(blueprint_stats, Unit.YOLONA_OSS), survived, a_queue)
        self._built_paragons(_count_built_units(blueprint_stats, Unit.PARAGON), survived, a_queue)
        self._built_atlantis(_count_built_units(blueprint_stats, Unit.ATLANTIS), a_queue)
        self._built_tempests(_count_built_units(blueprint_stats, Unit.TEMPEST), a_queue)
        self._built_scathis(_count_built_units(blueprint_stats, Unit.SCATHIS), survived, a_queue)
        self._built_mavors(_count_built_units(blueprint_stats, Unit.MAVOR), survived, a_queue)
        self._built_czars(_count_built_units(blueprint_stats, Unit.CZAR), a_queue)
        self._built_ahwassas(_count_built_units(blueprint_stats, Unit.AHWASSA), a_queue)
        self._built_ythothas(_count_built_units(blueprint_stats, Unit.YTHOTHA), a_queue)
        self._built_fatboys(_count_built_units(blueprint_stats, Unit.FATBOY), a_queue)
        self._built_monkeylords(_count_built_units(blueprint_stats, Unit.MONKEYLORD), a_queue)
        self._built_galactic_colossus(_count_built_units(blueprint_stats, Unit.GALACTIC_COLOSSUS), a_queue)
        self._built_soul_rippers(_count_built_units(blueprint_stats, Unit.SOUL_RIPPER), a_queue)
        self._built_megaliths(_count_built_units(blueprint_stats, Unit.MEGALITH), a_queue)
        self._built_asfs(_count_built_units(blueprint_stats, *ASFS), a_queue)
        self._built_transports(unit_stats[&#34;transportation&#34;].get(&#34;built&#34;, 0), a_queue)
        self._built_sacus(unit_stats[&#34;sacu&#34;].get(&#34;built&#34;, 0), a_queue)
        self._lowest_acu_health(_count(blueprint_stats, lambda x: x.get(&#34;lowest_health&#34;, 0), *ACUS), survived, a_queue)
        self._highscore(scored_highest, number_of_humans, a_queue)

        if config.USE_API:
            updated_achievements = await self._achievement_service.execute_batch_update(player.id, a_queue)

            if updated_achievements is None:
                self._logger.warning(&#34;API returned an error while handling the achievements batch update.&#34;)
                return

            await self._event_service.execute_batch_update(player.id, e_queue)
            if player.lobby_connection is not None:
                await player.lobby_connection.send_updated_achievements(updated_achievements)

    def _category_stats(self, unit_stats, survived, achievements_queue, events_queue):
        built_air = unit_stats[&#34;air&#34;].get(&#34;built&#34;, 0)
        built_land = unit_stats[&#34;land&#34;].get(&#34;built&#34;, 0)
        built_naval = unit_stats[&#34;naval&#34;].get(&#34;built&#34;, 0)
        built_experimentals = unit_stats[&#34;experimental&#34;].get(&#34;built&#34;, 0)

        self._record_event(EVENT_BUILT_AIR_UNITS, built_air, events_queue)
        self._record_event(EVENT_LOST_AIR_UNITS, unit_stats[&#34;air&#34;].get(&#34;lost&#34;, 0), events_queue)
        self._record_event(EVENT_BUILT_LAND_UNITS, built_land, events_queue)
        self._record_event(EVENT_LOST_LAND_UNITS, unit_stats[&#34;land&#34;].get(&#34;lost&#34;, 0), events_queue)
        self._record_event(EVENT_BUILT_NAVAL_UNITS, built_naval, events_queue)
        self._record_event(EVENT_LOST_NAVAL_UNITS, unit_stats[&#34;naval&#34;].get(&#34;lost&#34;, 0), events_queue)
        self._record_event(EVENT_LOST_ACUS, unit_stats[&#34;cdr&#34;].get(&#34;lost&#34;, 0), events_queue)
        self._record_event(EVENT_BUILT_TECH_1_UNITS, unit_stats[&#34;tech1&#34;].get(&#34;built&#34;, 0), events_queue)
        self._record_event(EVENT_LOST_TECH_1_UNITS, unit_stats[&#34;tech1&#34;].get(&#34;lost&#34;, 0), events_queue)
        self._record_event(EVENT_BUILT_TECH_2_UNITS, unit_stats[&#34;tech2&#34;].get(&#34;built&#34;, 0), events_queue)
        self._record_event(EVENT_LOST_TECH_2_UNITS, unit_stats[&#34;tech2&#34;].get(&#34;lost&#34;, 0), events_queue)
        self._record_event(EVENT_BUILT_TECH_3_UNITS, unit_stats[&#34;tech3&#34;].get(&#34;built&#34;, 0), events_queue)
        self._record_event(EVENT_LOST_TECH_3_UNITS, unit_stats[&#34;tech3&#34;].get(&#34;lost&#34;, 0), events_queue)
        self._record_event(EVENT_BUILT_EXPERIMENTALS, built_experimentals, events_queue)
        self._record_event(EVENT_LOST_EXPERIMENTALS, unit_stats[&#34;experimental&#34;].get(&#34;lost&#34;, 0), events_queue)
        self._record_event(EVENT_BUILT_ENGINEERS, unit_stats[&#34;engineer&#34;].get(&#34;built&#34;, 0), events_queue)
        self._record_event(EVENT_LOST_ENGINEERS, unit_stats[&#34;engineer&#34;].get(&#34;lost&#34;, 0), events_queue)

        if survived:
            if built_air &gt; built_land and built_air &gt; built_naval:
                self._increment(ACH_WRIGHT_BROTHER, 1, achievements_queue)
                self._increment(ACH_WINGMAN, 1, achievements_queue)
                self._increment(ACH_KING_OF_THE_SKIES, 1, achievements_queue)
            elif built_land &gt; built_air and built_land &gt; built_naval:
                self._increment(ACH_MILITIAMAN, 1, achievements_queue)
                self._increment(ACH_GRENADIER, 1, achievements_queue)
                self._increment(ACH_FIELD_MARSHAL, 1, achievements_queue)
            elif built_naval &gt; built_land and built_naval &gt; built_air:
                self._increment(ACH_LANDLUBBER, 1, achievements_queue)
                self._increment(ACH_SEAMAN, 1, achievements_queue)
                self._increment(ACH_ADMIRAL_OF_THE_FLEET, 1, achievements_queue)

            if built_experimentals &gt; 0:
                self._increment(ACH_DR_EVIL, built_experimentals, achievements_queue)

                if built_experimentals &gt;= 3:
                    self._increment(ACH_TECHIE, 1, achievements_queue)
                    self._increment(ACH_I_LOVE_BIG_TOYS, 1, achievements_queue)
                    self._increment(ACH_EXPERIMENTALIST, 1, achievements_queue)

    def _faction_played(self, faction, survived, achievements_queue, events_queue):
        if faction == Faction.aeon:
            self._record_event(EVENT_AEON_PLAYS, 1, events_queue)

            if survived:
                self._record_event(EVENT_AEON_WINS, 1, events_queue)
                self._increment(ACH_AURORA, 1, achievements_queue)
                self._increment(ACH_BLAZE, 1, achievements_queue)
                self._increment(ACH_SERENITY, 1, achievements_queue)
        elif faction == Faction.cybran:
            self._record_event(EVENT_CYBRAN_PLAYS, 1, events_queue)

            if survived:
                self._record_event(EVENT_CYBRAN_WINS, 1, events_queue)
                self._increment(ACH_MANTIS, 1, achievements_queue)
                self._increment(ACH_WAGNER, 1, achievements_queue)
                self._increment(ACH_TREBUCHET, 1, achievements_queue)
        elif faction == Faction.uef:
            self._record_event(EVENT_UEF_PLAYS, 1, events_queue)

            if survived:
                self._record_event(EVENT_UEF_WINS, 1, events_queue)
                self._increment(ACH_MA12_STRIKER, 1, achievements_queue)
                self._increment(ACH_RIPTIDE, 1, achievements_queue)
                self._increment(ACH_DEMOLISHER, 1, achievements_queue)
        elif faction == Faction.seraphim:
            self._record_event(EVENT_SERAPHIM_PLAYS, 1, events_queue)

            if survived:
                self._record_event(EVENT_SERAPHIM_WINS, 1, events_queue)
                self._increment(ACH_THAAM, 1, achievements_queue)
                self._increment(ACH_YENZYNE, 1, achievements_queue)
                self._increment(ACH_SUTHANUS, 1, achievements_queue)

    def _killed_acus(self, unit_stats, survived, achievements_queue):
        killed_acus = unit_stats[&#34;cdr&#34;].get(&#34;kills&#34;, 0)

        if killed_acus &gt; 0:
            self._increment(ACH_DONT_MESS_WITH_ME, killed_acus, achievements_queue)

        if killed_acus &gt;= 3 and survived:
            self._unlock(ACH_HATTRICK, achievements_queue)

    def _built_mercies(self, count, achievements_queue):
        self._increment(ACH_NO_MERCY, count, achievements_queue)

    def _built_fire_beetles(self, count, achievements_queue):
        self._increment(ACH_DEADLY_BUGS, count, achievements_queue)

    def _built_salvations(self, count, survived, achievements_queue):
        if survived and count &gt; 0:
            self._unlock(ACH_RAINMAKER, achievements_queue)

    def _built_yolona_oss(self, count, survived, achievements_queue):
        if survived and count &gt; 0:
            self._unlock(ACH_NUCLEAR_WAR, achievements_queue)

    def _built_paragons(self, count, survived, achievements_queue):
        if survived and count &gt; 0:
            self._unlock(ACH_SO_MUCH_RESOURCES, achievements_queue)

    def _built_atlantis(self, count, achievements_queue):
        self._increment(ACH_IT_AINT_A_CITY, count, achievements_queue)

    def _built_tempests(self, count, achievements_queue):
        self._increment(ACH_STORMY_SEA, count, achievements_queue)

    def _built_scathis(self, count, survived, achievements_queue):
        if survived and count &gt; 0:
            self._unlock(ACH_MAKE_IT_HAIL, achievements_queue)

    def _built_mavors(self, count, survived, achievements_queue):
        if survived and count &gt; 0:
            self._unlock(ACH_I_HAVE_A_CANON, achievements_queue)

    def _built_czars(self, count, achievements_queue):
        self._increment(ACH_DEATH_FROM_ABOVE, count, achievements_queue)

    def _built_ahwassas(self, count, achievements_queue):
        self._increment(ACH_ASS_WASHER, count, achievements_queue)

    def _built_ythothas(self, count, achievements_queue):
        self._increment(ACH_ALIEN_INVASION, count, achievements_queue)

    def _built_fatboys(self, count, achievements_queue):
        self._increment(ACH_FATTER_IS_BETTER, count, achievements_queue)

    def _built_monkeylords(self, count, achievements_queue):
        self._increment(ACH_ARACHNOLOGIST, count, achievements_queue)

    def _built_galactic_colossus(self, count, achievements_queue):
        self._increment(ACH_INCOMING_ROBOTS, count, achievements_queue)

    def _built_soul_rippers(self, count, achievements_queue):
        self._increment(ACH_FLYING_DEATH, count, achievements_queue)

    def _built_megaliths(self, count, achievements_queue):
        self._increment(ACH_HOLY_CRAB, count, achievements_queue)

    def _built_transports(self, count, achievements_queue):
        self._increment(ACH_THE_TRANSPORTER, count, achievements_queue)

    def _built_sacus(self, count, achievements_queue):
        self._set_steps_at_least(ACH_WHO_NEEDS_SUPPORT, count, achievements_queue)

    def _built_asfs(self, count, achievements_queue):
        self._set_steps_at_least(ACH_WHAT_A_SWARM, count, achievements_queue)

    def _lowest_acu_health(self, health, survived, achievements_queue):
        if 0 &lt; health &lt; 500 and survived:
            self._unlock(ACH_THAT_WAS_CLOSE, achievements_queue)

    def _highscore(self, scored_highest, number_of_humans, achievements_queue):
        if scored_highest and number_of_humans &gt;= 8:
            self._unlock(ACH_TOP_SCORE, achievements_queue)
            self._increment(ACH_UNBEATABLE, 1, achievements_queue)

    def _unlock(self, achievement_id, achievements_queue):
        self._achievement_service.unlock(achievement_id, achievements_queue)

    def _increment(self, achievement_id, steps, achievements_queue):
        self._achievement_service.increment(achievement_id, steps, achievements_queue)

    def _set_steps_at_least(self, achievement_id, steps, achievements_queue):
        self._achievement_service.set_steps_at_least(achievement_id, steps, achievements_queue)

    def _record_event(self, event_id, count, events_queue):
        self._event_service.record_event(event_id, count, events_queue)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="server.core.service.Service" href="core/service.html#server.core.service.Service">Service</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="server.GameStatsService.process_game_stats"><code class="name flex">
<span>async def <span class="ident">process_game_stats</span></span>(<span>self, player: <a title="server.players.Player" href="players.html#server.players.Player">Player</a>, game: <a title="server.games.game.Game" href="games/game.html#server.games.game.Game">Game</a>, army_stats_list: list)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def process_game_stats(
    self,
    player: Player,
    game: Game,
    army_stats_list: list
):
    try:
        await self._process_game_stats(player, game, army_stats_list)
    except KeyError as e:
        self._logger.info(&#34;Malformed game stats. KeyError: %s&#34;, e)
    except Exception:
        self._logger.exception(
            &#34;Error processing game stats for %s in game %d&#34;,
            player.login,
            game.id
        )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="server.core.service.Service" href="core/service.html#server.core.service.Service">Service</a></b></code>:
<ul class="hlist">
<li><code><a title="server.core.service.Service.initialize" href="core/service.html#server.core.service.Service.initialize">initialize</a></code></li>
<li><code><a title="server.core.service.Service.on_connection_lost" href="core/service.html#server.core.service.Service.on_connection_lost">on_connection_lost</a></code></li>
<li><code><a title="server.core.service.Service.shutdown" href="core/service.html#server.core.service.Service.shutdown">shutdown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="server.GeoIpService"><code class="flex name class">
<span>class <span class="ident">GeoIpService</span></span>
</code></dt>
<dd>
<div class="desc"><p>Service for managing the GeoIp database. This includes an asyncio crontab
which periodically checks if the current file is out of date. If it is, then
the service will try to download a new file from tue url in <code><a title="server.config" href="config.html">server.config</a></code>.</p>
<p>Provides an interface for getting data out of the database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@with_logger
class GeoIpService(Service):
    &#34;&#34;&#34;
    Service for managing the GeoIp database. This includes an asyncio crontab
    which periodically checks if the current file is out of date. If it is, then
    the service will try to download a new file from tue url in `server.config`.

    Provides an interface for getting data out of the database.
    &#34;&#34;&#34;

    def __init__(self):
        self.refresh_file_path()
        config.register_callback(&#34;GEO_IP_DATABASE_PATH&#34;, self.refresh_file_path)

        self.db = None
        self.db_update_time = None

    def refresh_file_path(self):
        self.file_path = config.GEO_IP_DATABASE_PATH

    async def initialize(self) -&gt; None:
        self.check_geoip_db_file_updated()

        await self.check_update_geoip_db()
        # crontab: min hour day month day_of_week
        # Run every Wednesday because GeoLite2 is updated every first Tuesday
        # of the month.
        self._update_cron = aiocron.crontab(
            &#34;0 0 0 * * 3&#34;, func=self.check_update_geoip_db
        )
        self._check_file_timer = Timer(
            60 * 10, self.check_geoip_db_file_updated, start=True
        )

    def check_geoip_db_file_updated(self):
        &#34;&#34;&#34;
        Checks if the local database file has been updated by a server admin
        and loads it if it has.
        &#34;&#34;&#34;
        if not os.path.isfile(self.file_path):
            return

        if self.db is None:
            # We haven&#39;t loaded the file before
            self.load_db()
        else:
            assert self.db_update_time is not None
            # We have loaded the file, so check if it has been updated

            date_modified = datetime.fromtimestamp(
                os.path.getmtime(self.file_path)
            )
            if date_modified &gt; self.db_update_time:
                self.load_db()

    async def check_update_geoip_db(self) -&gt; None:
        &#34;&#34;&#34;
        Check if the geoip database is old and update it if so.
        &#34;&#34;&#34;
        if not config.GEO_IP_LICENSE_KEY:
            self._logger.warning(
                &#34;GEO_IP_LICENSE_KEY not set! Unable to download GeoIP database!&#34;
            )
            return

        self._logger.debug(&#34;Checking if geoip database needs updating&#34;)
        try:
            date_modified = datetime.fromtimestamp(
                os.path.getmtime(self.file_path)
            )
            delta = datetime.now() - date_modified

            if delta.days &gt; config.GEO_IP_DATABASE_MAX_AGE_DAYS:
                self._logger.info(&#34;Geoip database is out of date&#34;)
                await self.download_geoip_db()
        except FileNotFoundError:    # pragma: no cover
            self._logger.warning(&#34;Geoip database is missing...&#34;)
            await self.download_geoip_db()
        except asyncio.TimeoutError:    # pragma: no cover
            self._logger.warning(
                &#34;Failed to download database file! &#34;
                &#34;Check the network connection and try again&#34;
            )
        except Exception as e:    # pragma: no cover
            self._logger.exception(e)
            raise e

        self.load_db()

    async def download_geoip_db(self) -&gt; None:
        &#34;&#34;&#34;
        Download the geoip database to a file. If the downloaded file is not
        a valid gzip file, then it does NOT overwrite the old file.
        &#34;&#34;&#34;
        assert config.GEO_IP_LICENSE_KEY is not None

        self._logger.info(&#34;Downloading new geoip database&#34;)

        # Download new file to a temp location
        with TemporaryFile() as temp_file:
            await self._download_file(
                config.GEO_IP_DATABASE_URL,
                config.GEO_IP_LICENSE_KEY,
                temp_file
            )
            temp_file.seek(0)

            # Unzip the archive and overwrite the old file
            try:
                with tarfile.open(fileobj=temp_file, mode=&#34;r:gz&#34;) as tar:
                    with open(self.file_path, &#34;wb&#34;) as f_out:
                        f_in = extract_file(tar, &#34;GeoLite2-Country.mmdb&#34;)
                        shutil.copyfileobj(f_in, f_out)
            except (tarfile.TarError) as e:    # pragma: no cover
                self._logger.warning(&#34;Failed to extract downloaded file!&#34;)
                raise e
        self._logger.info(&#34;New database download complete&#34;)

    async def _download_file(
        self,
        url: str,
        license_key: str,
        fileobj: IO[bytes]
    ) -&gt; None:
        &#34;&#34;&#34;
        Download a file using aiohttp and save it to a file.

        # Params
        - `url`: The url to download from
        - `file_path`: Path to save the file at
        &#34;&#34;&#34;

        chunk_size = 1024
        params = {
            &#34;edition_id&#34;: &#34;GeoLite2-Country&#34;,
            &#34;license_key&#34;: license_key,
            &#34;suffix&#34;: &#34;tar.gz&#34;
        }

        async def get_checksum(session):
            async with session.get(url, params={
                **params,
                &#34;suffix&#34;: params[&#34;suffix&#34;] + &#34;.md5&#34;
            }, timeout=60 * 20) as resp:
                return await resp.text()

        async def get_db_file_with_checksum(session):
            hasher = hashlib.md5()
            async with session.get(url, params=params, timeout=60 * 20) as resp:
                while True:
                    chunk = await resp.content.read(chunk_size)
                    if not chunk:
                        break
                    fileobj.write(chunk)
                    hasher.update(chunk)

            return hasher.hexdigest()

        async with aiohttp.ClientSession(raise_for_status=True) as session:
            checksum, our_hash = await asyncio.gather(
                get_checksum(session),
                get_db_file_with_checksum(session)
            )

        if checksum != our_hash:
            raise Exception(
                f&#34;Hashes did not match! Expected {checksum} got {our_hash}&#34;
            )

    def load_db(self) -&gt; None:
        &#34;&#34;&#34;
        Loads the database into memory.
        &#34;&#34;&#34;
        # Set the time first, if the file is corrupted we don&#39;t need to try
        # loading it again anyways
        self.db_update_time = datetime.now()

        try:
            new_db = maxminddb.open_database(self.file_path)
        except (InvalidDatabaseError, OSError, ValueError):
            self._logger.exception(
                &#34;Failed to load maxmind db! Maybe the download was interrupted&#34;
            )
        else:
            if self.db is not None:
                self.db.close()

            self.db = new_db
            self._logger.info(
                &#34;File loaded successfully from %s&#34;, self.file_path
            )

    def country(self, address: str) -&gt; str:
        &#34;&#34;&#34;
        Look up an ip address in the db and return it&#39;s country code.
        &#34;&#34;&#34;
        default_value = &#34;&#34;
        if self.db is None:
            return default_value

        entry = self.db.get(address)
        if entry is None:
            return default_value

        return str(entry.get(&#34;country&#34;, {}).get(&#34;iso_code&#34;, default_value))

    async def shutdown(self):
        if self.db is not None:
            self.db.close()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="server.core.service.Service" href="core/service.html#server.core.service.Service">Service</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="server.GeoIpService.check_geoip_db_file_updated"><code class="name flex">
<span>def <span class="ident">check_geoip_db_file_updated</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the local database file has been updated by a server admin
and loads it if it has.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_geoip_db_file_updated(self):
    &#34;&#34;&#34;
    Checks if the local database file has been updated by a server admin
    and loads it if it has.
    &#34;&#34;&#34;
    if not os.path.isfile(self.file_path):
        return

    if self.db is None:
        # We haven&#39;t loaded the file before
        self.load_db()
    else:
        assert self.db_update_time is not None
        # We have loaded the file, so check if it has been updated

        date_modified = datetime.fromtimestamp(
            os.path.getmtime(self.file_path)
        )
        if date_modified &gt; self.db_update_time:
            self.load_db()</code></pre>
</details>
</dd>
<dt id="server.GeoIpService.check_update_geoip_db"><code class="name flex">
<span>async def <span class="ident">check_update_geoip_db</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the geoip database is old and update it if so.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def check_update_geoip_db(self) -&gt; None:
    &#34;&#34;&#34;
    Check if the geoip database is old and update it if so.
    &#34;&#34;&#34;
    if not config.GEO_IP_LICENSE_KEY:
        self._logger.warning(
            &#34;GEO_IP_LICENSE_KEY not set! Unable to download GeoIP database!&#34;
        )
        return

    self._logger.debug(&#34;Checking if geoip database needs updating&#34;)
    try:
        date_modified = datetime.fromtimestamp(
            os.path.getmtime(self.file_path)
        )
        delta = datetime.now() - date_modified

        if delta.days &gt; config.GEO_IP_DATABASE_MAX_AGE_DAYS:
            self._logger.info(&#34;Geoip database is out of date&#34;)
            await self.download_geoip_db()
    except FileNotFoundError:    # pragma: no cover
        self._logger.warning(&#34;Geoip database is missing...&#34;)
        await self.download_geoip_db()
    except asyncio.TimeoutError:    # pragma: no cover
        self._logger.warning(
            &#34;Failed to download database file! &#34;
            &#34;Check the network connection and try again&#34;
        )
    except Exception as e:    # pragma: no cover
        self._logger.exception(e)
        raise e

    self.load_db()</code></pre>
</details>
</dd>
<dt id="server.GeoIpService.country"><code class="name flex">
<span>def <span class="ident">country</span></span>(<span>self, address: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Look up an ip address in the db and return it's country code.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def country(self, address: str) -&gt; str:
    &#34;&#34;&#34;
    Look up an ip address in the db and return it&#39;s country code.
    &#34;&#34;&#34;
    default_value = &#34;&#34;
    if self.db is None:
        return default_value

    entry = self.db.get(address)
    if entry is None:
        return default_value

    return str(entry.get(&#34;country&#34;, {}).get(&#34;iso_code&#34;, default_value))</code></pre>
</details>
</dd>
<dt id="server.GeoIpService.download_geoip_db"><code class="name flex">
<span>async def <span class="ident">download_geoip_db</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Download the geoip database to a file. If the downloaded file is not
a valid gzip file, then it does NOT overwrite the old file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def download_geoip_db(self) -&gt; None:
    &#34;&#34;&#34;
    Download the geoip database to a file. If the downloaded file is not
    a valid gzip file, then it does NOT overwrite the old file.
    &#34;&#34;&#34;
    assert config.GEO_IP_LICENSE_KEY is not None

    self._logger.info(&#34;Downloading new geoip database&#34;)

    # Download new file to a temp location
    with TemporaryFile() as temp_file:
        await self._download_file(
            config.GEO_IP_DATABASE_URL,
            config.GEO_IP_LICENSE_KEY,
            temp_file
        )
        temp_file.seek(0)

        # Unzip the archive and overwrite the old file
        try:
            with tarfile.open(fileobj=temp_file, mode=&#34;r:gz&#34;) as tar:
                with open(self.file_path, &#34;wb&#34;) as f_out:
                    f_in = extract_file(tar, &#34;GeoLite2-Country.mmdb&#34;)
                    shutil.copyfileobj(f_in, f_out)
        except (tarfile.TarError) as e:    # pragma: no cover
            self._logger.warning(&#34;Failed to extract downloaded file!&#34;)
            raise e
    self._logger.info(&#34;New database download complete&#34;)</code></pre>
</details>
</dd>
<dt id="server.GeoIpService.load_db"><code class="name flex">
<span>def <span class="ident">load_db</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Loads the database into memory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_db(self) -&gt; None:
    &#34;&#34;&#34;
    Loads the database into memory.
    &#34;&#34;&#34;
    # Set the time first, if the file is corrupted we don&#39;t need to try
    # loading it again anyways
    self.db_update_time = datetime.now()

    try:
        new_db = maxminddb.open_database(self.file_path)
    except (InvalidDatabaseError, OSError, ValueError):
        self._logger.exception(
            &#34;Failed to load maxmind db! Maybe the download was interrupted&#34;
        )
    else:
        if self.db is not None:
            self.db.close()

        self.db = new_db
        self._logger.info(
            &#34;File loaded successfully from %s&#34;, self.file_path
        )</code></pre>
</details>
</dd>
<dt id="server.GeoIpService.refresh_file_path"><code class="name flex">
<span>def <span class="ident">refresh_file_path</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh_file_path(self):
    self.file_path = config.GEO_IP_DATABASE_PATH</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="server.core.service.Service" href="core/service.html#server.core.service.Service">Service</a></b></code>:
<ul class="hlist">
<li><code><a title="server.core.service.Service.initialize" href="core/service.html#server.core.service.Service.initialize">initialize</a></code></li>
<li><code><a title="server.core.service.Service.on_connection_lost" href="core/service.html#server.core.service.Service.on_connection_lost">on_connection_lost</a></code></li>
<li><code><a title="server.core.service.Service.shutdown" href="core/service.html#server.core.service.Service.shutdown">shutdown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="server.LadderService"><code class="flex name class">
<span>class <span class="ident">LadderService</span></span>
<span>(</span><span>database: <a title="server.db.FAFDatabase" href="db/index.html#server.db.FAFDatabase">FAFDatabase</a>, game_service: <a title="server.game_service.GameService" href="game_service.html#server.game_service.GameService">GameService</a>, violation_service: <a title="server.ladder_service.violation_service.ViolationService" href="ladder_service/violation_service.html#server.ladder_service.violation_service.ViolationService">ViolationService</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Service responsible for managing the automatches. Does matchmaking, updates
statistics, and launches the games.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@with_logger
class LadderService(Service):
    &#34;&#34;&#34;
    Service responsible for managing the automatches. Does matchmaking, updates
    statistics, and launches the games.
    &#34;&#34;&#34;

    def __init__(
        self,
        database: FAFDatabase,
        game_service: GameService,
        violation_service: ViolationService,
    ):
        self._db = database
        self._informed_players: set[Player] = set()
        self.game_service = game_service
        self.queues = {}
        self.violation_service = violation_service

        self._searches: dict[Player, dict[str, Search]] = defaultdict(dict)

    async def initialize(self) -&gt; None:
        await self.update_data()
        self._update_cron = aiocron.crontab(&#34;*/10 * * * *&#34;, func=self.update_data)

    async def update_data(self) -&gt; None:
        async with self._db.acquire() as conn:
            map_pool_maps = await self.fetch_map_pools(conn)
            db_queues = await self.fetch_matchmaker_queues(conn)

        for name, info in db_queues.items():
            if name not in self.queues:
                queue = MatchmakerQueue(
                    self.game_service,
                    self.on_match_found,
                    name=name,
                    queue_id=info[&#34;id&#34;],
                    featured_mod=info[&#34;mod&#34;],
                    rating_type=info[&#34;rating_type&#34;],
                    team_size=info[&#34;team_size&#34;],
                    params=info.get(&#34;params&#34;)
                )
                self.queues[name] = queue
                queue.initialize()
            else:
                queue = self.queues[name]
                queue.featured_mod = info[&#34;mod&#34;]
                queue.rating_type = info[&#34;rating_type&#34;]
                queue.team_size = info[&#34;team_size&#34;]
            queue.map_pools.clear()
            for map_pool_id, min_rating, max_rating in info[&#34;map_pools&#34;]:
                map_pool_name, map_list = map_pool_maps[map_pool_id]
                if not map_list:
                    self._logger.warning(
                        &#34;Map pool &#39;%s&#39; is empty! Some %s games will &#34;
                        &#34;likely fail to start!&#34;,
                        map_pool_name,
                        name
                    )
                queue.add_map_pool(
                    MapPool(map_pool_id, map_pool_name, map_list),
                    min_rating,
                    max_rating
                )
        # Remove queues that don&#39;t exist anymore
        for queue_name in list(self.queues.keys()):
            if queue_name not in db_queues:
                self.queues[queue_name].shutdown()
                del self.queues[queue_name]

    async def fetch_map_pools(self, conn) -&gt; dict[int, tuple[str, list[Map]]]:
        result = await conn.execute(
            select([
                map_pool.c.id,
                map_pool.c.name,
                map_pool_map_version.c.weight,
                map_pool_map_version.c.map_params,
                map_version.c.id.label(&#34;map_id&#34;),
                map_version.c.filename,
                t_map.c.display_name
            ]).select_from(
                map_pool.outerjoin(map_pool_map_version)
                .outerjoin(map_version)
                .outerjoin(t_map)
            )
        )
        map_pool_maps = {}
        for row in result:
            id_ = row.id
            name = row.name
            if id_ not in map_pool_maps:
                map_pool_maps[id_] = (name, list())
            _, map_list = map_pool_maps[id_]
            if row.map_id is not None:
                map_list.append(
                    Map(row.map_id, row.display_name, row.filename, row.weight)
                )
            elif row.map_params is not None:
                try:
                    params = json.loads(row.map_params)
                    map_type = params[&#34;type&#34;]
                    if map_type == &#34;neroxis&#34;:
                        map_list.append(
                            NeroxisGeneratedMap.of(params, row.weight)
                        )
                    else:
                        self._logger.warning(
                            &#34;Unsupported map type %s in pool %s&#34;,
                            map_type,
                            row.id
                        )

                except Exception:
                    self._logger.warning(
                        &#34;Failed to load map in map pool %d. &#34;
                        &#34;Parameters are &#39;%s&#39;&#34;,
                        row.id,
                        row.map_params,
                        exc_info=True
                    )

        return map_pool_maps

    async def fetch_matchmaker_queues(self, conn):
        result = await conn.execute(
            select([
                matchmaker_queue.c.id,
                matchmaker_queue.c.technical_name,
                matchmaker_queue.c.team_size,
                matchmaker_queue.c.params,
                matchmaker_queue_map_pool.c.map_pool_id,
                matchmaker_queue_map_pool.c.min_rating,
                matchmaker_queue_map_pool.c.max_rating,
                game_featuredMods.c.gamemod,
                leaderboard.c.technical_name.label(&#34;rating_type&#34;)
            ])
            .select_from(
                matchmaker_queue
                .join(matchmaker_queue_map_pool)
                .join(game_featuredMods)
                .join(leaderboard)
            ).where(matchmaker_queue.c.enabled == true())
        )
        # So we don&#39;t log the same error multiple times when a queue has several
        # map pools
        errored = set()
        matchmaker_queues = defaultdict(lambda: defaultdict(list))
        for row in result:
            name = row.technical_name
            if name in errored:
                continue
            info = matchmaker_queues[name]
            try:
                info[&#34;id&#34;] = row.id
                info[&#34;mod&#34;] = row.gamemod
                info[&#34;rating_type&#34;] = row.rating_type
                info[&#34;team_size&#34;] = row.team_size
                info[&#34;params&#34;] = json.loads(row.params) if row.params else None
                info[&#34;map_pools&#34;].append((
                    row.map_pool_id,
                    row.min_rating,
                    row.max_rating
                ))
            except Exception:
                self._logger.warning(
                    &#34;Unable to load queue &#39;%s&#39;!&#34;,
                    name,
                    exc_info=True
                )
                del matchmaker_queues[name]
                errored.add(name)
        return matchmaker_queues

    def start_search(
        self,
        players: list[Player],
        queue_name: str,
        on_matched: OnMatchedCallback = lambda _1, _2: None
    ):
        timeouts = self.violation_service.get_violations(players)
        if timeouts:
            self._logger.debug(&#34;timeouts: %s&#34;, timeouts)
            times = [
                {
                    &#34;player&#34;: p.id,
                    &#34;expires_at&#34;: violation.get_ban_expiration().isoformat()
                }
                for p, violation in timeouts.items()
            ]
            for player in players:
                player.write_message({
                    &#34;command&#34;: &#34;search_timeout&#34;,
                    &#34;timeouts&#34;: times
                })
                # TODO: Do we need this or is `search_timeout` enough?
                player.write_message({
                    &#34;command&#34;: &#34;search_info&#34;,
                    &#34;queue_name&#34;: queue_name,
                    &#34;state&#34;: &#34;stop&#34;
                })
                # For compatibility with clients that don&#39;t understand
                # `search_timeout` only. This may be removed at any time.
                if len(times) == 1:
                    s = &#34;&#34;
                    are = &#34;is&#34;
                else:
                    s = &#34;s&#34;
                    are = &#34;are&#34;
                names = &#34;, &#34;.join(p.login for p in timeouts)
                max_time = humanize.naturaldelta(
                    max(
                        timeouts.values(),
                        key=lambda v: v.get_ban_expiration()
                    ).get_remaining()
                )
                player.write_message({
                    &#34;command&#34;: &#34;notice&#34;,
                    &#34;style&#34;: &#34;info&#34;,
                    &#34;text&#34;: f&#34;Player{s} {names} {are} timed out for {max_time}&#34;
                })
            return
        # Cancel any existing searches that players have for this queue
        for player in players:
            if queue_name in self._searches[player]:
                self._cancel_search(player, queue_name)

        queue = self.queues[queue_name]
        search = Search(
            players,
            rating_type=queue.rating_type,
            on_matched=on_matched
        )

        for player in players:
            player.state = PlayerState.SEARCHING_LADDER

            self.write_rating_progress(player, queue.rating_type)

            player.write_message({
                &#34;command&#34;: &#34;search_info&#34;,
                &#34;queue_name&#34;: queue_name,
                &#34;state&#34;: &#34;start&#34;
            })

            self._searches[player][queue_name] = search

        self._logger.info(&#34;%s started searching for %s&#34;, search, queue_name)

        asyncio.create_task(queue.search(search))

    def cancel_search(
        self,
        initiator: Player,
        queue_name: Optional[str] = None
    ) -&gt; None:
        if queue_name is None:
            queue_names = list(self._searches[initiator].keys())
        else:
            queue_names = [queue_name]

        for queue_name in queue_names:
            self._cancel_search(initiator, queue_name)

    def _cancel_search(self, initiator: Player, queue_name: str) -&gt; None:
        &#34;&#34;&#34;
        Cancel search for a specific player/queue.
        &#34;&#34;&#34;
        cancelled_search = self._clear_search(initiator, queue_name)
        if cancelled_search is None:
            self._logger.debug(
                &#34;Ignoring request to cancel a search that does not exist: &#34;
                &#34;%s, %s&#34;,
                initiator,
                queue_name
            )
            return
        cancelled_search.cancel()

        for player in cancelled_search.players:
            player.write_message({
                &#34;command&#34;: &#34;search_info&#34;,
                &#34;queue_name&#34;: queue_name,
                &#34;state&#34;: &#34;stop&#34;
            })
            if (
                not self._searches[player]
                and player.state == PlayerState.SEARCHING_LADDER
            ):
                player.state = PlayerState.IDLE
        self._logger.info(
            &#34;%s stopped searching for %s&#34;, cancelled_search, queue_name
        )

    def _clear_search(
        self,
        initiator: Player,
        queue_name: str
    ) -&gt; Optional[Search]:
        &#34;&#34;&#34;
        Remove a search from the searches dictionary.

        Does NOT cancel the search.
        &#34;&#34;&#34;
        search = self._searches[initiator].get(queue_name)

        if search is not None:
            for player in search.players:
                del self._searches[player][queue_name]

        return search

    def write_rating_progress(self, player: Player, rating_type: str) -&gt; None:
        if player not in self._informed_players:
            self._informed_players.add(player)
            _, deviation = player.ratings[rating_type]

            if deviation &gt; 490:
                player.write_message({
                    &#34;command&#34;: &#34;notice&#34;,
                    &#34;style&#34;: &#34;info&#34;,
                    &#34;text&#34;: (
                        &#34;&lt;i&gt;Welcome to the matchmaker&lt;/i&gt;&lt;br&gt;&lt;br&gt;&lt;b&gt;Until &#34;
                        &#34;you&#39;ve played enough games for the system to learn &#34;
                        &#34;your skill level, you&#39;ll be matched randomly.&lt;/b&gt;&lt;br&gt;&#34;
                        &#34;Afterwards, you&#39;ll be more reliably matched up with &#34;
                        &#34;people of your skill level: so don&#39;t worry if your &#34;
                        &#34;first few games are uneven. This will improve as you &#34;
                        &#34;play!&lt;/b&gt;&#34;
                    )
                })
            elif deviation &gt; 250:
                progress = (500.0 - deviation) / 2.5
                player.write_message({
                    &#34;command&#34;: &#34;notice&#34;,
                    &#34;style&#34;: &#34;info&#34;,
                    &#34;text&#34;: (
                        &#34;The matchmaking system is calibrating your skill level; &#34;
                        &#34;your first few games may be slightly more imbalanced &#34;
                        &#34;as the system attempts to learn your capability as a player.&#34;
                        &#34;&lt;br&gt;&lt;br&gt;&#34;
                        f&#34;&lt;b&gt;The learning phase is {progress:.0f}% completed&lt;/b&gt;&#34;
                    )
                })

    def on_match_found(
        self,
        s1: Search,
        s2: Search,
        queue: MatchmakerQueue
    ) -&gt; None:
        &#34;&#34;&#34;
        Callback for when a match is generated by a matchmaker queue.

        NOTE: This function is called while the matchmaker search lock is held,
        so it should only perform fast operations.
        &#34;&#34;&#34;
        try:
            msg = {&#34;command&#34;: &#34;match_found&#34;, &#34;queue_name&#34;: queue.name}

            for player in s1.players + s2.players:
                player.state = PlayerState.STARTING_AUTOMATCH
                player.write_message(msg)

                # Cancel any other searches
                queue_names = list(
                    name for name in self._searches[player].keys()
                    if name != queue.name
                )
                for queue_name in queue_names:
                    self._cancel_search(player, queue_name)

                self._clear_search(player, queue.name)

            asyncio.create_task(self.start_game(s1.players, s2.players, queue))
        except Exception:
            self._logger.exception(
                &#34;Error processing match between searches %s, and %s&#34;,
                s1, s2
            )

    def start_game(
        self,
        team1: list[Player],
        team2: list[Player],
        queue: MatchmakerQueue
    ) -&gt; Awaitable[None]:
        # We want assertion errors to trigger when the caller attempts to
        # create the async function, not when the function starts executing.
        assert len(team1) == len(team2)

        return self._start_game(team1, team2, queue)

    async def _start_game(
        self,
        team1: list[Player],
        team2: list[Player],
        queue: MatchmakerQueue
    ) -&gt; None:
        self._logger.debug(
            &#34;Starting %s game between %s and %s&#34;,
            queue.name,
            [p.login for p in team1],
            [p.login for p in team2]
        )
        game = None
        try:
            host = team1[0]
            all_players = team1 + team2
            all_guests = all_players[1:]

            played_map_ids = await self.get_game_history(
                all_players,
                queue.id,
                limit=config.LADDER_ANTI_REPETITION_LIMIT
            )
            rating = min(
                player.ratings[queue.rating_type].displayed()
                for player in all_players
            )
            pool = queue.get_map_pool_for_rating(rating)
            if not pool:
                raise RuntimeError(f&#34;No map pool available for rating {rating}!&#34;)
            _, _, map_path, _ = pool.choose_map(played_map_ids)

            game = self.game_service.create_game(
                game_class=LadderGame,
                game_mode=queue.featured_mod,
                host=host,
                name=&#34;Matchmaker Game&#34;,
                matchmaker_queue_id=queue.id,
                rating_type=queue.rating_type,
                max_players=len(all_players)
            )
            game.init_mode = InitMode.AUTO_LOBBY
            game.map_file_path = map_path
            game.set_name_unchecked(game_name(team1, team2))

            def get_player_mean(player: Player) -&gt; float:
                return player.ratings[queue.rating_type].mean

            team1 = sorted(team1, key=get_player_mean)
            team2 = sorted(team2, key=get_player_mean)

            # Shuffle the teams such that direct opponents remain the same
            zipped_teams = list(zip(team1, team2))
            random.shuffle(zipped_teams)

            for i, player in enumerate(
                player for pair in zipped_teams for player in pair
            ):
                # FA uses lua and lua arrays are 1-indexed
                slot = i + 1
                # 2 if even, 3 if odd
                team = (i % 2) + 2
                player.game = game

                # Set player options without triggering the logic for
                # determining that players have actually connected to the game.
                game._player_options[player.id][&#34;Faction&#34;] = player.faction.value
                game._player_options[player.id][&#34;Team&#34;] = team
                game._player_options[player.id][&#34;StartSpot&#34;] = slot
                game._player_options[player.id][&#34;Army&#34;] = slot
                game._player_options[player.id][&#34;Color&#34;] = slot

            game_options = queue.get_game_options()
            if game_options:
                game.gameOptions.update(game_options)

            mapname = re.match(&#34;maps/(.+).zip&#34;, map_path).group(1)
            # FIXME: Database filenames contain the maps/ prefix and .zip suffix.
            # Really in the future, just send a better description

            self._logger.debug(&#34;Starting ladder game: %s&#34;, game)

            def make_game_options(player: Player) -&gt; GameLaunchOptions:
                return GameLaunchOptions(
                    mapname=mapname,
                    expected_players=len(all_players),
                    game_options=game_options,
                    team=game.get_player_option(player.id, &#34;Team&#34;),
                    faction=game.get_player_option(player.id, &#34;Faction&#34;),
                    map_position=game.get_player_option(player.id, &#34;StartSpot&#34;)
                )

            await self.launch_match(game, host, all_guests, make_game_options)
            self._logger.debug(&#34;Ladder game launched successfully %s&#34;, game)
            metrics.matches.labels(queue.name, MatchLaunch.SUCCESSFUL).inc()
        except Exception as e:
            abandoning_players = []
            if isinstance(e, NotConnectedError):
                self._logger.info(
                    &#34;Ladder game failed to start! %s setup timed out&#34;,
                    game
                )
                metrics.matches.labels(queue.name, MatchLaunch.TIMED_OUT).inc()
                abandoning_players = e.players
            elif isinstance(e, GameClosedError):
                self._logger.info(
                    &#34;Ladder game %s failed to start! &#34;
                    &#34;Player %s closed their game instance&#34;,
                    game, e.player
                )
                metrics.matches.labels(queue.name, MatchLaunch.ABORTED_BY_PLAYER).inc()
                abandoning_players = [e.player]
            else:
                # All timeout errors should be transformed by the match starter.
                assert not isinstance(e, asyncio.TimeoutError)

                self._logger.exception(&#34;Ladder game failed to start %s&#34;, game)
                metrics.matches.labels(queue.name, MatchLaunch.ERRORED).inc()

            if game:
                await game.on_game_finish()

            game_id = game.id if game else None
            msg = {&#34;command&#34;: &#34;match_cancelled&#34;, &#34;game_id&#34;: game_id}
            for player in all_players:
                if player.state == PlayerState.STARTING_AUTOMATCH:
                    player.state = PlayerState.IDLE
                player.write_message(msg)

            if abandoning_players:
                self._logger.info(
                    &#34;Players failed to connect: %s&#34;,
                    abandoning_players
                )
                self.violation_service.register_violations(abandoning_players)

    async def launch_match(
        self,
        game: LadderGame,
        host: Player,
        guests: list[Player],
        make_game_options: Callable[[Player], GameLaunchOptions]
    ):
        # Launch the host
        if host.lobby_connection is None:
            raise NotConnectedError([host])

        host.lobby_connection.write_launch_game(
            game,
            is_host=True,
            options=make_game_options(host)
        )

        try:
            await game.wait_hosted(60)
        except asyncio.TimeoutError:
            raise NotConnectedError([host])
        finally:
            # TODO: Once the client supports `match_cancelled`, don&#39;t
            # send `launch_game` to the client if the host timed out. Until
            # then, failing to send `launch_game` will cause the client to
            # think it is searching for ladder, even though the server has
            # already removed it from the queue.

            # Launch the guests
            not_connected_guests = [
                player for player in guests
                if player.lobby_connection is None
            ]
            if not_connected_guests:
                raise NotConnectedError(not_connected_guests)

            for guest in guests:
                assert guest.lobby_connection is not None

                guest.lobby_connection.write_launch_game(
                    game,
                    is_host=False,
                    options=make_game_options(guest)
                )
        try:
            await game.wait_launched(60 + 10 * len(guests))
        except asyncio.TimeoutError:
            connected_players = game.get_connected_players()
            raise NotConnectedError([
                player for player in guests
                if player not in connected_players
            ])

    async def get_game_history(
        self,
        players: list[Player],
        queue_id: int,
        limit: int = 3
    ) -&gt; list[int]:
        async with self._db.acquire() as conn:
            result = []
            for player in players:
                query = select([
                    game_stats.c.mapId,
                ]).select_from(
                    game_player_stats
                    .join(game_stats)
                    .join(matchmaker_queue_game)
                ).where(
                    and_(
                        game_player_stats.c.playerId == player.id,
                        game_stats.c.startTime &gt;= func.DATE_SUB(
                            func.now(),
                            text(&#34;interval 1 day&#34;)
                        ),
                        matchmaker_queue_game.c.matchmaker_queue_id == queue_id
                    )
                ).order_by(
                    game_stats.c.startTime.desc(),
                    # Timestamps only have second resolution, so for this to
                    # work correctly in the unit tests we also need id
                    game_stats.c.id.desc()
                ).limit(limit)

                result.extend([
                    row.mapId for row in await conn.execute(query)
                ])
        return result

    def on_connection_lost(self, conn: &#34;LobbyConnection&#34;) -&gt; None:
        if not conn.player:
            return

        player = conn.player
        self.cancel_search(player)
        del self._searches[player]
        if player in self._informed_players:
            self._informed_players.remove(player)

    async def shutdown(self):
        for queue in self.queues.values():
            queue.shutdown()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="server.core.service.Service" href="core/service.html#server.core.service.Service">Service</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="server.LadderService.cancel_search"><code class="name flex">
<span>def <span class="ident">cancel_search</span></span>(<span>self, initiator: <a title="server.players.Player" href="players.html#server.players.Player">Player</a>, queue_name: Optional[str] = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cancel_search(
    self,
    initiator: Player,
    queue_name: Optional[str] = None
) -&gt; None:
    if queue_name is None:
        queue_names = list(self._searches[initiator].keys())
    else:
        queue_names = [queue_name]

    for queue_name in queue_names:
        self._cancel_search(initiator, queue_name)</code></pre>
</details>
</dd>
<dt id="server.LadderService.fetch_map_pools"><code class="name flex">
<span>async def <span class="ident">fetch_map_pools</span></span>(<span>self, conn) ‑> dict[int, tuple[str, list[<a title="server.types.Map" href="types.html#server.types.Map">Map</a>]]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def fetch_map_pools(self, conn) -&gt; dict[int, tuple[str, list[Map]]]:
    result = await conn.execute(
        select([
            map_pool.c.id,
            map_pool.c.name,
            map_pool_map_version.c.weight,
            map_pool_map_version.c.map_params,
            map_version.c.id.label(&#34;map_id&#34;),
            map_version.c.filename,
            t_map.c.display_name
        ]).select_from(
            map_pool.outerjoin(map_pool_map_version)
            .outerjoin(map_version)
            .outerjoin(t_map)
        )
    )
    map_pool_maps = {}
    for row in result:
        id_ = row.id
        name = row.name
        if id_ not in map_pool_maps:
            map_pool_maps[id_] = (name, list())
        _, map_list = map_pool_maps[id_]
        if row.map_id is not None:
            map_list.append(
                Map(row.map_id, row.display_name, row.filename, row.weight)
            )
        elif row.map_params is not None:
            try:
                params = json.loads(row.map_params)
                map_type = params[&#34;type&#34;]
                if map_type == &#34;neroxis&#34;:
                    map_list.append(
                        NeroxisGeneratedMap.of(params, row.weight)
                    )
                else:
                    self._logger.warning(
                        &#34;Unsupported map type %s in pool %s&#34;,
                        map_type,
                        row.id
                    )

            except Exception:
                self._logger.warning(
                    &#34;Failed to load map in map pool %d. &#34;
                    &#34;Parameters are &#39;%s&#39;&#34;,
                    row.id,
                    row.map_params,
                    exc_info=True
                )

    return map_pool_maps</code></pre>
</details>
</dd>
<dt id="server.LadderService.fetch_matchmaker_queues"><code class="name flex">
<span>async def <span class="ident">fetch_matchmaker_queues</span></span>(<span>self, conn)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def fetch_matchmaker_queues(self, conn):
    result = await conn.execute(
        select([
            matchmaker_queue.c.id,
            matchmaker_queue.c.technical_name,
            matchmaker_queue.c.team_size,
            matchmaker_queue.c.params,
            matchmaker_queue_map_pool.c.map_pool_id,
            matchmaker_queue_map_pool.c.min_rating,
            matchmaker_queue_map_pool.c.max_rating,
            game_featuredMods.c.gamemod,
            leaderboard.c.technical_name.label(&#34;rating_type&#34;)
        ])
        .select_from(
            matchmaker_queue
            .join(matchmaker_queue_map_pool)
            .join(game_featuredMods)
            .join(leaderboard)
        ).where(matchmaker_queue.c.enabled == true())
    )
    # So we don&#39;t log the same error multiple times when a queue has several
    # map pools
    errored = set()
    matchmaker_queues = defaultdict(lambda: defaultdict(list))
    for row in result:
        name = row.technical_name
        if name in errored:
            continue
        info = matchmaker_queues[name]
        try:
            info[&#34;id&#34;] = row.id
            info[&#34;mod&#34;] = row.gamemod
            info[&#34;rating_type&#34;] = row.rating_type
            info[&#34;team_size&#34;] = row.team_size
            info[&#34;params&#34;] = json.loads(row.params) if row.params else None
            info[&#34;map_pools&#34;].append((
                row.map_pool_id,
                row.min_rating,
                row.max_rating
            ))
        except Exception:
            self._logger.warning(
                &#34;Unable to load queue &#39;%s&#39;!&#34;,
                name,
                exc_info=True
            )
            del matchmaker_queues[name]
            errored.add(name)
    return matchmaker_queues</code></pre>
</details>
</dd>
<dt id="server.LadderService.get_game_history"><code class="name flex">
<span>async def <span class="ident">get_game_history</span></span>(<span>self, players: list[<a title="server.players.Player" href="players.html#server.players.Player">Player</a>], queue_id: int, limit: int = 3) ‑> list[int]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_game_history(
    self,
    players: list[Player],
    queue_id: int,
    limit: int = 3
) -&gt; list[int]:
    async with self._db.acquire() as conn:
        result = []
        for player in players:
            query = select([
                game_stats.c.mapId,
            ]).select_from(
                game_player_stats
                .join(game_stats)
                .join(matchmaker_queue_game)
            ).where(
                and_(
                    game_player_stats.c.playerId == player.id,
                    game_stats.c.startTime &gt;= func.DATE_SUB(
                        func.now(),
                        text(&#34;interval 1 day&#34;)
                    ),
                    matchmaker_queue_game.c.matchmaker_queue_id == queue_id
                )
            ).order_by(
                game_stats.c.startTime.desc(),
                # Timestamps only have second resolution, so for this to
                # work correctly in the unit tests we also need id
                game_stats.c.id.desc()
            ).limit(limit)

            result.extend([
                row.mapId for row in await conn.execute(query)
            ])
    return result</code></pre>
</details>
</dd>
<dt id="server.LadderService.launch_match"><code class="name flex">
<span>async def <span class="ident">launch_match</span></span>(<span>self, game: <a title="server.games.ladder_game.LadderGame" href="games/ladder_game.html#server.games.ladder_game.LadderGame">LadderGame</a>, host: <a title="server.players.Player" href="players.html#server.players.Player">Player</a>, guests: list[<a title="server.players.Player" href="players.html#server.players.Player">Player</a>], make_game_options: Callable[[<a title="server.players.Player" href="players.html#server.players.Player">Player</a>], <a title="server.types.GameLaunchOptions" href="types.html#server.types.GameLaunchOptions">GameLaunchOptions</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def launch_match(
    self,
    game: LadderGame,
    host: Player,
    guests: list[Player],
    make_game_options: Callable[[Player], GameLaunchOptions]
):
    # Launch the host
    if host.lobby_connection is None:
        raise NotConnectedError([host])

    host.lobby_connection.write_launch_game(
        game,
        is_host=True,
        options=make_game_options(host)
    )

    try:
        await game.wait_hosted(60)
    except asyncio.TimeoutError:
        raise NotConnectedError([host])
    finally:
        # TODO: Once the client supports `match_cancelled`, don&#39;t
        # send `launch_game` to the client if the host timed out. Until
        # then, failing to send `launch_game` will cause the client to
        # think it is searching for ladder, even though the server has
        # already removed it from the queue.

        # Launch the guests
        not_connected_guests = [
            player for player in guests
            if player.lobby_connection is None
        ]
        if not_connected_guests:
            raise NotConnectedError(not_connected_guests)

        for guest in guests:
            assert guest.lobby_connection is not None

            guest.lobby_connection.write_launch_game(
                game,
                is_host=False,
                options=make_game_options(guest)
            )
    try:
        await game.wait_launched(60 + 10 * len(guests))
    except asyncio.TimeoutError:
        connected_players = game.get_connected_players()
        raise NotConnectedError([
            player for player in guests
            if player not in connected_players
        ])</code></pre>
</details>
</dd>
<dt id="server.LadderService.on_match_found"><code class="name flex">
<span>def <span class="ident">on_match_found</span></span>(<span>self, s1: <a title="server.matchmaker.search.Search" href="matchmaker/search.html#server.matchmaker.search.Search">Search</a>, s2: <a title="server.matchmaker.search.Search" href="matchmaker/search.html#server.matchmaker.search.Search">Search</a>, queue: <a title="server.matchmaker.matchmaker_queue.MatchmakerQueue" href="matchmaker/matchmaker_queue.html#server.matchmaker.matchmaker_queue.MatchmakerQueue">MatchmakerQueue</a>) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Callback for when a match is generated by a matchmaker queue.</p>
<p>NOTE: This function is called while the matchmaker search lock is held,
so it should only perform fast operations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_match_found(
    self,
    s1: Search,
    s2: Search,
    queue: MatchmakerQueue
) -&gt; None:
    &#34;&#34;&#34;
    Callback for when a match is generated by a matchmaker queue.

    NOTE: This function is called while the matchmaker search lock is held,
    so it should only perform fast operations.
    &#34;&#34;&#34;
    try:
        msg = {&#34;command&#34;: &#34;match_found&#34;, &#34;queue_name&#34;: queue.name}

        for player in s1.players + s2.players:
            player.state = PlayerState.STARTING_AUTOMATCH
            player.write_message(msg)

            # Cancel any other searches
            queue_names = list(
                name for name in self._searches[player].keys()
                if name != queue.name
            )
            for queue_name in queue_names:
                self._cancel_search(player, queue_name)

            self._clear_search(player, queue.name)

        asyncio.create_task(self.start_game(s1.players, s2.players, queue))
    except Exception:
        self._logger.exception(
            &#34;Error processing match between searches %s, and %s&#34;,
            s1, s2
        )</code></pre>
</details>
</dd>
<dt id="server.LadderService.start_game"><code class="name flex">
<span>def <span class="ident">start_game</span></span>(<span>self, team1: list[<a title="server.players.Player" href="players.html#server.players.Player">Player</a>], team2: list[<a title="server.players.Player" href="players.html#server.players.Player">Player</a>], queue: <a title="server.matchmaker.matchmaker_queue.MatchmakerQueue" href="matchmaker/matchmaker_queue.html#server.matchmaker.matchmaker_queue.MatchmakerQueue">MatchmakerQueue</a>) ‑> Awaitable[None]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_game(
    self,
    team1: list[Player],
    team2: list[Player],
    queue: MatchmakerQueue
) -&gt; Awaitable[None]:
    # We want assertion errors to trigger when the caller attempts to
    # create the async function, not when the function starts executing.
    assert len(team1) == len(team2)

    return self._start_game(team1, team2, queue)</code></pre>
</details>
</dd>
<dt id="server.LadderService.start_search"><code class="name flex">
<span>def <span class="ident">start_search</span></span>(<span>self, players: list[<a title="server.players.Player" href="players.html#server.players.Player">Player</a>], queue_name: str, on_matched: Callable[[ForwardRef('Search'), ForwardRef('Search')], Any] = &lt;function LadderService.&lt;lambda&gt;&gt;)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_search(
    self,
    players: list[Player],
    queue_name: str,
    on_matched: OnMatchedCallback = lambda _1, _2: None
):
    timeouts = self.violation_service.get_violations(players)
    if timeouts:
        self._logger.debug(&#34;timeouts: %s&#34;, timeouts)
        times = [
            {
                &#34;player&#34;: p.id,
                &#34;expires_at&#34;: violation.get_ban_expiration().isoformat()
            }
            for p, violation in timeouts.items()
        ]
        for player in players:
            player.write_message({
                &#34;command&#34;: &#34;search_timeout&#34;,
                &#34;timeouts&#34;: times
            })
            # TODO: Do we need this or is `search_timeout` enough?
            player.write_message({
                &#34;command&#34;: &#34;search_info&#34;,
                &#34;queue_name&#34;: queue_name,
                &#34;state&#34;: &#34;stop&#34;
            })
            # For compatibility with clients that don&#39;t understand
            # `search_timeout` only. This may be removed at any time.
            if len(times) == 1:
                s = &#34;&#34;
                are = &#34;is&#34;
            else:
                s = &#34;s&#34;
                are = &#34;are&#34;
            names = &#34;, &#34;.join(p.login for p in timeouts)
            max_time = humanize.naturaldelta(
                max(
                    timeouts.values(),
                    key=lambda v: v.get_ban_expiration()
                ).get_remaining()
            )
            player.write_message({
                &#34;command&#34;: &#34;notice&#34;,
                &#34;style&#34;: &#34;info&#34;,
                &#34;text&#34;: f&#34;Player{s} {names} {are} timed out for {max_time}&#34;
            })
        return
    # Cancel any existing searches that players have for this queue
    for player in players:
        if queue_name in self._searches[player]:
            self._cancel_search(player, queue_name)

    queue = self.queues[queue_name]
    search = Search(
        players,
        rating_type=queue.rating_type,
        on_matched=on_matched
    )

    for player in players:
        player.state = PlayerState.SEARCHING_LADDER

        self.write_rating_progress(player, queue.rating_type)

        player.write_message({
            &#34;command&#34;: &#34;search_info&#34;,
            &#34;queue_name&#34;: queue_name,
            &#34;state&#34;: &#34;start&#34;
        })

        self._searches[player][queue_name] = search

    self._logger.info(&#34;%s started searching for %s&#34;, search, queue_name)

    asyncio.create_task(queue.search(search))</code></pre>
</details>
</dd>
<dt id="server.LadderService.update_data"><code class="name flex">
<span>async def <span class="ident">update_data</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def update_data(self) -&gt; None:
    async with self._db.acquire() as conn:
        map_pool_maps = await self.fetch_map_pools(conn)
        db_queues = await self.fetch_matchmaker_queues(conn)

    for name, info in db_queues.items():
        if name not in self.queues:
            queue = MatchmakerQueue(
                self.game_service,
                self.on_match_found,
                name=name,
                queue_id=info[&#34;id&#34;],
                featured_mod=info[&#34;mod&#34;],
                rating_type=info[&#34;rating_type&#34;],
                team_size=info[&#34;team_size&#34;],
                params=info.get(&#34;params&#34;)
            )
            self.queues[name] = queue
            queue.initialize()
        else:
            queue = self.queues[name]
            queue.featured_mod = info[&#34;mod&#34;]
            queue.rating_type = info[&#34;rating_type&#34;]
            queue.team_size = info[&#34;team_size&#34;]
        queue.map_pools.clear()
        for map_pool_id, min_rating, max_rating in info[&#34;map_pools&#34;]:
            map_pool_name, map_list = map_pool_maps[map_pool_id]
            if not map_list:
                self._logger.warning(
                    &#34;Map pool &#39;%s&#39; is empty! Some %s games will &#34;
                    &#34;likely fail to start!&#34;,
                    map_pool_name,
                    name
                )
            queue.add_map_pool(
                MapPool(map_pool_id, map_pool_name, map_list),
                min_rating,
                max_rating
            )
    # Remove queues that don&#39;t exist anymore
    for queue_name in list(self.queues.keys()):
        if queue_name not in db_queues:
            self.queues[queue_name].shutdown()
            del self.queues[queue_name]</code></pre>
</details>
</dd>
<dt id="server.LadderService.write_rating_progress"><code class="name flex">
<span>def <span class="ident">write_rating_progress</span></span>(<span>self, player: <a title="server.players.Player" href="players.html#server.players.Player">Player</a>, rating_type: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_rating_progress(self, player: Player, rating_type: str) -&gt; None:
    if player not in self._informed_players:
        self._informed_players.add(player)
        _, deviation = player.ratings[rating_type]

        if deviation &gt; 490:
            player.write_message({
                &#34;command&#34;: &#34;notice&#34;,
                &#34;style&#34;: &#34;info&#34;,
                &#34;text&#34;: (
                    &#34;&lt;i&gt;Welcome to the matchmaker&lt;/i&gt;&lt;br&gt;&lt;br&gt;&lt;b&gt;Until &#34;
                    &#34;you&#39;ve played enough games for the system to learn &#34;
                    &#34;your skill level, you&#39;ll be matched randomly.&lt;/b&gt;&lt;br&gt;&#34;
                    &#34;Afterwards, you&#39;ll be more reliably matched up with &#34;
                    &#34;people of your skill level: so don&#39;t worry if your &#34;
                    &#34;first few games are uneven. This will improve as you &#34;
                    &#34;play!&lt;/b&gt;&#34;
                )
            })
        elif deviation &gt; 250:
            progress = (500.0 - deviation) / 2.5
            player.write_message({
                &#34;command&#34;: &#34;notice&#34;,
                &#34;style&#34;: &#34;info&#34;,
                &#34;text&#34;: (
                    &#34;The matchmaking system is calibrating your skill level; &#34;
                    &#34;your first few games may be slightly more imbalanced &#34;
                    &#34;as the system attempts to learn your capability as a player.&#34;
                    &#34;&lt;br&gt;&lt;br&gt;&#34;
                    f&#34;&lt;b&gt;The learning phase is {progress:.0f}% completed&lt;/b&gt;&#34;
                )
            })</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="server.core.service.Service" href="core/service.html#server.core.service.Service">Service</a></b></code>:
<ul class="hlist">
<li><code><a title="server.core.service.Service.initialize" href="core/service.html#server.core.service.Service.initialize">initialize</a></code></li>
<li><code><a title="server.core.service.Service.on_connection_lost" href="core/service.html#server.core.service.Service.on_connection_lost">on_connection_lost</a></code></li>
<li><code><a title="server.core.service.Service.shutdown" href="core/service.html#server.core.service.Service.shutdown">shutdown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="server.MessageQueueService"><code class="flex name class">
<span>class <span class="ident">MessageQueueService</span></span>
</code></dt>
<dd>
<div class="desc"><p>Service handling connection to the message queue
and providing an interface to publish messages.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@with_logger
class MessageQueueService(Service):
    &#34;&#34;&#34;
    Service handling connection to the message queue
    and providing an interface to publish messages.
    &#34;&#34;&#34;

    def __init__(self) -&gt; None:
        self._connection = None
        self._channel = None
        self._exchanges = {}
        self._exchange_types = {}
        self._is_ready = False

        config.register_callback(&#34;MQ_USER&#34;, self.reconnect)
        config.register_callback(&#34;MQ_PASSWORD&#34;, self.reconnect)
        config.register_callback(&#34;MQ_VHOST&#34;, self.reconnect)
        config.register_callback(&#34;MQ_SERVER&#34;, self.reconnect)
        config.register_callback(&#34;MQ_PORT&#34;, self.reconnect)

    @synchronizedmethod(&#34;initialization_lock&#34;)
    async def initialize(self) -&gt; None:
        if self._is_ready:
            return

        try:
            await self._connect()
        except ConnectionAttemptFailed:
            return
        self._is_ready = True

        await self._declare_exchange(config.MQ_EXCHANGE_NAME, ExchangeType.TOPIC)

    async def _connect(self) -&gt; None:
        try:
            self._connection = await aio_pika.connect_robust(
                &#34;amqp://{user}:{password}@{server}:{port}/{vhost}&#34;.format(
                    user=config.MQ_USER,
                    password=config.MQ_PASSWORD,
                    vhost=config.MQ_VHOST,
                    server=config.MQ_SERVER,
                    port=config.MQ_PORT,
                ),
                loop=asyncio.get_running_loop(),
            )
        except ConnectionError as e:
            self._logger.warning(
                &#34;Unable to connect to RabbitMQ. Is it running?&#34;, exc_info=True
            )
            raise ConnectionAttemptFailed from e
        except ProbableAuthenticationError as e:
            self._logger.warning(
                &#34;Unable to connect to RabbitMQ. Incorrect credentials?&#34;, exc_info=True
            )
            raise ConnectionAttemptFailed from e
        except Exception as e:
            self._logger.warning(
                &#34;Unable to connect to RabbitMQ due to unhandled excpetion %s. Incorrect vhost?&#34;,
                e,
                exc_info=True,
            )
            raise ConnectionAttemptFailed from e

        self._channel = await self._connection.channel(publisher_confirms=False)
        self._logger.debug(&#34;Connected to RabbitMQ %r&#34;, self._connection)

    async def declare_exchange(
        self, exchange_name: str, exchange_type: ExchangeType = ExchangeType.TOPIC, durable: bool = True
    ) -&gt; None:
        await self.initialize()
        if not self._is_ready:
            self._logger.warning(
                &#34;Not connected to RabbitMQ, unable to declare exchange.&#34;
            )
            return

        await self._declare_exchange(exchange_name, exchange_type, durable)

    async def _declare_exchange(
        self, exchange_name: str, exchange_type: ExchangeType, durable: bool = True
    ) -&gt; None:
        new_exchange = await self._channel.declare_exchange(
            exchange_name, exchange_type, durable
        )

        self._exchanges[exchange_name] = new_exchange
        self._exchange_types[exchange_name] = exchange_type

    @synchronizedmethod(&#34;initialization_lock&#34;)
    async def shutdown(self) -&gt; None:
        self._is_ready = False
        await self._shutdown()

    async def _shutdown(self) -&gt; None:
        if self._channel is not None:
            await self._channel.close()
            self._channel = None

        if self._connection is not None:
            await self._connection.close()
            self._connection = None

    async def publish(
        self,
        exchange_name: str,
        routing: str,
        payload: dict,
        mandatory: bool = False,
        delivery_mode: DeliveryMode = DeliveryMode.PERSISTENT,
    ) -&gt; None:
        if not self._is_ready:
            self._logger.warning(
                &#34;Not connected to RabbitMQ, unable to publish message.&#34;
            )
            return

        exchange = self._exchanges.get(exchange_name)
        if exchange is None:
            raise KeyError(f&#34;Unknown exchange {exchange_name}.&#34;)

        message = aio_pika.Message(
            json.dumps(payload).encode(), delivery_mode=delivery_mode
        )

        async with self._channel.transaction():
            await exchange.publish(
                message,
                routing_key=routing,
                mandatory=mandatory
            )
            self._logger.log(
                TRACE, &#34;Published message %s to %s/%s&#34;, payload, exchange_name, routing
            )

    @synchronizedmethod(&#34;initialization_lock&#34;)
    async def reconnect(self) -&gt; None:
        self._is_ready = False
        await self._shutdown()

        try:
            await self._connect()
        except ConnectionAttemptFailed:
            return

        for exchange_name in list(self._exchanges.keys()):
            await self._declare_exchange(
                exchange_name, self._exchange_types[exchange_name]
            )
        self._is_ready = True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="server.core.service.Service" href="core/service.html#server.core.service.Service">Service</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="server.MessageQueueService.declare_exchange"><code class="name flex">
<span>async def <span class="ident">declare_exchange</span></span>(<span>self, exchange_name: str, exchange_type: aio_pika.abc.ExchangeType = ExchangeType.TOPIC, durable: bool = True) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def declare_exchange(
    self, exchange_name: str, exchange_type: ExchangeType = ExchangeType.TOPIC, durable: bool = True
) -&gt; None:
    await self.initialize()
    if not self._is_ready:
        self._logger.warning(
            &#34;Not connected to RabbitMQ, unable to declare exchange.&#34;
        )
        return

    await self._declare_exchange(exchange_name, exchange_type, durable)</code></pre>
</details>
</dd>
<dt id="server.MessageQueueService.publish"><code class="name flex">
<span>async def <span class="ident">publish</span></span>(<span>self, exchange_name: str, routing: str, payload: dict, mandatory: bool = False, delivery_mode: aio_pika.abc.DeliveryMode = DeliveryMode.PERSISTENT) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def publish(
    self,
    exchange_name: str,
    routing: str,
    payload: dict,
    mandatory: bool = False,
    delivery_mode: DeliveryMode = DeliveryMode.PERSISTENT,
) -&gt; None:
    if not self._is_ready:
        self._logger.warning(
            &#34;Not connected to RabbitMQ, unable to publish message.&#34;
        )
        return

    exchange = self._exchanges.get(exchange_name)
    if exchange is None:
        raise KeyError(f&#34;Unknown exchange {exchange_name}.&#34;)

    message = aio_pika.Message(
        json.dumps(payload).encode(), delivery_mode=delivery_mode
    )

    async with self._channel.transaction():
        await exchange.publish(
            message,
            routing_key=routing,
            mandatory=mandatory
        )
        self._logger.log(
            TRACE, &#34;Published message %s to %s/%s&#34;, payload, exchange_name, routing
        )</code></pre>
</details>
</dd>
<dt id="server.MessageQueueService.reconnect"><code class="name flex">
<span>async def <span class="ident">reconnect</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@synchronizedmethod(&#34;initialization_lock&#34;)
async def reconnect(self) -&gt; None:
    self._is_ready = False
    await self._shutdown()

    try:
        await self._connect()
    except ConnectionAttemptFailed:
        return

    for exchange_name in list(self._exchanges.keys()):
        await self._declare_exchange(
            exchange_name, self._exchange_types[exchange_name]
        )
    self._is_ready = True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="server.core.service.Service" href="core/service.html#server.core.service.Service">Service</a></b></code>:
<ul class="hlist">
<li><code><a title="server.core.service.Service.initialize" href="core/service.html#server.core.service.Service.initialize">initialize</a></code></li>
<li><code><a title="server.core.service.Service.on_connection_lost" href="core/service.html#server.core.service.Service.on_connection_lost">on_connection_lost</a></code></li>
<li><code><a title="server.core.service.Service.shutdown" href="core/service.html#server.core.service.Service.shutdown">shutdown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="server.OAuthService"><code class="flex name class">
<span>class <span class="ident">OAuthService</span></span>
</code></dt>
<dd>
<div class="desc"><p>Service for managing the OAuth token logins and verification.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@with_logger
class OAuthService(Service, name=&#34;oauth_service&#34;):
    &#34;&#34;&#34;
    Service for managing the OAuth token logins and verification.
    &#34;&#34;&#34;

    def __init__(self):
        self.public_keys = {}
        self._last_key_fetch_time = None

    async def initialize(self) -&gt; None:
        await self.retrieve_public_keys()
        # crontab: min hour day month day_of_week
        # Run every 10 minutes to update public keys.
        self._update_cron = aiocron.crontab(
            &#34;*/10 * * * *&#34;, func=self.retrieve_public_keys
        )

    @synchronizedmethod
    async def get_public_keys(self) -&gt; dict:
        &#34;&#34;&#34;
        Return cached keys, or fetch them if they&#39;re missing
        &#34;&#34;&#34;
        if not self.public_keys:
            # Rate limit requests so we don&#39;t spam the endpoint when it&#39;s down
            if (
                not self._last_key_fetch_time or
                time.monotonic() - self._last_key_fetch_time &gt; 5
            ):
                await self.retrieve_public_keys()

            if not self.public_keys:
                raise RuntimeError(&#34;jwks could not be retrieved&#34;)

        return self.public_keys

    async def retrieve_public_keys(self) -&gt; None:
        &#34;&#34;&#34;
        Get the latest jwks from the hydra endpoint
        &#34;&#34;&#34;
        self._last_key_fetch_time = time.monotonic()
        try:
            async with aiohttp.ClientSession(raise_for_status=True) as session:
                async with session.get(config.HYDRA_JWKS_URI) as resp:
                    jwks = await resp.json()
                    self.public_keys = {
                        jwk[&#34;kid&#34;]: RSAAlgorithm.from_jwk(jwk)
                        for jwk in jwks[&#34;keys&#34;]
                    }
            self._logger.info(&#34;Got public keys from %s&#34;, config.HYDRA_JWKS_URI)
        except Exception:
            self._logger.exception(
                &#34;Unable to retrieve jwks, token login will be unavailable!&#34;
            )

    async def get_player_id_from_token(self, token: str) -&gt; int:
        &#34;&#34;&#34;
        Decode the JWT to get the player_id
        &#34;&#34;&#34;
        # Ensures that if we&#39;re missing the jwks we will try to fetch them on
        # each new login request. This way our login functionality will be
        # restored as soon as possible
        keys = await self.get_public_keys()
        try:
            kid = jwt.get_unverified_header(token)[&#34;kid&#34;]
            key = keys[kid]
            decoded = jwt.decode(
                token,
                key=key,
                algorithms=&#34;RS256&#34;,
                options={&#34;verify_aud&#34;: False}
            )

            if &#34;lobby&#34; not in decoded[&#34;scp&#34;]:
                raise AuthenticationError(
                    &#34;Token does not have permission to login to the lobby server&#34;,
                    &#34;token&#34;
                )

            return int(decoded[&#34;sub&#34;])
        except (InvalidTokenError, KeyError, ValueError):
            raise AuthenticationError(&#34;Token signature was invalid&#34;, &#34;token&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="server.core.service.Service" href="core/service.html#server.core.service.Service">Service</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="server.OAuthService.get_player_id_from_token"><code class="name flex">
<span>async def <span class="ident">get_player_id_from_token</span></span>(<span>self, token: str) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Decode the JWT to get the player_id</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_player_id_from_token(self, token: str) -&gt; int:
    &#34;&#34;&#34;
    Decode the JWT to get the player_id
    &#34;&#34;&#34;
    # Ensures that if we&#39;re missing the jwks we will try to fetch them on
    # each new login request. This way our login functionality will be
    # restored as soon as possible
    keys = await self.get_public_keys()
    try:
        kid = jwt.get_unverified_header(token)[&#34;kid&#34;]
        key = keys[kid]
        decoded = jwt.decode(
            token,
            key=key,
            algorithms=&#34;RS256&#34;,
            options={&#34;verify_aud&#34;: False}
        )

        if &#34;lobby&#34; not in decoded[&#34;scp&#34;]:
            raise AuthenticationError(
                &#34;Token does not have permission to login to the lobby server&#34;,
                &#34;token&#34;
            )

        return int(decoded[&#34;sub&#34;])
    except (InvalidTokenError, KeyError, ValueError):
        raise AuthenticationError(&#34;Token signature was invalid&#34;, &#34;token&#34;)</code></pre>
</details>
</dd>
<dt id="server.OAuthService.get_public_keys"><code class="name flex">
<span>async def <span class="ident">get_public_keys</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Return cached keys, or fetch them if they're missing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@synchronizedmethod
async def get_public_keys(self) -&gt; dict:
    &#34;&#34;&#34;
    Return cached keys, or fetch them if they&#39;re missing
    &#34;&#34;&#34;
    if not self.public_keys:
        # Rate limit requests so we don&#39;t spam the endpoint when it&#39;s down
        if (
            not self._last_key_fetch_time or
            time.monotonic() - self._last_key_fetch_time &gt; 5
        ):
            await self.retrieve_public_keys()

        if not self.public_keys:
            raise RuntimeError(&#34;jwks could not be retrieved&#34;)

    return self.public_keys</code></pre>
</details>
</dd>
<dt id="server.OAuthService.retrieve_public_keys"><code class="name flex">
<span>async def <span class="ident">retrieve_public_keys</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Get the latest jwks from the hydra endpoint</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def retrieve_public_keys(self) -&gt; None:
    &#34;&#34;&#34;
    Get the latest jwks from the hydra endpoint
    &#34;&#34;&#34;
    self._last_key_fetch_time = time.monotonic()
    try:
        async with aiohttp.ClientSession(raise_for_status=True) as session:
            async with session.get(config.HYDRA_JWKS_URI) as resp:
                jwks = await resp.json()
                self.public_keys = {
                    jwk[&#34;kid&#34;]: RSAAlgorithm.from_jwk(jwk)
                    for jwk in jwks[&#34;keys&#34;]
                }
        self._logger.info(&#34;Got public keys from %s&#34;, config.HYDRA_JWKS_URI)
    except Exception:
        self._logger.exception(
            &#34;Unable to retrieve jwks, token login will be unavailable!&#34;
        )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="server.core.service.Service" href="core/service.html#server.core.service.Service">Service</a></b></code>:
<ul class="hlist">
<li><code><a title="server.core.service.Service.initialize" href="core/service.html#server.core.service.Service.initialize">initialize</a></code></li>
<li><code><a title="server.core.service.Service.on_connection_lost" href="core/service.html#server.core.service.Service.on_connection_lost">on_connection_lost</a></code></li>
<li><code><a title="server.core.service.Service.shutdown" href="core/service.html#server.core.service.Service.shutdown">shutdown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="server.PartyService"><code class="flex name class">
<span>class <span class="ident">PartyService</span></span>
<span>(</span><span>game_service: <a title="server.game_service.GameService" href="game_service.html#server.game_service.GameService">GameService</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Service responsible for managing the player parties.</p>
<p>Logically, we consider players to always be in a party, either alone, or
with other players.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@with_logger
class PartyService(Service):
    &#34;&#34;&#34;
    Service responsible for managing the player parties.

    Logically, we consider players to always be in a party, either alone, or
    with other players.
    &#34;&#34;&#34;

    def __init__(self, game_service: GameService):
        self.game_service = game_service
        self.player_parties: dict[Player, PlayerParty] = {}
        self._dirty_parties: set[PlayerParty] = set()

    async def initialize(self):
        self._update_task = at_interval(1, self.update_dirties)

    async def shutdown(self):
        self._update_task.stop()

    async def update_dirties(self):
        if not self._dirty_parties:
            return

        dirty_parties = self._dirty_parties
        self._dirty_parties = set()

        for party in dirty_parties:
            try:
                self.write_broadcast_party(party)
            except Exception:  # pragma: no cover
                self._logger.exception(
                    &#34;Unexpected exception while sending party updates!&#34;
                )

    def write_broadcast_party(self, party, members=None):
        &#34;&#34;&#34;
        Send a party update to all players in the party
        &#34;&#34;&#34;
        if not members:
            members = iter(party)
        msg = {
            &#34;command&#34;: &#34;update_party&#34;,
            **party.to_dict()
        }
        for member in members:
            # Will re-encode the message for each player
            member.player.write_message(msg)

    def get_party(self, owner: Player) -&gt; PlayerParty:
        party = self.player_parties.get(owner)
        if not party:
            party = PlayerParty(owner)
            self.player_parties[owner] = party

        return party

    def mark_dirty(self, party: PlayerParty):
        self._dirty_parties.add(party)

    def invite_player_to_party(self, sender: Player, recipient: Player):
        &#34;&#34;&#34;
        Creates a new party for `sender` if one doesn&#39;t exist, and invites
        `recipient` to that party.
        &#34;&#34;&#34;
        if sender not in self.player_parties:
            self.player_parties[sender] = PlayerParty(sender)

        party = self.player_parties[sender]

        if party.owner != sender:
            raise ClientError(&#34;You do not own this party.&#34;, recoverable=True)

        party.add_invited_player(recipient)
        recipient.write_message({
            &#34;command&#34;: &#34;party_invite&#34;,
            &#34;sender&#34;: sender.id
        })

    async def accept_invite(self, recipient: Player, sender: Player):
        party = self.player_parties.get(sender)
        if (
            not party or
            recipient not in party.invited_players or
            party.invited_players[recipient].is_expired()
        ):
            # TODO: Localize with a proper message
            raise ClientError(&#34;You are not invited to that party (anymore)&#34;, recoverable=True)

        if sender.state is PlayerState.SEARCHING_LADDER:
            # TODO: Localize with a proper message
            raise ClientError(&#34;That party is already in queue&#34;, recoverable=True)

        old_party = self.player_parties.get(recipient)
        if old_party is not None:
            # Preserve state (like faction selection) from the old party
            member = old_party.get_member_by_player(recipient)
            assert member is not None

            await self.leave_party(recipient)
            party.add_member(member)
        else:
            party.add_player(recipient)

        self.player_parties[recipient] = party
        self.mark_dirty(party)

    async def kick_player_from_party(self, owner: Player, kicked_player: Player):
        if owner not in self.player_parties:
            raise ClientError(&#34;You are not in a party.&#34;, recoverable=True)

        party = self.player_parties[owner]

        if party.owner != owner:
            raise ClientError(&#34;You do not own that party.&#34;, recoverable=True)

        if kicked_player not in party:
            # Client state appears to be out of date
            await party.send_party(owner)
            return

        party.remove_player(kicked_player)
        del self.player_parties[kicked_player]

        kicked_player.write_message({&#34;command&#34;: &#34;kicked_from_party&#34;})

        self.mark_dirty(party)

    async def leave_party(self, player: Player):
        if player not in self.player_parties:
            raise ClientError(&#34;You are not in a party.&#34;, recoverable=True)

        party = self.player_parties[player]
        self._remove_player_from_party(player, party)
        # TODO: Remove?
        await party.send_party(player)

    def _remove_player_from_party(self, player, party):
        party.remove_player(player)
        del self.player_parties[player]

        if party.is_disbanded():
            self.remove_party(party)
            return

        self.mark_dirty(party)

    def set_factions(self, player: Player, factions: list[Faction]):
        if player not in self.player_parties:
            self.player_parties[player] = PlayerParty(player)

        party = self.player_parties[player]
        party.set_factions(player, factions)
        self.mark_dirty(party)

    def remove_party(self, party):
        # Remove all players who were in the party
        self._logger.info(&#34;Removing party: %s&#34;, party.members)
        for member in party:
            self._logger.info(&#34;Removing party for player %s&#34;, member.player)
            if party == self.player_parties.get(member.player):
                del self.player_parties[member.player]
            else:
                self._logger.warning(
                    &#34;Player %s was in two parties at once!&#34;, member.player
                )

        members = party.members
        party.clear()
        # TODO: Send a special &#34;disbanded&#34; command?
        self.write_broadcast_party(party, members=members)

    def on_connection_lost(self, conn: &#34;LobbyConnection&#34;) -&gt; None:
        if not conn.player or conn.player not in self.player_parties:
            return

        self._remove_player_from_party(
            conn.player,
            self.player_parties[conn.player]
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="server.core.service.Service" href="core/service.html#server.core.service.Service">Service</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="server.PartyService.accept_invite"><code class="name flex">
<span>async def <span class="ident">accept_invite</span></span>(<span>self, recipient: <a title="server.players.Player" href="players.html#server.players.Player">Player</a>, sender: <a title="server.players.Player" href="players.html#server.players.Player">Player</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def accept_invite(self, recipient: Player, sender: Player):
    party = self.player_parties.get(sender)
    if (
        not party or
        recipient not in party.invited_players or
        party.invited_players[recipient].is_expired()
    ):
        # TODO: Localize with a proper message
        raise ClientError(&#34;You are not invited to that party (anymore)&#34;, recoverable=True)

    if sender.state is PlayerState.SEARCHING_LADDER:
        # TODO: Localize with a proper message
        raise ClientError(&#34;That party is already in queue&#34;, recoverable=True)

    old_party = self.player_parties.get(recipient)
    if old_party is not None:
        # Preserve state (like faction selection) from the old party
        member = old_party.get_member_by_player(recipient)
        assert member is not None

        await self.leave_party(recipient)
        party.add_member(member)
    else:
        party.add_player(recipient)

    self.player_parties[recipient] = party
    self.mark_dirty(party)</code></pre>
</details>
</dd>
<dt id="server.PartyService.get_party"><code class="name flex">
<span>def <span class="ident">get_party</span></span>(<span>self, owner: <a title="server.players.Player" href="players.html#server.players.Player">Player</a>) ‑> <a title="server.team_matchmaker.player_party.PlayerParty" href="team_matchmaker/player_party.html#server.team_matchmaker.player_party.PlayerParty">PlayerParty</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_party(self, owner: Player) -&gt; PlayerParty:
    party = self.player_parties.get(owner)
    if not party:
        party = PlayerParty(owner)
        self.player_parties[owner] = party

    return party</code></pre>
</details>
</dd>
<dt id="server.PartyService.invite_player_to_party"><code class="name flex">
<span>def <span class="ident">invite_player_to_party</span></span>(<span>self, sender: <a title="server.players.Player" href="players.html#server.players.Player">Player</a>, recipient: <a title="server.players.Player" href="players.html#server.players.Player">Player</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new party for <code>sender</code> if one doesn't exist, and invites
<code>recipient</code> to that party.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def invite_player_to_party(self, sender: Player, recipient: Player):
    &#34;&#34;&#34;
    Creates a new party for `sender` if one doesn&#39;t exist, and invites
    `recipient` to that party.
    &#34;&#34;&#34;
    if sender not in self.player_parties:
        self.player_parties[sender] = PlayerParty(sender)

    party = self.player_parties[sender]

    if party.owner != sender:
        raise ClientError(&#34;You do not own this party.&#34;, recoverable=True)

    party.add_invited_player(recipient)
    recipient.write_message({
        &#34;command&#34;: &#34;party_invite&#34;,
        &#34;sender&#34;: sender.id
    })</code></pre>
</details>
</dd>
<dt id="server.PartyService.kick_player_from_party"><code class="name flex">
<span>async def <span class="ident">kick_player_from_party</span></span>(<span>self, owner: <a title="server.players.Player" href="players.html#server.players.Player">Player</a>, kicked_player: <a title="server.players.Player" href="players.html#server.players.Player">Player</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def kick_player_from_party(self, owner: Player, kicked_player: Player):
    if owner not in self.player_parties:
        raise ClientError(&#34;You are not in a party.&#34;, recoverable=True)

    party = self.player_parties[owner]

    if party.owner != owner:
        raise ClientError(&#34;You do not own that party.&#34;, recoverable=True)

    if kicked_player not in party:
        # Client state appears to be out of date
        await party.send_party(owner)
        return

    party.remove_player(kicked_player)
    del self.player_parties[kicked_player]

    kicked_player.write_message({&#34;command&#34;: &#34;kicked_from_party&#34;})

    self.mark_dirty(party)</code></pre>
</details>
</dd>
<dt id="server.PartyService.leave_party"><code class="name flex">
<span>async def <span class="ident">leave_party</span></span>(<span>self, player: <a title="server.players.Player" href="players.html#server.players.Player">Player</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def leave_party(self, player: Player):
    if player not in self.player_parties:
        raise ClientError(&#34;You are not in a party.&#34;, recoverable=True)

    party = self.player_parties[player]
    self._remove_player_from_party(player, party)
    # TODO: Remove?
    await party.send_party(player)</code></pre>
</details>
</dd>
<dt id="server.PartyService.mark_dirty"><code class="name flex">
<span>def <span class="ident">mark_dirty</span></span>(<span>self, party: <a title="server.team_matchmaker.player_party.PlayerParty" href="team_matchmaker/player_party.html#server.team_matchmaker.player_party.PlayerParty">PlayerParty</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mark_dirty(self, party: PlayerParty):
    self._dirty_parties.add(party)</code></pre>
</details>
</dd>
<dt id="server.PartyService.remove_party"><code class="name flex">
<span>def <span class="ident">remove_party</span></span>(<span>self, party)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_party(self, party):
    # Remove all players who were in the party
    self._logger.info(&#34;Removing party: %s&#34;, party.members)
    for member in party:
        self._logger.info(&#34;Removing party for player %s&#34;, member.player)
        if party == self.player_parties.get(member.player):
            del self.player_parties[member.player]
        else:
            self._logger.warning(
                &#34;Player %s was in two parties at once!&#34;, member.player
            )

    members = party.members
    party.clear()
    # TODO: Send a special &#34;disbanded&#34; command?
    self.write_broadcast_party(party, members=members)</code></pre>
</details>
</dd>
<dt id="server.PartyService.set_factions"><code class="name flex">
<span>def <span class="ident">set_factions</span></span>(<span>self, player: <a title="server.players.Player" href="players.html#server.players.Player">Player</a>, factions: list[<a title="server.factions.Faction" href="factions.html#server.factions.Faction">Faction</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_factions(self, player: Player, factions: list[Faction]):
    if player not in self.player_parties:
        self.player_parties[player] = PlayerParty(player)

    party = self.player_parties[player]
    party.set_factions(player, factions)
    self.mark_dirty(party)</code></pre>
</details>
</dd>
<dt id="server.PartyService.update_dirties"><code class="name flex">
<span>async def <span class="ident">update_dirties</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def update_dirties(self):
    if not self._dirty_parties:
        return

    dirty_parties = self._dirty_parties
    self._dirty_parties = set()

    for party in dirty_parties:
        try:
            self.write_broadcast_party(party)
        except Exception:  # pragma: no cover
            self._logger.exception(
                &#34;Unexpected exception while sending party updates!&#34;
            )</code></pre>
</details>
</dd>
<dt id="server.PartyService.write_broadcast_party"><code class="name flex">
<span>def <span class="ident">write_broadcast_party</span></span>(<span>self, party, members=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Send a party update to all players in the party</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_broadcast_party(self, party, members=None):
    &#34;&#34;&#34;
    Send a party update to all players in the party
    &#34;&#34;&#34;
    if not members:
        members = iter(party)
    msg = {
        &#34;command&#34;: &#34;update_party&#34;,
        **party.to_dict()
    }
    for member in members:
        # Will re-encode the message for each player
        member.player.write_message(msg)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="server.core.service.Service" href="core/service.html#server.core.service.Service">Service</a></b></code>:
<ul class="hlist">
<li><code><a title="server.core.service.Service.initialize" href="core/service.html#server.core.service.Service.initialize">initialize</a></code></li>
<li><code><a title="server.core.service.Service.on_connection_lost" href="core/service.html#server.core.service.Service.on_connection_lost">on_connection_lost</a></code></li>
<li><code><a title="server.core.service.Service.shutdown" href="core/service.html#server.core.service.Service.shutdown">shutdown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="server.PlayerService"><code class="flex name class">
<span>class <span class="ident">PlayerService</span></span>
<span>(</span><span>database: <a title="server.db.FAFDatabase" href="db/index.html#server.db.FAFDatabase">FAFDatabase</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>All services should inherit from this class.</p>
<p>Services are singleton objects which manage some server task.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@with_logger
class PlayerService(Service):
    def __init__(self, database: FAFDatabase):
        self._db = database
        self._players = dict()

        # Static-ish data fields.
        self.uniqueid_exempt = {}
        self._dirty_players = set()

    async def initialize(self) -&gt; None:
        await self.update_data()
        self._update_cron = aiocron.crontab(
            &#34;*/10 * * * *&#34;, func=self.update_data
        )

    def __len__(self):
        return len(self._players)

    def __iter__(self):
        return self._players.values().__iter__()

    def __getitem__(self, player_id: int) -&gt; Optional[Player]:
        return self._players.get(player_id)

    def __setitem__(self, player_id: int, player: Player):
        self._players[player_id] = player
        metrics.players_online.set(len(self._players))

    @property
    def all_players(self) -&gt; ValuesView[Player]:
        return self._players.values()

    def mark_dirty(self, player: Player):
        self._dirty_players.add(player)

    def pop_dirty_players(self) -&gt; set[Player]:
        dirty_players = self._dirty_players
        self._dirty_players = set()

        return dirty_players

    async def fetch_player_data(self, player):
        async with self._db.acquire() as conn:
            result = await conn.execute(
                select([user_group.c.technical_name])
                .select_from(user_group_assignment.join(user_group))
                .where(user_group_assignment.c.user_id == player.id)
            )
            player.user_groups = {row.technical_name for row in result}

            sql = select([
                avatars_list.c.url,
                avatars_list.c.tooltip,
                clan.c.tag
            ], use_labels=True).select_from(
                login
                .outerjoin(clan_membership)
                .outerjoin(clan)
                .outerjoin(
                    avatars,
                    onclause=and_(
                        avatars.c.idUser == login.c.id,
                        avatars.c.selected == 1
                    )
                )
                .outerjoin(avatars_list)
            ).where(login.c.id == player.id)  # yapf: disable

            result = await conn.execute(sql)
            row = result.fetchone()
            if not row:
                self._logger.warning(
                    &#34;Did not find data for player with id %i&#34;,
                    player.id
                )
                return

            row = row._mapping
            player.clan = row.get(clan.c.tag)

            url, tooltip = (
                row.get(avatars_list.c.url),
                row.get(avatars_list.c.tooltip)
            )
            if url and tooltip:
                player.avatar = {&#34;url&#34;: url, &#34;tooltip&#34;: tooltip}

            await self._fetch_player_ratings(player, conn)

    async def _fetch_player_ratings(self, player, conn):
        sql = select([
            leaderboard_rating.c.mean,
            leaderboard_rating.c.deviation,
            leaderboard_rating.c.total_games,
            leaderboard.c.technical_name,
        ]).select_from(
            leaderboard.join(leaderboard_rating)
        ).where(
            leaderboard_rating.c.login_id == player.id
        )
        result = await conn.execute(sql)

        retrieved_ratings = {
            row.technical_name: (
                (row.mean, row.deviation),
                row.total_games
            )
            for row in result
        }
        for rating_type, (rating, total_games) in retrieved_ratings.items():
            player.ratings[rating_type] = rating
            player.game_count[rating_type] = total_games

        types_not_found = [
            rating_type for rating_type in (
                RatingType.GLOBAL, RatingType.LADDER_1V1
            )
            if rating_type not in retrieved_ratings
        ]
        await self._fetch_player_legacy_rating(player, types_not_found, conn)

    async def _fetch_player_legacy_rating(self, player, rating_types, conn):
        if not rating_types:
            return

        sql = select(
            [
                global_rating.c.mean, global_rating.c.deviation,
                global_rating.c.numGames,
                ladder1v1_rating.c.mean, ladder1v1_rating.c.deviation,
                ladder1v1_rating.c.numGames,
            ], use_labels=True
        ).select_from(
            login.outerjoin(ladder1v1_rating).outerjoin(global_rating)
        ).where(
            login.c.id == player.id
        )
        result = await conn.execute(sql)
        row = result.fetchone()

        if row is None:
            self._logger.info(&#34;Found no ratings for Player with id %i&#34;, player.id)
            return

        row = row._mapping

        table_map = {
            RatingType.GLOBAL: &#34;global_rating_{}&#34;,
            RatingType.LADDER_1V1: &#34;ladder1v1_rating_{}&#34;,
        }
        for rating_type in rating_types:
            if rating_type not in table_map:
                raise ValueError(f&#34;Unknown rating type {rating_type}.&#34;)

            table = table_map[rating_type]
            if row[table.format(&#34;mean&#34;)] is None:
                self._logger.info(
                    &#34;Found no %s ratings for Player with id %i&#34;,
                    rating_type, player.id
                )
                continue

            player.ratings[rating_type] = (
                row[table.format(&#34;mean&#34;)],
                row[table.format(&#34;deviation&#34;)]
            )
            player.game_count[rating_type] = row[table.format(&#34;numGames&#34;)]

    def remove_player(self, player: Player):
        if player.id in self._players:
            del self._players[player.id]
            metrics.players_online.set(len(self._players))

    async def has_permission_role(self, player: Player, role_name: str) -&gt; bool:
        async with self._db.acquire() as conn:
            result = await conn.execute(
                select([group_permission.c.id])
                .select_from(
                    user_group_assignment
                    .join(group_permission_assignment, onclause=(
                        user_group_assignment.c.group_id ==
                        group_permission_assignment.c.group_id
                    ))
                    .join(group_permission)
                )
                .where(
                    and_(
                        user_group_assignment.c.user_id == player.id,
                        group_permission.c.technical_name == role_name
                    )
                )
            )
            row = result.fetchone()
            return row is not None

    def is_uniqueid_exempt(self, user_id: int) -&gt; bool:
        return user_id in self.uniqueid_exempt

    def get_player(self, player_id: int) -&gt; Optional[Player]:
        return self._players.get(player_id)

    def signal_player_rating_change(
        self, player_id: int, rating_type: str, new_rating: Rating
    ) -&gt; None:
        player = self.get_player(player_id)
        if player is None:
            self._logger.debug(
                &#34;Received rating change for player with id %i not in PlayerService.&#34;,
                player_id
            )
            return

        self._logger.debug(
            &#34;Received rating change for player %s.&#34;, player
        )
        player.ratings[rating_type] = new_rating
        player.game_count[rating_type] += 1
        self.mark_dirty(player)

    async def update_data(self):
        &#34;&#34;&#34;
        Update rarely-changing data, such as the admin list and the list of users exempt from the
        uniqueid check.
        &#34;&#34;&#34;
        async with self._db.acquire() as conn:
            # UniqueID-exempt users.
            result = await conn.execute(
                &#34;SELECT `user_id` FROM uniqueid_exempt&#34;
            )
            self.uniqueid_exempt = frozenset(map(lambda x: x[0], result))

    async def shutdown(self):
        for player in self:
            if player.lobby_connection is not None:
                with contextlib.suppress(Exception):
                    player.lobby_connection.write_warning(
                        &#34;The server has been shut down for maintenance, &#34;
                        &#34;but should be back online soon. If you experience any &#34;
                        &#34;problems, please restart your client. &lt;br/&gt;&lt;br/&gt;&#34;
                        &#34;We apologize for this interruption.&#34;
                    )

    def on_connection_lost(self, conn: &#34;LobbyConnection&#34;) -&gt; None:
        if not conn.player:
            return

        self.remove_player(conn.player)

        self._logger.debug(
            &#34;Removed player %d, %s, %d&#34;,
            conn.player.id,
            conn.player.login,
            conn.session
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="server.core.service.Service" href="core/service.html#server.core.service.Service">Service</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="server.PlayerService.all_players"><code class="name">var <span class="ident">all_players</span> : ValuesView[<a title="server.players.Player" href="players.html#server.players.Player">Player</a>]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def all_players(self) -&gt; ValuesView[Player]:
    return self._players.values()</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="server.PlayerService.fetch_player_data"><code class="name flex">
<span>async def <span class="ident">fetch_player_data</span></span>(<span>self, player)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def fetch_player_data(self, player):
    async with self._db.acquire() as conn:
        result = await conn.execute(
            select([user_group.c.technical_name])
            .select_from(user_group_assignment.join(user_group))
            .where(user_group_assignment.c.user_id == player.id)
        )
        player.user_groups = {row.technical_name for row in result}

        sql = select([
            avatars_list.c.url,
            avatars_list.c.tooltip,
            clan.c.tag
        ], use_labels=True).select_from(
            login
            .outerjoin(clan_membership)
            .outerjoin(clan)
            .outerjoin(
                avatars,
                onclause=and_(
                    avatars.c.idUser == login.c.id,
                    avatars.c.selected == 1
                )
            )
            .outerjoin(avatars_list)
        ).where(login.c.id == player.id)  # yapf: disable

        result = await conn.execute(sql)
        row = result.fetchone()
        if not row:
            self._logger.warning(
                &#34;Did not find data for player with id %i&#34;,
                player.id
            )
            return

        row = row._mapping
        player.clan = row.get(clan.c.tag)

        url, tooltip = (
            row.get(avatars_list.c.url),
            row.get(avatars_list.c.tooltip)
        )
        if url and tooltip:
            player.avatar = {&#34;url&#34;: url, &#34;tooltip&#34;: tooltip}

        await self._fetch_player_ratings(player, conn)</code></pre>
</details>
</dd>
<dt id="server.PlayerService.get_player"><code class="name flex">
<span>def <span class="ident">get_player</span></span>(<span>self, player_id: int) ‑> Optional[<a title="server.players.Player" href="players.html#server.players.Player">Player</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_player(self, player_id: int) -&gt; Optional[Player]:
    return self._players.get(player_id)</code></pre>
</details>
</dd>
<dt id="server.PlayerService.has_permission_role"><code class="name flex">
<span>async def <span class="ident">has_permission_role</span></span>(<span>self, player: <a title="server.players.Player" href="players.html#server.players.Player">Player</a>, role_name: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def has_permission_role(self, player: Player, role_name: str) -&gt; bool:
    async with self._db.acquire() as conn:
        result = await conn.execute(
            select([group_permission.c.id])
            .select_from(
                user_group_assignment
                .join(group_permission_assignment, onclause=(
                    user_group_assignment.c.group_id ==
                    group_permission_assignment.c.group_id
                ))
                .join(group_permission)
            )
            .where(
                and_(
                    user_group_assignment.c.user_id == player.id,
                    group_permission.c.technical_name == role_name
                )
            )
        )
        row = result.fetchone()
        return row is not None</code></pre>
</details>
</dd>
<dt id="server.PlayerService.is_uniqueid_exempt"><code class="name flex">
<span>def <span class="ident">is_uniqueid_exempt</span></span>(<span>self, user_id: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_uniqueid_exempt(self, user_id: int) -&gt; bool:
    return user_id in self.uniqueid_exempt</code></pre>
</details>
</dd>
<dt id="server.PlayerService.mark_dirty"><code class="name flex">
<span>def <span class="ident">mark_dirty</span></span>(<span>self, player: <a title="server.players.Player" href="players.html#server.players.Player">Player</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mark_dirty(self, player: Player):
    self._dirty_players.add(player)</code></pre>
</details>
</dd>
<dt id="server.PlayerService.pop_dirty_players"><code class="name flex">
<span>def <span class="ident">pop_dirty_players</span></span>(<span>self) ‑> set[<a title="server.players.Player" href="players.html#server.players.Player">Player</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop_dirty_players(self) -&gt; set[Player]:
    dirty_players = self._dirty_players
    self._dirty_players = set()

    return dirty_players</code></pre>
</details>
</dd>
<dt id="server.PlayerService.remove_player"><code class="name flex">
<span>def <span class="ident">remove_player</span></span>(<span>self, player: <a title="server.players.Player" href="players.html#server.players.Player">Player</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_player(self, player: Player):
    if player.id in self._players:
        del self._players[player.id]
        metrics.players_online.set(len(self._players))</code></pre>
</details>
</dd>
<dt id="server.PlayerService.signal_player_rating_change"><code class="name flex">
<span>def <span class="ident">signal_player_rating_change</span></span>(<span>self, player_id: int, rating_type: str, new_rating: trueskill.Rating) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def signal_player_rating_change(
    self, player_id: int, rating_type: str, new_rating: Rating
) -&gt; None:
    player = self.get_player(player_id)
    if player is None:
        self._logger.debug(
            &#34;Received rating change for player with id %i not in PlayerService.&#34;,
            player_id
        )
        return

    self._logger.debug(
        &#34;Received rating change for player %s.&#34;, player
    )
    player.ratings[rating_type] = new_rating
    player.game_count[rating_type] += 1
    self.mark_dirty(player)</code></pre>
</details>
</dd>
<dt id="server.PlayerService.update_data"><code class="name flex">
<span>async def <span class="ident">update_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Update rarely-changing data, such as the admin list and the list of users exempt from the
uniqueid check.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def update_data(self):
    &#34;&#34;&#34;
    Update rarely-changing data, such as the admin list and the list of users exempt from the
    uniqueid check.
    &#34;&#34;&#34;
    async with self._db.acquire() as conn:
        # UniqueID-exempt users.
        result = await conn.execute(
            &#34;SELECT `user_id` FROM uniqueid_exempt&#34;
        )
        self.uniqueid_exempt = frozenset(map(lambda x: x[0], result))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="server.core.service.Service" href="core/service.html#server.core.service.Service">Service</a></b></code>:
<ul class="hlist">
<li><code><a title="server.core.service.Service.initialize" href="core/service.html#server.core.service.Service.initialize">initialize</a></code></li>
<li><code><a title="server.core.service.Service.on_connection_lost" href="core/service.html#server.core.service.Service.on_connection_lost">on_connection_lost</a></code></li>
<li><code><a title="server.core.service.Service.shutdown" href="core/service.html#server.core.service.Service.shutdown">shutdown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="server.RatingService"><code class="flex name class">
<span>class <span class="ident">RatingService</span></span>
<span>(</span><span>database: <a title="server.db.FAFDatabase" href="db/index.html#server.db.FAFDatabase">FAFDatabase</a>, player_service: <a title="server.player_service.PlayerService" href="player_service.html#server.player_service.PlayerService">PlayerService</a>, message_queue_service: <a title="server.message_queue_service.MessageQueueService" href="message_queue_service.html#server.message_queue_service.MessageQueueService">MessageQueueService</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Service responsible for calculating and saving trueskill rating updates.
To avoid race conditions, rating updates from a single game ought to be
atomic.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@with_logger
class RatingService(Service):
    &#34;&#34;&#34;
    Service responsible for calculating and saving trueskill rating updates.
    To avoid race conditions, rating updates from a single game ought to be
    atomic.
    &#34;&#34;&#34;

    def __init__(
        self,
        database: FAFDatabase,
        player_service: PlayerService,
        message_queue_service: MessageQueueService
    ):
        self._db = database
        self._player_service_callback = player_service.signal_player_rating_change
        self._accept_input = False
        self._queue = asyncio.Queue()
        self._task = None
        self._rating_type_ids: Optional[dict[str, int]] = None
        self.leaderboards: dict[str, Leaderboard] = {}
        self._message_queue_service = message_queue_service

    async def initialize(self) -&gt; None:
        if self._task is not None:
            self._logger.error(&#34;Service already runnning or not properly shut down.&#34;)
            return

        await self.update_data()
        self._update_cron = aiocron.crontab(&#34;*/10 * * * *&#34;, func=self.update_data)
        self._accept_input = True
        self._task = asyncio.create_task(self._handle_rating_queue())

    async def update_data(self):
        async with self._db.acquire() as conn:
            initializer = leaderboard.alias()
            sql = select([
                leaderboard.c.id,
                leaderboard.c.technical_name,
                initializer.c.technical_name.label(&#34;initializer&#34;)
            ]).select_from(
                leaderboard.outerjoin(
                    initializer,
                    leaderboard.c.initializer_id == initializer.c.id
                )
            )
            result = await conn.execute(sql)
            rows = result.fetchall()

            self.leaderboards.clear()
            self._rating_type_ids = {}
            for row in rows:
                self.leaderboards[row.technical_name] = Leaderboard(
                    row.id,
                    row.technical_name
                )
                self._rating_type_ids[row.technical_name] = row.id

            # Link the initializers
            for row in rows:
                current = self.leaderboards[row.technical_name]
                init = self.leaderboards.get(row.initializer)
                if init:
                    current.initializer = init

    async def enqueue(self, game_info: dict[str]) -&gt; None:
        if not self._accept_input:
            self._logger.warning(&#34;Dropped rating request %s&#34;, game_info)
            raise ServiceNotReadyError(
                &#34;RatingService not yet initialized or shutting down.&#34;
            )

        summary = GameRatingSummary.from_game_info_dict(game_info)
        self._logger.debug(&#34;Queued up rating request %s&#34;, summary)
        await self._queue.put(summary)
        rating_service_backlog.set(self._queue.qsize())

    async def _handle_rating_queue(self) -&gt; None:
        self._logger.debug(&#34;RatingService started!&#34;)
        try:
            while self._accept_input or not self._queue.empty():
                summary = await self._queue.get()
                self._logger.debug(&#34;Now rating request %s&#34;, summary)

                try:
                    # Make sure we finish writing rating changes even if the
                    # server is shutting down
                    await asyncio.shield(self._rate(summary))
                except GameRatingError:
                    self._logger.warning(&#34;Error rating game %s&#34;, summary)
                except Exception:  # pragma: no cover
                    self._logger.exception(&#34;Failed rating request %s&#34;, summary)
                else:
                    self._logger.debug(&#34;Done rating request.&#34;)
                finally:
                    self._queue.task_done()
                rating_service_backlog.set(self._queue.qsize())
        except asyncio.CancelledError:
            pass
        except Exception:  # pragma: no cover
            self._logger.critical(
                &#34;Unexpected exception while handling rating queue.&#34;,
                exc_info=True
            )

        self._logger.debug(&#34;RatingService stopped.&#34;)

    async def _rate(self, summary: GameRatingSummary) -&gt; None:
        assert self._rating_type_ids is not None

        if summary.rating_type not in self._rating_type_ids:
            raise GameRatingError(f&#34;Unknown rating type {summary.rating_type}.&#34;)

        rater = GameRater(summary)
        rating_results = []

        async with self._db.acquire() as conn:
            # Fetch all players rating info from the database
            player_ratings = await self._get_all_player_ratings(
                conn, rater.player_ids
            )
            rating_result = await self._rate_for_leaderboard(
                conn,
                summary.game_id,
                summary.rating_type,
                player_ratings,
                rater
            )
            assert rating_result is not None
            rating_results.append(rating_result)

            # TODO: If we add hidden ratings, make sure to check for them here.
            # Hidden ratings should not affect global.
            # TODO: Use game_type == &#34;matchmaker&#34; instead?
            if summary.rating_type != RatingType.GLOBAL:
                self._logger.debug(
                    &#34;Performing global rating adjustment for players: %s&#34;,
                    rater.player_ids
                )
                adjustment_rater = AdjustmentGameRater(
                    rater,
                    rating_result.old_ratings
                )
                global_rating_result = await self._rate_for_leaderboard(
                    conn,
                    summary.game_id,
                    RatingType.GLOBAL,
                    player_ratings,
                    adjustment_rater,
                    update_game_player_stats=False
                )
                if global_rating_result:
                    rating_results.append(global_rating_result)

        for rating_result in rating_results:
            await self._publish_rating_changes(
                rating_result.rating_type,
                rating_result.old_ratings,
                rating_result.new_ratings,
                rating_result.outcome_map
            )

    async def _rate_for_leaderboard(
        self,
        conn,
        game_id: int,
        rating_type: str,
        player_ratings: dict[PlayerID, PlayerRatings],
        rater: GameRater,
        update_game_player_stats: bool = True
    ) -&gt; Optional[GameRatingResult]:
        &#34;&#34;&#34;
        Rates a game using a particular rating_type and GameRater.
        &#34;&#34;&#34;
        uninitialized_ratings = {
            # Querying the key will create the value using rating
            # initialization, sort of like a defaultdict.
            player_id: Rating(*player_ratings[player_id][rating_type])
            for player_id in player_ratings.keys()
            if rating_type not in player_ratings[player_id]
        }
        # Initialize the ratings we need
        old_ratings = {
            player_id: Rating(*player_ratings[player_id][rating_type])
            for player_id in player_ratings.keys()
        }

        new_ratings = rater.compute_rating(old_ratings)
        if not new_ratings:
            return None

        need_initial_ratings = {
            player_id: rating
            for player_id, rating in uninitialized_ratings.items()
            if player_id in new_ratings
        }
        if need_initial_ratings:
            # Ensure that leaderboard entries exist before calling persist.
            await self._create_initial_ratings(
                conn,
                rating_type,
                need_initial_ratings
            )

        outcome_map = rater.get_outcome_map()
        # Now persist the changes for all players that get the adjustment.
        await self._persist_rating_changes(
            conn,
            game_id,
            rating_type,
            old_ratings,
            new_ratings,
            outcome_map,
            update_game_player_stats=update_game_player_stats
        )

        return GameRatingResult(
            rating_type,
            old_ratings,
            new_ratings,
            outcome_map
        )

    async def _create_initial_ratings(
        self,
        conn,
        rating_type: str,
        ratings: RatingDict
    ):
        assert self._rating_type_ids is not None

        leaderboard_id = self._rating_type_ids[rating_type]

        values = [
            dict(
                login_id=player_id,
                mean=rating.mean,
                deviation=rating.dev,
                total_games=0,
                won_games=0,
                leaderboard_id=leaderboard_id,
            )
            for player_id, rating in ratings.items()
        ]
        if values:
            await conn.execute(
                leaderboard_rating.insert(),
                values
            )

    async def _get_all_player_ratings(
        self, conn, player_ids: list[PlayerID]
    ) -&gt; dict[PlayerID, PlayerRatings]:
        sql = select([
            leaderboard_rating.c.login_id,
            leaderboard.c.technical_name,
            leaderboard_rating.c.mean,
            leaderboard_rating.c.deviation
        ]).join(leaderboard).where(
            leaderboard_rating.c.login_id.in_(player_ids)
        )
        result = await conn.execute(sql)

        player_ratings = {
            player_id: PlayerRatings(self.leaderboards, init=False)
            for player_id in player_ids
        }

        for row in result:
            player_id, rating_type = row.login_id, row.technical_name
            player_ratings[player_id][rating_type] = (row.mean, row.deviation)

        return player_ratings

    async def _persist_rating_changes(
        self,
        conn,
        game_id: int,
        rating_type: str,
        old_ratings: RatingDict,
        new_ratings: RatingDict,
        outcomes: dict[PlayerID, GameOutcome],
        update_game_player_stats: bool = True
    ) -&gt; None:
        &#34;&#34;&#34;
        Persist computed ratings to the respective players&#39; selected rating
        &#34;&#34;&#34;
        assert self._rating_type_ids is not None

        self._logger.debug(&#34;Saving rating change stats for game %i&#34;, game_id)

        ratings = [
            (player_id, old_ratings[player_id], new_ratings[player_id])
            for player_id in new_ratings.keys()
        ]

        for player_id, old_rating, new_rating in ratings:
            self._logger.debug(
                &#34;New %s rating for player with id %s: %s -&gt; %s&#34;,
                rating_type,
                player_id,
                old_rating,
                new_rating,
            )

        if update_game_player_stats:
            # DEPRECATED: game_player_stats table contains rating data.
            # Use leaderboard_rating_journal instead
            gps_update_sql = (
                game_player_stats.update()
                .where(
                    and_(
                        game_player_stats.c.playerId == bindparam(&#34;player_id&#34;),
                        game_player_stats.c.gameId == game_id,
                    )
                )
                .values(
                    after_mean=bindparam(&#34;after_mean&#34;),
                    after_deviation=bindparam(&#34;after_deviation&#34;),
                    mean=bindparam(&#34;mean&#34;),
                    deviation=bindparam(&#34;deviation&#34;),
                    scoreTime=func.now()
                )
            )
            try:
                result = await conn.execute(gps_update_sql, [
                    dict(
                        player_id=player_id,
                        after_mean=new_rating.mean,
                        after_deviation=new_rating.dev,
                        mean=old_rating.mean,
                        deviation=old_rating.dev,
                    )
                    for player_id, old_rating, new_rating in ratings
                ])

                if result.rowcount != len(ratings):
                    self._logger.warning(
                        &#34;gps_update_sql only updated %d out of %d rows for game_id %d&#34;,
                        result.rowcount,
                        len(ratings),
                        game_id
                    )
                    return
            except pymysql.OperationalError:
                # Could happen if we drop the rating columns from game_player_stats
                self._logger.warning(
                    &#34;gps_update_sql failed for game %d, ignoring...&#34;,
                    game_id,
                    exc_info=True
                )

        leaderboard_id = self._rating_type_ids[rating_type]

        journal_insert_sql = leaderboard_rating_journal.insert().values(
            leaderboard_id=leaderboard_id,
            rating_mean_before=bindparam(&#34;rating_mean_before&#34;),
            rating_deviation_before=bindparam(&#34;rating_deviation_before&#34;),
            rating_mean_after=bindparam(&#34;rating_mean_after&#34;),
            rating_deviation_after=bindparam(&#34;rating_deviation_after&#34;),
            game_player_stats_id=select([game_player_stats.c.id]).where(
                and_(
                    game_player_stats.c.playerId == bindparam(&#34;player_id&#34;),
                    game_player_stats.c.gameId == game_id,
                )
            ).scalar_subquery(),
        )
        await conn.execute(journal_insert_sql, [
            dict(
                player_id=player_id,
                rating_mean_before=old_rating.mean,
                rating_deviation_before=old_rating.dev,
                rating_mean_after=new_rating.mean,
                rating_deviation_after=new_rating.dev,
            )
            for player_id, old_rating, new_rating in ratings
        ])

        rating_update_sql = (
            leaderboard_rating.update()
            .where(
                and_(
                    leaderboard_rating.c.login_id == bindparam(&#34;player_id&#34;),
                    leaderboard_rating.c.leaderboard_id == leaderboard_id,
                )
            )
            .values(
                mean=bindparam(&#34;mean&#34;),
                deviation=bindparam(&#34;deviation&#34;),
                total_games=leaderboard_rating.c.total_games + 1,
                won_games=leaderboard_rating.c.won_games + bindparam(&#34;increment&#34;),
            )
        )
        await conn.execute(rating_update_sql, [
            dict(
                player_id=player_id,
                mean=new_rating.mean,
                deviation=new_rating.dev,
                increment=(
                    1 if outcomes[player_id] is GameOutcome.VICTORY else 0
                )
            )
            for player_id, _, new_rating in ratings
        ])

        for player_id, new_rating in new_ratings.items():
            self._update_player_object(player_id, rating_type, new_rating)

    def _update_player_object(
        self, player_id: PlayerID, rating_type: str, new_rating: Rating
    ) -&gt; None:
        if self._player_service_callback is None:
            self._logger.warning(
                &#34;Tried to send rating change to player service, &#34;
                &#34;but no service was registered.&#34;
            )
            return

        self._logger.debug(
            &#34;Sending player rating update for player with id %i&#34;, player_id
        )
        self._player_service_callback(player_id, rating_type, new_rating)

    async def _publish_rating_changes(
        self,
        rating_type: str,
        old_ratings: RatingDict,
        new_ratings: RatingDict,
        outcomes: dict[PlayerID, GameOutcome],
    ):
        for player_id, new_rating in new_ratings.items():
            if player_id not in outcomes:
                self._logger.error(&#34;Missing outcome for player %i&#34;, player_id)
                continue
            if player_id not in old_ratings:
                self._logger.error(&#34;Missing old rating for player %i&#34;, player_id)
                continue

            old_rating = old_ratings[player_id]

            rating_change_dict = {
                &#34;player_id&#34;: player_id,
                &#34;rating_type&#34;: rating_type,
                &#34;new_rating_mean&#34;: new_rating.mean,
                &#34;new_rating_deviation&#34;: new_rating.dev,
                &#34;old_rating_mean&#34;: old_rating.mean,
                &#34;old_rating_deviation&#34;: old_rating.dev,
                &#34;outcome&#34;: outcomes[player_id].value
            }

            await self._message_queue_service.publish(
                config.MQ_EXCHANGE_NAME,
                &#34;success.rating.update&#34;,
                rating_change_dict,
            )

    async def _join_rating_queue(self) -&gt; None:
        &#34;&#34;&#34;
        Offers a call that is blocking until the rating queue has been emptied.
        Mostly for testing purposes.
        &#34;&#34;&#34;
        await self._queue.join()

    async def shutdown(self) -&gt; None:
        &#34;&#34;&#34;
        Finish rating all remaining games, then exit.
        &#34;&#34;&#34;
        self._accept_input = False
        self._logger.debug(
            &#34;Shutdown initiated. Waiting on current queue: %s&#34;, self._queue
        )
        if self._queue.empty() and self._task:
            self._task.cancel()
        await self._queue.join()
        self._task = None
        self._logger.debug(&#34;Queue emptied: %s&#34;, self._queue)

    def kill(self) -&gt; None:
        &#34;&#34;&#34;
        Exit without waiting for the queue to join.
        &#34;&#34;&#34;
        self._accept_input = False
        if self._task is not None:
            self._task.cancel()
            self._task = None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="server.core.service.Service" href="core/service.html#server.core.service.Service">Service</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="server.RatingService.enqueue"><code class="name flex">
<span>async def <span class="ident">enqueue</span></span>(<span>self, game_info: dict[str]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def enqueue(self, game_info: dict[str]) -&gt; None:
    if not self._accept_input:
        self._logger.warning(&#34;Dropped rating request %s&#34;, game_info)
        raise ServiceNotReadyError(
            &#34;RatingService not yet initialized or shutting down.&#34;
        )

    summary = GameRatingSummary.from_game_info_dict(game_info)
    self._logger.debug(&#34;Queued up rating request %s&#34;, summary)
    await self._queue.put(summary)
    rating_service_backlog.set(self._queue.qsize())</code></pre>
</details>
</dd>
<dt id="server.RatingService.kill"><code class="name flex">
<span>def <span class="ident">kill</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Exit without waiting for the queue to join.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kill(self) -&gt; None:
    &#34;&#34;&#34;
    Exit without waiting for the queue to join.
    &#34;&#34;&#34;
    self._accept_input = False
    if self._task is not None:
        self._task.cancel()
        self._task = None</code></pre>
</details>
</dd>
<dt id="server.RatingService.shutdown"><code class="name flex">
<span>async def <span class="ident">shutdown</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Finish rating all remaining games, then exit.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def shutdown(self) -&gt; None:
    &#34;&#34;&#34;
    Finish rating all remaining games, then exit.
    &#34;&#34;&#34;
    self._accept_input = False
    self._logger.debug(
        &#34;Shutdown initiated. Waiting on current queue: %s&#34;, self._queue
    )
    if self._queue.empty() and self._task:
        self._task.cancel()
    await self._queue.join()
    self._task = None
    self._logger.debug(&#34;Queue emptied: %s&#34;, self._queue)</code></pre>
</details>
</dd>
<dt id="server.RatingService.update_data"><code class="name flex">
<span>async def <span class="ident">update_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def update_data(self):
    async with self._db.acquire() as conn:
        initializer = leaderboard.alias()
        sql = select([
            leaderboard.c.id,
            leaderboard.c.technical_name,
            initializer.c.technical_name.label(&#34;initializer&#34;)
        ]).select_from(
            leaderboard.outerjoin(
                initializer,
                leaderboard.c.initializer_id == initializer.c.id
            )
        )
        result = await conn.execute(sql)
        rows = result.fetchall()

        self.leaderboards.clear()
        self._rating_type_ids = {}
        for row in rows:
            self.leaderboards[row.technical_name] = Leaderboard(
                row.id,
                row.technical_name
            )
            self._rating_type_ids[row.technical_name] = row.id

        # Link the initializers
        for row in rows:
            current = self.leaderboards[row.technical_name]
            init = self.leaderboards.get(row.initializer)
            if init:
                current.initializer = init</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="server.core.service.Service" href="core/service.html#server.core.service.Service">Service</a></b></code>:
<ul class="hlist">
<li><code><a title="server.core.service.Service.initialize" href="core/service.html#server.core.service.Service.initialize">initialize</a></code></li>
<li><code><a title="server.core.service.Service.on_connection_lost" href="core/service.html#server.core.service.Service.on_connection_lost">on_connection_lost</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="server.ServerInstance"><code class="flex name class">
<span>class <span class="ident">ServerInstance</span></span>
<span>(</span><span>name: str, database: <a title="server.db.FAFDatabase" href="db/index.html#server.db.FAFDatabase">FAFDatabase</a>, api_accessor: Optional[<a title="server.api.api_accessor.ApiAccessor" href="api/api_accessor.html#server.api.api_accessor.ApiAccessor">ApiAccessor</a>], twilio_nts: Optional[<a title="server.ice_servers.nts.TwilioNTS" href="ice_servers/nts.html#server.ice_servers.nts.TwilioNTS">TwilioNTS</a>], loop: asyncio.base_events.BaseEventLoop)</span>
</code></dt>
<dd>
<div class="desc"><p>A class representing a shared server state. Each <code><a title="server.ServerInstance" href="#server.ServerInstance">ServerInstance</a></code> may be
exposed on multiple ports, but each port will share the same internal server
state, i.e. the same players, games, etc.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ServerInstance(object):
    &#34;&#34;&#34;
    A class representing a shared server state. Each `ServerInstance` may be
    exposed on multiple ports, but each port will share the same internal server
    state, i.e. the same players, games, etc.
    &#34;&#34;&#34;

    def __init__(
        self,
        name: str,
        database: FAFDatabase,
        api_accessor: Optional[ApiAccessor],
        twilio_nts: Optional[TwilioNTS],
        loop: asyncio.BaseEventLoop,
        # For testing
        _override_services: Optional[dict[str, Service]] = None
    ):
        self.name = name
        self._logger = logging.getLogger(self.name)
        self.database = database
        self.api_accessor = api_accessor
        self.twilio_nts = twilio_nts
        self.loop = loop

        self.started = False

        self.contexts: set[ServerContext] = set()

        self.services = _override_services or create_services({
            &#34;server&#34;: self,
            &#34;database&#34;: self.database,
            &#34;api_accessor&#34;: self.api_accessor,
            &#34;loop&#34;: self.loop,
        })

        self.connection_factory = lambda: LobbyConnection(
            database=database,
            geoip=self.services[&#34;geo_ip_service&#34;],
            game_service=self.services[&#34;game_service&#34;],
            nts_client=twilio_nts,
            players=self.services[&#34;player_service&#34;],
            ladder_service=self.services[&#34;ladder_service&#34;],
            party_service=self.services[&#34;party_service&#34;],
            rating_service=self.services[&#34;rating_service&#34;],
            oauth_service=self.services[&#34;oauth_service&#34;],
        )

    def write_broadcast(
        self,
        message,
        predicate=lambda conn: conn.authenticated
    ):
        &#34;&#34;&#34;
        Queue a message to be sent to all connected clients.
        &#34;&#34;&#34;
        self._logger.log(TRACE, &#34;]]: %s&#34;, message)
        metrics.server_broadcasts.inc()

        for ctx in self.contexts:
            try:
                ctx.write_broadcast(message, predicate)
            except Exception:
                self._logger.exception(
                    &#34;Error writing &#39;%s&#39;&#34;,
                    message.get(&#34;command&#34;, message)
                )

    @synchronizedmethod
    async def start_services(self) -&gt; None:
        if self.started:
            return

        num_services = len(self.services)
        self._logger.debug(&#34;Initializing %s services&#34;, num_services)

        async def initialize(service):
            start = time.perf_counter()
            await service.initialize()
            service._logger.debug(
                &#34;%s initialized in %0.2f seconds&#34;,
                service.__class__.__name__,
                time.perf_counter() - start
            )

        await asyncio.gather(*[
            initialize(service) for service in self.services.values()
        ])

        self._logger.debug(&#34;Initialized %s services&#34;, num_services)

        self.started = True

    async def listen(
        self,
        address: tuple[str, int],
        protocol_class: type[Protocol] = QDataStreamProtocol
    ) -&gt; ServerContext:
        &#34;&#34;&#34;
        Start listening on a new address.
        &#34;&#34;&#34;
        if not self.started:
            await self.start_services()

        ctx = ServerContext(
            f&#34;{self.name}[{protocol_class.__name__}]&#34;,
            self.connection_factory,
            list(self.services.values()),
            protocol_class
        )
        self.contexts.add(ctx)

        await ctx.listen(*address)

        return ctx

    async def shutdown(self):
        results = await asyncio.gather(
            *(ctx.stop() for ctx in self.contexts),
            return_exceptions=True
        )
        for result, ctx in zip(results, self.contexts):
            if isinstance(result, BaseException):
                self._logger.error(
                    &#34;Unexpected error when stopping context %s&#34;,
                    ctx
                )

        results = await asyncio.gather(
            *(service.shutdown() for service in self.services.values()),
            return_exceptions=True
        )
        for result, service in zip(results, self.services.values()):
            if isinstance(result, BaseException):
                self._logger.error(
                    &#34;Unexpected error when shutting down service %s&#34;,
                    service
                )

        results = await asyncio.gather(
            *(ctx.shutdown() for ctx in self.contexts),
            return_exceptions=True
        )
        for result, ctx in zip(results, self.contexts):
            if isinstance(result, BaseException):
                self._logger.error(
                    &#34;Unexpected error when shutting down context %s&#34;,
                    ctx
                )

        self.contexts.clear()
        self.started = False</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="server.ServerInstance.listen"><code class="name flex">
<span>async def <span class="ident">listen</span></span>(<span>self, address: tuple[str, int], protocol_class: type[<a title="server.protocol.protocol.Protocol" href="protocol/protocol.html#server.protocol.protocol.Protocol">Protocol</a>] = server.protocol.qdatastream.QDataStreamProtocol) ‑> <a title="server.servercontext.ServerContext" href="servercontext.html#server.servercontext.ServerContext">ServerContext</a></span>
</code></dt>
<dd>
<div class="desc"><p>Start listening on a new address.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def listen(
    self,
    address: tuple[str, int],
    protocol_class: type[Protocol] = QDataStreamProtocol
) -&gt; ServerContext:
    &#34;&#34;&#34;
    Start listening on a new address.
    &#34;&#34;&#34;
    if not self.started:
        await self.start_services()

    ctx = ServerContext(
        f&#34;{self.name}[{protocol_class.__name__}]&#34;,
        self.connection_factory,
        list(self.services.values()),
        protocol_class
    )
    self.contexts.add(ctx)

    await ctx.listen(*address)

    return ctx</code></pre>
</details>
</dd>
<dt id="server.ServerInstance.shutdown"><code class="name flex">
<span>async def <span class="ident">shutdown</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def shutdown(self):
    results = await asyncio.gather(
        *(ctx.stop() for ctx in self.contexts),
        return_exceptions=True
    )
    for result, ctx in zip(results, self.contexts):
        if isinstance(result, BaseException):
            self._logger.error(
                &#34;Unexpected error when stopping context %s&#34;,
                ctx
            )

    results = await asyncio.gather(
        *(service.shutdown() for service in self.services.values()),
        return_exceptions=True
    )
    for result, service in zip(results, self.services.values()):
        if isinstance(result, BaseException):
            self._logger.error(
                &#34;Unexpected error when shutting down service %s&#34;,
                service
            )

    results = await asyncio.gather(
        *(ctx.shutdown() for ctx in self.contexts),
        return_exceptions=True
    )
    for result, ctx in zip(results, self.contexts):
        if isinstance(result, BaseException):
            self._logger.error(
                &#34;Unexpected error when shutting down context %s&#34;,
                ctx
            )

    self.contexts.clear()
    self.started = False</code></pre>
</details>
</dd>
<dt id="server.ServerInstance.start_services"><code class="name flex">
<span>async def <span class="ident">start_services</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@synchronizedmethod
async def start_services(self) -&gt; None:
    if self.started:
        return

    num_services = len(self.services)
    self._logger.debug(&#34;Initializing %s services&#34;, num_services)

    async def initialize(service):
        start = time.perf_counter()
        await service.initialize()
        service._logger.debug(
            &#34;%s initialized in %0.2f seconds&#34;,
            service.__class__.__name__,
            time.perf_counter() - start
        )

    await asyncio.gather(*[
        initialize(service) for service in self.services.values()
    ])

    self._logger.debug(&#34;Initialized %s services&#34;, num_services)

    self.started = True</code></pre>
</details>
</dd>
<dt id="server.ServerInstance.write_broadcast"><code class="name flex">
<span>def <span class="ident">write_broadcast</span></span>(<span>self, message, predicate=&lt;function ServerInstance.&lt;lambda&gt;&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Queue a message to be sent to all connected clients.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_broadcast(
    self,
    message,
    predicate=lambda conn: conn.authenticated
):
    &#34;&#34;&#34;
    Queue a message to be sent to all connected clients.
    &#34;&#34;&#34;
    self._logger.log(TRACE, &#34;]]: %s&#34;, message)
    metrics.server_broadcasts.inc()

    for ctx in self.contexts:
        try:
            ctx.write_broadcast(message, predicate)
        except Exception:
            self._logger.exception(
                &#34;Error writing &#39;%s&#39;&#34;,
                message.get(&#34;command&#34;, message)
            )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="server.ViolationService"><code class="flex name class">
<span>class <span class="ident">ViolationService</span></span>
</code></dt>
<dd>
<div class="desc"><p>Track who is banned from searching and for how long. Apply progressive
discipline for repeated violations.</p>
<p>A violation could be anything, but it is usually any time a player fails
to connect to a game.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@with_logger
class ViolationService(Service):
    &#34;&#34;&#34;
    Track who is banned from searching and for how long. Apply progressive
    discipline for repeated violations.

    A violation could be anything, but it is usually any time a player fails
    to connect to a game.
    &#34;&#34;&#34;

    def __init__(self):
        self.violations: dict[Player, Violation] = {}

    async def initialize(self):
        self._cleanup_task = at_interval(5, func=self.clear_expired)

    def clear_expired(self):
        now = datetime_now()
        for player, violation in list(self.violations.items()):
            if violation.is_expired(now):
                self._clear_violation(player)

    def register_violations(self, players: list[Player]):
        now = datetime_now()
        for player in players:
            violation = self.violations.get(player)
            if violation is None or violation.is_expired(now):
                violation = Violation(time=now)
                self.violations[player] = violation
            else:
                violation.register()

            player.write_message({
                &#34;command&#34;: &#34;search_violation&#34;,
                **violation.to_dict()
            })
            extra_text = &#34;&#34;
            if violation.count &gt; 1:
                delta_text = humanize.naturaldelta(
                    violation.get_ban_expiration() - now
                )
                extra_text = f&#34; You can queue again in {delta_text}&#34;
            player.write_message({
                &#34;command&#34;: &#34;notice&#34;,
                &#34;style&#34;: &#34;info&#34;,
                &#34;text&#34;: (
                    f&#34;You have received {violation.count} violations &#34;
                    &#34;for failing to connect to matchmaker games.&#34; +
                    extra_text
                )
            })

    def get_violations(self, players: list[Player]) -&gt; dict[Player, Violation]:
        now = datetime_now()
        result = {}
        for player in players:
            violation = self.violations.get(player)
            if not violation:
                continue
            elif violation.get_ban_expiration() &gt; now:
                result[player] = violation
            elif violation.is_expired(now):
                self._clear_violation(player)

        return result

    def _clear_violation(self, player: Player):
        violation = self.violations.get(player)
        self._logger.debug(
            &#34;Cleared violation for player %s: %s&#34;,
            player.login,
            violation
        )
        del self.violations[player]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="server.core.service.Service" href="core/service.html#server.core.service.Service">Service</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="server.ViolationService.clear_expired"><code class="name flex">
<span>def <span class="ident">clear_expired</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_expired(self):
    now = datetime_now()
    for player, violation in list(self.violations.items()):
        if violation.is_expired(now):
            self._clear_violation(player)</code></pre>
</details>
</dd>
<dt id="server.ViolationService.get_violations"><code class="name flex">
<span>def <span class="ident">get_violations</span></span>(<span>self, players: list[<a title="server.players.Player" href="players.html#server.players.Player">Player</a>]) ‑> dict[<a title="server.players.Player" href="players.html#server.players.Player">Player</a>, <a title="server.ladder_service.violation_service.Violation" href="ladder_service/violation_service.html#server.ladder_service.violation_service.Violation">Violation</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_violations(self, players: list[Player]) -&gt; dict[Player, Violation]:
    now = datetime_now()
    result = {}
    for player in players:
        violation = self.violations.get(player)
        if not violation:
            continue
        elif violation.get_ban_expiration() &gt; now:
            result[player] = violation
        elif violation.is_expired(now):
            self._clear_violation(player)

    return result</code></pre>
</details>
</dd>
<dt id="server.ViolationService.register_violations"><code class="name flex">
<span>def <span class="ident">register_violations</span></span>(<span>self, players: list[<a title="server.players.Player" href="players.html#server.players.Player">Player</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_violations(self, players: list[Player]):
    now = datetime_now()
    for player in players:
        violation = self.violations.get(player)
        if violation is None or violation.is_expired(now):
            violation = Violation(time=now)
            self.violations[player] = violation
        else:
            violation.register()

        player.write_message({
            &#34;command&#34;: &#34;search_violation&#34;,
            **violation.to_dict()
        })
        extra_text = &#34;&#34;
        if violation.count &gt; 1:
            delta_text = humanize.naturaldelta(
                violation.get_ban_expiration() - now
            )
            extra_text = f&#34; You can queue again in {delta_text}&#34;
        player.write_message({
            &#34;command&#34;: &#34;notice&#34;,
            &#34;style&#34;: &#34;info&#34;,
            &#34;text&#34;: (
                f&#34;You have received {violation.count} violations &#34;
                &#34;for failing to connect to matchmaker games.&#34; +
                extra_text
            )
        })</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="server.core.service.Service" href="core/service.html#server.core.service.Service">Service</a></b></code>:
<ul class="hlist">
<li><code><a title="server.core.service.Service.initialize" href="core/service.html#server.core.service.Service.initialize">initialize</a></code></li>
<li><code><a title="server.core.service.Service.on_connection_lost" href="core/service.html#server.core.service.Service.on_connection_lost">on_connection_lost</a></code></li>
<li><code><a title="server.core.service.Service.shutdown" href="core/service.html#server.core.service.Service.shutdown">shutdown</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#overview">Overview</a><ul>
<li><a href="#social">Social</a></li>
<li><a href="#games">Games</a><ul>
<li><a href="#custom-games">Custom Games</a></li>
<li><a href="#matchmaker-games">Matchmaker games</a></li>
<li><a href="#connectivity-establishment">Connectivity Establishment</a></li>
</ul>
</li>
<li><a href="#achievements">Achievements</a></li>
</ul>
</li>
<li><a href="#technical-overview">Technical Overview</a><ul>
<li><a href="#protocol">Protocol</a></li>
</ul>
</li>
<li><a href="#legal">Legal</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="server.api" href="api/index.html">server.api</a></code></li>
<li><code><a title="server.asyncio_extensions" href="asyncio_extensions.html">server.asyncio_extensions</a></code></li>
<li><code><a title="server.broadcast_service" href="broadcast_service.html">server.broadcast_service</a></code></li>
<li><code><a title="server.config" href="config.html">server.config</a></code></li>
<li><code><a title="server.configuration_service" href="configuration_service.html">server.configuration_service</a></code></li>
<li><code><a title="server.control" href="control.html">server.control</a></code></li>
<li><code><a title="server.core" href="core/index.html">server.core</a></code></li>
<li><code><a title="server.db" href="db/index.html">server.db</a></code></li>
<li><code><a title="server.decorators" href="decorators.html">server.decorators</a></code></li>
<li><code><a title="server.exceptions" href="exceptions.html">server.exceptions</a></code></li>
<li><code><a title="server.factions" href="factions.html">server.factions</a></code></li>
<li><code><a title="server.game_service" href="game_service.html">server.game_service</a></code></li>
<li><code><a title="server.gameconnection" href="gameconnection.html">server.gameconnection</a></code></li>
<li><code><a title="server.games" href="games/index.html">server.games</a></code></li>
<li><code><a title="server.geoip_service" href="geoip_service.html">server.geoip_service</a></code></li>
<li><code><a title="server.ice_servers" href="ice_servers/index.html">server.ice_servers</a></code></li>
<li><code><a title="server.ladder_service" href="ladder_service/index.html">server.ladder_service</a></code></li>
<li><code><a title="server.lobbyconnection" href="lobbyconnection.html">server.lobbyconnection</a></code></li>
<li><code><a title="server.matchmaker" href="matchmaker/index.html">server.matchmaker</a></code></li>
<li><code><a title="server.message_queue_service" href="message_queue_service.html">server.message_queue_service</a></code></li>
<li><code><a title="server.metrics" href="metrics.html">server.metrics</a></code></li>
<li><code><a title="server.oauth_service" href="oauth_service.html">server.oauth_service</a></code></li>
<li><code><a title="server.party_service" href="party_service.html">server.party_service</a></code></li>
<li><code><a title="server.player_service" href="player_service.html">server.player_service</a></code></li>
<li><code><a title="server.players" href="players.html">server.players</a></code></li>
<li><code><a title="server.profiler" href="profiler.html">server.profiler</a></code></li>
<li><code><a title="server.protocol" href="protocol/index.html">server.protocol</a></code></li>
<li><code><a title="server.rating" href="rating.html">server.rating</a></code></li>
<li><code><a title="server.rating_service" href="rating_service/index.html">server.rating_service</a></code></li>
<li><code><a title="server.servercontext" href="servercontext.html">server.servercontext</a></code></li>
<li><code><a title="server.stats" href="stats/index.html">server.stats</a></code></li>
<li><code><a title="server.team_matchmaker" href="team_matchmaker/index.html">server.team_matchmaker</a></code></li>
<li><code><a title="server.timing" href="timing/index.html">server.timing</a></code></li>
<li><code><a title="server.types" href="types.html">server.types</a></code></li>
<li><code><a title="server.weakattr" href="weakattr.html">server.weakattr</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="server.run_control_server" href="#server.run_control_server">run_control_server</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="server.BroadcastService" href="#server.BroadcastService">BroadcastService</a></code></h4>
<ul class="">
<li><code><a title="server.BroadcastService.broadcast_ping" href="#server.BroadcastService.broadcast_ping">broadcast_ping</a></code></li>
<li><code><a title="server.BroadcastService.report_dirties" href="#server.BroadcastService.report_dirties">report_dirties</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="server.ConfigurationService" href="#server.ConfigurationService">ConfigurationService</a></code></h4>
</li>
<li>
<h4><code><a title="server.GameConnection" href="#server.GameConnection">GameConnection</a></code></h4>
<ul class="">
<li><code><a title="server.GameConnection.abort" href="#server.GameConnection.abort">abort</a></code></li>
<li><code><a title="server.GameConnection.connect_to_host" href="#server.GameConnection.connect_to_host">connect_to_host</a></code></li>
<li><code><a title="server.GameConnection.connect_to_peer" href="#server.GameConnection.connect_to_peer">connect_to_peer</a></code></li>
<li><code><a title="server.GameConnection.disconnect_all_peers" href="#server.GameConnection.disconnect_all_peers">disconnect_all_peers</a></code></li>
<li><code><a title="server.GameConnection.game" href="#server.GameConnection.game">game</a></code></li>
<li><code><a title="server.GameConnection.handle_action" href="#server.GameConnection.handle_action">handle_action</a></code></li>
<li><code><a title="server.GameConnection.handle_ai_option" href="#server.GameConnection.handle_ai_option">handle_ai_option</a></code></li>
<li><code><a title="server.GameConnection.handle_bottleneck" href="#server.GameConnection.handle_bottleneck">handle_bottleneck</a></code></li>
<li><code><a title="server.GameConnection.handle_bottleneck_cleared" href="#server.GameConnection.handle_bottleneck_cleared">handle_bottleneck_cleared</a></code></li>
<li><code><a title="server.GameConnection.handle_chat" href="#server.GameConnection.handle_chat">handle_chat</a></code></li>
<li><code><a title="server.GameConnection.handle_clear_slot" href="#server.GameConnection.handle_clear_slot">handle_clear_slot</a></code></li>
<li><code><a title="server.GameConnection.handle_desync" href="#server.GameConnection.handle_desync">handle_desync</a></code></li>
<li><code><a title="server.GameConnection.handle_disconnected" href="#server.GameConnection.handle_disconnected">handle_disconnected</a></code></li>
<li><code><a title="server.GameConnection.handle_enforce_rating" href="#server.GameConnection.handle_enforce_rating">handle_enforce_rating</a></code></li>
<li><code><a title="server.GameConnection.handle_game_ended" href="#server.GameConnection.handle_game_ended">handle_game_ended</a></code></li>
<li><code><a title="server.GameConnection.handle_game_full" href="#server.GameConnection.handle_game_full">handle_game_full</a></code></li>
<li><code><a title="server.GameConnection.handle_game_mods" href="#server.GameConnection.handle_game_mods">handle_game_mods</a></code></li>
<li><code><a title="server.GameConnection.handle_game_option" href="#server.GameConnection.handle_game_option">handle_game_option</a></code></li>
<li><code><a title="server.GameConnection.handle_game_result" href="#server.GameConnection.handle_game_result">handle_game_result</a></code></li>
<li><code><a title="server.GameConnection.handle_game_state" href="#server.GameConnection.handle_game_state">handle_game_state</a></code></li>
<li><code><a title="server.GameConnection.handle_ice_message" href="#server.GameConnection.handle_ice_message">handle_ice_message</a></code></li>
<li><code><a title="server.GameConnection.handle_json_stats" href="#server.GameConnection.handle_json_stats">handle_json_stats</a></code></li>
<li><code><a title="server.GameConnection.handle_launch_status" href="#server.GameConnection.handle_launch_status">handle_launch_status</a></code></li>
<li><code><a title="server.GameConnection.handle_operation_complete" href="#server.GameConnection.handle_operation_complete">handle_operation_complete</a></code></li>
<li><code><a title="server.GameConnection.handle_player_option" href="#server.GameConnection.handle_player_option">handle_player_option</a></code></li>
<li><code><a title="server.GameConnection.handle_rehost" href="#server.GameConnection.handle_rehost">handle_rehost</a></code></li>
<li><code><a title="server.GameConnection.handle_teamkill_happened" href="#server.GameConnection.handle_teamkill_happened">handle_teamkill_happened</a></code></li>
<li><code><a title="server.GameConnection.handle_teamkill_report" href="#server.GameConnection.handle_teamkill_report">handle_teamkill_report</a></code></li>
<li><code><a title="server.GameConnection.is_host" href="#server.GameConnection.is_host">is_host</a></code></li>
<li><code><a title="server.GameConnection.on_connection_lost" href="#server.GameConnection.on_connection_lost">on_connection_lost</a></code></li>
<li><code><a title="server.GameConnection.player" href="#server.GameConnection.player">player</a></code></li>
<li><code><a title="server.GameConnection.send" href="#server.GameConnection.send">send</a></code></li>
<li><code><a title="server.GameConnection.state" href="#server.GameConnection.state">state</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="server.GameService" href="#server.GameService">GameService</a></code></h4>
<ul class="">
<li><code><a title="server.GameService.all_games" href="#server.GameService.all_games">all_games</a></code></li>
<li><code><a title="server.GameService.create_game" href="#server.GameService.create_game">create_game</a></code></li>
<li><code><a title="server.GameService.create_uid" href="#server.GameService.create_uid">create_uid</a></code></li>
<li><code><a title="server.GameService.initialise_game_counter" href="#server.GameService.initialise_game_counter">initialise_game_counter</a></code></li>
<li><code><a title="server.GameService.live_games" href="#server.GameService.live_games">live_games</a></code></li>
<li><code><a title="server.GameService.mark_dirty" href="#server.GameService.mark_dirty">mark_dirty</a></code></li>
<li><code><a title="server.GameService.open_games" href="#server.GameService.open_games">open_games</a></code></li>
<li><code><a title="server.GameService.pending_games" href="#server.GameService.pending_games">pending_games</a></code></li>
<li><code><a title="server.GameService.pop_dirty_games" href="#server.GameService.pop_dirty_games">pop_dirty_games</a></code></li>
<li><code><a title="server.GameService.pop_dirty_queues" href="#server.GameService.pop_dirty_queues">pop_dirty_queues</a></code></li>
<li><code><a title="server.GameService.publish_game_results" href="#server.GameService.publish_game_results">publish_game_results</a></code></li>
<li><code><a title="server.GameService.remove_game" href="#server.GameService.remove_game">remove_game</a></code></li>
<li><code><a title="server.GameService.update_active_game_metrics" href="#server.GameService.update_active_game_metrics">update_active_game_metrics</a></code></li>
<li><code><a title="server.GameService.update_data" href="#server.GameService.update_data">update_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="server.GameStatsService" href="#server.GameStatsService">GameStatsService</a></code></h4>
<ul class="">
<li><code><a title="server.GameStatsService.process_game_stats" href="#server.GameStatsService.process_game_stats">process_game_stats</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="server.GeoIpService" href="#server.GeoIpService">GeoIpService</a></code></h4>
<ul class="">
<li><code><a title="server.GeoIpService.check_geoip_db_file_updated" href="#server.GeoIpService.check_geoip_db_file_updated">check_geoip_db_file_updated</a></code></li>
<li><code><a title="server.GeoIpService.check_update_geoip_db" href="#server.GeoIpService.check_update_geoip_db">check_update_geoip_db</a></code></li>
<li><code><a title="server.GeoIpService.country" href="#server.GeoIpService.country">country</a></code></li>
<li><code><a title="server.GeoIpService.download_geoip_db" href="#server.GeoIpService.download_geoip_db">download_geoip_db</a></code></li>
<li><code><a title="server.GeoIpService.load_db" href="#server.GeoIpService.load_db">load_db</a></code></li>
<li><code><a title="server.GeoIpService.refresh_file_path" href="#server.GeoIpService.refresh_file_path">refresh_file_path</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="server.LadderService" href="#server.LadderService">LadderService</a></code></h4>
<ul class="">
<li><code><a title="server.LadderService.cancel_search" href="#server.LadderService.cancel_search">cancel_search</a></code></li>
<li><code><a title="server.LadderService.fetch_map_pools" href="#server.LadderService.fetch_map_pools">fetch_map_pools</a></code></li>
<li><code><a title="server.LadderService.fetch_matchmaker_queues" href="#server.LadderService.fetch_matchmaker_queues">fetch_matchmaker_queues</a></code></li>
<li><code><a title="server.LadderService.get_game_history" href="#server.LadderService.get_game_history">get_game_history</a></code></li>
<li><code><a title="server.LadderService.launch_match" href="#server.LadderService.launch_match">launch_match</a></code></li>
<li><code><a title="server.LadderService.on_match_found" href="#server.LadderService.on_match_found">on_match_found</a></code></li>
<li><code><a title="server.LadderService.start_game" href="#server.LadderService.start_game">start_game</a></code></li>
<li><code><a title="server.LadderService.start_search" href="#server.LadderService.start_search">start_search</a></code></li>
<li><code><a title="server.LadderService.update_data" href="#server.LadderService.update_data">update_data</a></code></li>
<li><code><a title="server.LadderService.write_rating_progress" href="#server.LadderService.write_rating_progress">write_rating_progress</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="server.MessageQueueService" href="#server.MessageQueueService">MessageQueueService</a></code></h4>
<ul class="">
<li><code><a title="server.MessageQueueService.declare_exchange" href="#server.MessageQueueService.declare_exchange">declare_exchange</a></code></li>
<li><code><a title="server.MessageQueueService.publish" href="#server.MessageQueueService.publish">publish</a></code></li>
<li><code><a title="server.MessageQueueService.reconnect" href="#server.MessageQueueService.reconnect">reconnect</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="server.OAuthService" href="#server.OAuthService">OAuthService</a></code></h4>
<ul class="">
<li><code><a title="server.OAuthService.get_player_id_from_token" href="#server.OAuthService.get_player_id_from_token">get_player_id_from_token</a></code></li>
<li><code><a title="server.OAuthService.get_public_keys" href="#server.OAuthService.get_public_keys">get_public_keys</a></code></li>
<li><code><a title="server.OAuthService.retrieve_public_keys" href="#server.OAuthService.retrieve_public_keys">retrieve_public_keys</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="server.PartyService" href="#server.PartyService">PartyService</a></code></h4>
<ul class="">
<li><code><a title="server.PartyService.accept_invite" href="#server.PartyService.accept_invite">accept_invite</a></code></li>
<li><code><a title="server.PartyService.get_party" href="#server.PartyService.get_party">get_party</a></code></li>
<li><code><a title="server.PartyService.invite_player_to_party" href="#server.PartyService.invite_player_to_party">invite_player_to_party</a></code></li>
<li><code><a title="server.PartyService.kick_player_from_party" href="#server.PartyService.kick_player_from_party">kick_player_from_party</a></code></li>
<li><code><a title="server.PartyService.leave_party" href="#server.PartyService.leave_party">leave_party</a></code></li>
<li><code><a title="server.PartyService.mark_dirty" href="#server.PartyService.mark_dirty">mark_dirty</a></code></li>
<li><code><a title="server.PartyService.remove_party" href="#server.PartyService.remove_party">remove_party</a></code></li>
<li><code><a title="server.PartyService.set_factions" href="#server.PartyService.set_factions">set_factions</a></code></li>
<li><code><a title="server.PartyService.update_dirties" href="#server.PartyService.update_dirties">update_dirties</a></code></li>
<li><code><a title="server.PartyService.write_broadcast_party" href="#server.PartyService.write_broadcast_party">write_broadcast_party</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="server.PlayerService" href="#server.PlayerService">PlayerService</a></code></h4>
<ul class="">
<li><code><a title="server.PlayerService.all_players" href="#server.PlayerService.all_players">all_players</a></code></li>
<li><code><a title="server.PlayerService.fetch_player_data" href="#server.PlayerService.fetch_player_data">fetch_player_data</a></code></li>
<li><code><a title="server.PlayerService.get_player" href="#server.PlayerService.get_player">get_player</a></code></li>
<li><code><a title="server.PlayerService.has_permission_role" href="#server.PlayerService.has_permission_role">has_permission_role</a></code></li>
<li><code><a title="server.PlayerService.is_uniqueid_exempt" href="#server.PlayerService.is_uniqueid_exempt">is_uniqueid_exempt</a></code></li>
<li><code><a title="server.PlayerService.mark_dirty" href="#server.PlayerService.mark_dirty">mark_dirty</a></code></li>
<li><code><a title="server.PlayerService.pop_dirty_players" href="#server.PlayerService.pop_dirty_players">pop_dirty_players</a></code></li>
<li><code><a title="server.PlayerService.remove_player" href="#server.PlayerService.remove_player">remove_player</a></code></li>
<li><code><a title="server.PlayerService.signal_player_rating_change" href="#server.PlayerService.signal_player_rating_change">signal_player_rating_change</a></code></li>
<li><code><a title="server.PlayerService.update_data" href="#server.PlayerService.update_data">update_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="server.RatingService" href="#server.RatingService">RatingService</a></code></h4>
<ul class="">
<li><code><a title="server.RatingService.enqueue" href="#server.RatingService.enqueue">enqueue</a></code></li>
<li><code><a title="server.RatingService.kill" href="#server.RatingService.kill">kill</a></code></li>
<li><code><a title="server.RatingService.shutdown" href="#server.RatingService.shutdown">shutdown</a></code></li>
<li><code><a title="server.RatingService.update_data" href="#server.RatingService.update_data">update_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="server.ServerInstance" href="#server.ServerInstance">ServerInstance</a></code></h4>
<ul class="">
<li><code><a title="server.ServerInstance.listen" href="#server.ServerInstance.listen">listen</a></code></li>
<li><code><a title="server.ServerInstance.shutdown" href="#server.ServerInstance.shutdown">shutdown</a></code></li>
<li><code><a title="server.ServerInstance.start_services" href="#server.ServerInstance.start_services">start_services</a></code></li>
<li><code><a title="server.ServerInstance.write_broadcast" href="#server.ServerInstance.write_broadcast">write_broadcast</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="server.ViolationService" href="#server.ViolationService">ViolationService</a></code></h4>
<ul class="">
<li><code><a title="server.ViolationService.clear_expired" href="#server.ViolationService.clear_expired">clear_expired</a></code></li>
<li><code><a title="server.ViolationService.get_violations" href="#server.ViolationService.get_violations">get_violations</a></code></li>
<li><code><a title="server.ViolationService.register_violations" href="#server.ViolationService.register_violations">register_violations</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>