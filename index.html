<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>server API documentation</title>
<meta name="description" content="Forged Alliance Forever server project …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>server</code></h1>
</header>
<section id="section-intro">
<p>Forged Alliance Forever server project</p>
<p>Copyright (c) 2012-2014 Gael Honorez
Copyright (c) 2015-2016 Michael Søndergaard <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#104;&#101;&#101;&#111;&#64;&#102;&#97;&#102;&#111;&#114;&#101;&#118;&#101;&#114;&#46;&#99;&#111;&#109;">&#115;&#104;&#101;&#101;&#111;&#64;&#102;&#97;&#102;&#111;&#114;&#101;&#118;&#101;&#114;&#46;&#99;&#111;&#109;</a></p>
<p>Distributed under GPLv3, see license.txt</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Forged Alliance Forever server project

Copyright (c) 2012-2014 Gael Honorez
Copyright (c) 2015-2016 Michael Søndergaard &lt;sheeo@faforever.com&gt;

Distributed under GPLv3, see license.txt
&#34;&#34;&#34;
import asyncio
import logging
from typing import Dict, Optional, Set, Tuple, Type

from prometheus_client import start_http_server

import server.metrics as metrics

from .api.api_accessor import ApiAccessor
from .asyncio_extensions import synchronizedmethod
from .config import TRACE, config
from .configuration_service import ConfigurationService
from .control import run_control_server
from .core import Service, create_services
from .db import FAFDatabase
from .game_service import GameService
from .gameconnection import GameConnection
from .games import GameState
from .geoip_service import GeoIpService
from .ice_servers.nts import TwilioNTS
from .ladder_service import LadderService
from .lobbyconnection import LobbyConnection
from .message_queue_service import MessageQueueService
from .party_service import PartyService
from .player_service import PlayerService
from .protocol import Protocol, QDataStreamProtocol
from .rating_service.rating_service import RatingService
from .servercontext import ServerContext
from .stats.game_stats_service import GameStatsService
from .timing import at_interval

__author__ = &#34;Askaholic, Chris Kitching, Dragonfire, Gael Honorez, Jeroen De Dauw, Crotalus, Michael Søndergaard, Michel Jung&#34;
__contact__ = &#34;admin@faforever.com&#34;
__license__ = &#34;GPLv3&#34;
__copyright__ = &#34;Copyright (c) 2011-2015 &#34; + __author__

__all__ = (
    &#34;ConfigurationService&#34;,
    &#34;GameConnection&#34;,
    &#34;GameService&#34;,
    &#34;GameStatsService&#34;,
    &#34;GeoIpService&#34;,
    &#34;LadderService&#34;,
    &#34;MessageQueueService&#34;,
    &#34;PartyService&#34;,
    &#34;RatingService&#34;,
    &#34;RatingService&#34;,
    &#34;ServerInstance&#34;,
    &#34;abc&#34;,
    &#34;control&#34;,
    &#34;game_service&#34;,
    &#34;protocol&#34;,
    &#34;run_control_server&#34;,
)

DIRTY_REPORT_INTERVAL = 1  # Seconds
logger = logging.getLogger(&#34;server&#34;)

if config.ENABLE_METRICS:
    logger.info(&#34;Using prometheus on port: %i&#34;, config.METRICS_PORT)
    start_http_server(config.METRICS_PORT)


class ServerInstance(object):
    &#34;&#34;&#34;
        A class representing a shared server state. Each ServerInstance may be
    exposed on multiple ports, but each port will share the same internal server
    state, i.e. the same players, games, etc.
    &#34;&#34;&#34;

    def __init__(
        self,
        name: str,
        database: FAFDatabase,
        api_accessor: Optional[ApiAccessor],
        twilio_nts: Optional[TwilioNTS],
        loop: asyncio.BaseEventLoop,
        # For testing
        _override_services: Optional[Dict[str, Service]] = None
    ):
        self.name = name
        self._logger = logging.getLogger(self.name)
        self.database = database
        self.api_accessor = api_accessor
        self.twilio_nts = twilio_nts
        self.loop = loop

        self.started = False

        self.contexts: Set[ServerContext] = set()

        self.services = _override_services or create_services({
            &#34;database&#34;: self.database,
            &#34;api_accessor&#34;: self.api_accessor,
            &#34;loop&#34;: self.loop,
        })

        self.connection_factory = lambda: LobbyConnection(
            database=database,
            geoip=self.services[&#34;geo_ip_service&#34;],
            game_service=self.services[&#34;game_service&#34;],
            nts_client=twilio_nts,
            players=self.services[&#34;player_service&#34;],
            ladder_service=self.services[&#34;ladder_service&#34;],
            party_service=self.services[&#34;party_service&#34;]
        )

    def write_broadcast(self, message, predicate=lambda conn: conn.authenticated):
        self._logger.log(TRACE, &#34;]]: %s&#34;, message)
        metrics.server_broadcasts.inc()

        for ctx in self.contexts:
            try:
                ctx.write_broadcast(message, predicate)
            except Exception:
                self._logger.exception(
                    &#34;Error writing &#39;%s&#39;&#34;,
                    message.get(&#34;command&#34;, message)
                )

    @synchronizedmethod
    async def _start_services(self) -&gt; None:
        if self.started:
            return

        await asyncio.gather(*[
            service.initialize() for service in self.services.values()
        ])

        game_service: GameService = self.services[&#34;game_service&#34;]
        player_service: PlayerService = self.services[&#34;player_service&#34;]

        @at_interval(DIRTY_REPORT_INTERVAL, loop=self.loop)
        def do_report_dirties():
            game_service.update_active_game_metrics()
            dirty_games = game_service.dirty_games
            dirty_queues = game_service.dirty_queues
            dirty_players = player_service.dirty_players
            game_service.clear_dirty()
            player_service.clear_dirty()

            if dirty_queues:
                self.write_broadcast({
                    &#34;command&#34;: &#34;matchmaker_info&#34;,
                    &#34;queues&#34;: [queue.to_dict() for queue in dirty_queues]
                })

            if dirty_players:
                self.write_broadcast(
                    {
                        &#34;command&#34;: &#34;player_info&#34;,
                        &#34;players&#34;: [player.to_dict() for player in dirty_players]
                    },
                    lambda lobby_conn: lobby_conn.authenticated
                )

            # TODO: This spams squillions of messages: we should implement per-
            # connection message aggregation at the next abstraction layer down :P
            for game in dirty_games:
                if game.state == GameState.ENDED:
                    game_service.remove_game(game)

                # So we&#39;re going to be broadcasting this to _somebody_...
                message = game.to_dict()

                self.write_broadcast(
                    message,
                    lambda conn: (
                        conn.authenticated
                        and game.is_visible_to_player(conn.player)
                    )
                )

        @at_interval(45, loop=self.loop)
        def ping_broadcast():
            self.write_broadcast({&#34;command&#34;: &#34;ping&#34;})

        self.started = True

    async def listen(
        self,
        address: Tuple[str, int],
        protocol_class: Type[Protocol] = QDataStreamProtocol
    ) -&gt; ServerContext:
        &#34;&#34;&#34;
        Start listening on a new address.
        &#34;&#34;&#34;
        if not self.started:
            await self._start_services()

        ctx = ServerContext(
            f&#34;{self.name}[{protocol_class.__name__}]&#34;,
            self.connection_factory,
            list(self.services.values()),
            protocol_class
        )
        self.contexts.add(ctx)

        await ctx.listen(*address)

        return ctx

    async def shutdown(self):
        for ctx in self.contexts:
            ctx.close()

        for ctx in self.contexts:
            try:
                await ctx.wait_closed()
            except Exception:
                self._logger.error(
                    &#34;Encountered unexpected error when trying to shut down &#34;
                    &#34;context %s&#34;,
                    ctx
                )

        await asyncio.gather(*[
            service.shutdown() for service in self.services.values()
        ])

        self.started = False</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="server.abc" href="abc/index.html">server.abc</a></code></dt>
<dd>
<div class="desc"><p>Abstract base classes</p></div>
</dd>
<dt><code class="name"><a title="server.api" href="api/index.html">server.api</a></code></dt>
<dd>
<div class="desc"><p>API connector</p></div>
</dd>
<dt><code class="name"><a title="server.asyncio_extensions" href="asyncio_extensions.html">server.asyncio_extensions</a></code></dt>
<dd>
<div class="desc"><p>Some helper functions for common async tasks.</p></div>
</dd>
<dt><code class="name"><a title="server.config" href="config.html">server.config</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="server.configuration_service" href="configuration_service.html">server.configuration_service</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="server.control" href="control.html">server.control</a></code></dt>
<dd>
<div class="desc"><p>Tiny local-only http server for getting stats and performing various tasks</p></div>
</dd>
<dt><code class="name"><a title="server.core" href="core/index.html">server.core</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="server.db" href="db/index.html">server.db</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="server.decorators" href="decorators.html">server.decorators</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="server.exceptions" href="exceptions.html">server.exceptions</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="server.factions" href="factions.html">server.factions</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="server.game_service" href="game_service.html">server.game_service</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="server.gameconnection" href="gameconnection.html">server.gameconnection</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="server.games" href="games/index.html">server.games</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="server.geoip_service" href="geoip_service.html">server.geoip_service</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="server.ice_servers" href="ice_servers/index.html">server.ice_servers</a></code></dt>
<dd>
<div class="desc"><p>ICE server configuration</p></div>
</dd>
<dt><code class="name"><a title="server.ladder_service" href="ladder_service.html">server.ladder_service</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="server.lobbyconnection" href="lobbyconnection.html">server.lobbyconnection</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="server.matchmaker" href="matchmaker/index.html">server.matchmaker</a></code></dt>
<dd>
<div class="desc"><p>The matchmaker system …</p></div>
</dd>
<dt><code class="name"><a title="server.message_queue_service" href="message_queue_service.html">server.message_queue_service</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="server.metrics" href="metrics.html">server.metrics</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="server.party_service" href="party_service.html">server.party_service</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="server.player_service" href="player_service.html">server.player_service</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="server.players" href="players.html">server.players</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="server.profiler" href="profiler.html">server.profiler</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="server.protocol" href="protocol/index.html">server.protocol</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="server.rating" href="rating.html">server.rating</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="server.rating_service" href="rating_service/index.html">server.rating_service</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="server.servercontext" href="servercontext.html">server.servercontext</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="server.stats" href="stats/index.html">server.stats</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="server.team_matchmaker" href="team_matchmaker/index.html">server.team_matchmaker</a></code></dt>
<dd>
<div class="desc"><p>The team matchmaking system …</p></div>
</dd>
<dt><code class="name"><a title="server.timing" href="timing/index.html">server.timing</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="server.types" href="types.html">server.types</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="server.weakattr" href="weakattr.html">server.weakattr</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="server.run_control_server"><code class="name flex">
<span>async def <span class="ident">run_control_server</span></span>(<span>player_service: <a title="server.player_service.PlayerService" href="player_service.html#server.player_service.PlayerService">PlayerService</a>, game_service: <a title="server.game_service.GameService" href="game_service.html#server.game_service.GameService">GameService</a>) ‑> <a title="server.control.ControlServer" href="control.html#server.control.ControlServer">ControlServer</a></span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the http control server</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def run_control_server(
    player_service: PlayerService,
    game_service: GameService
) -&gt; ControlServer:
    &#34;&#34;&#34;
    Initialize the http control server
    &#34;&#34;&#34;
    host = socket.gethostbyname(socket.gethostname())
    port = config.CONTROL_SERVER_PORT

    ctrl_server = ControlServer(game_service, player_service, host, port)
    await ctrl_server.start()

    return ctrl_server</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="server.ConfigurationService"><code class="flex name class">
<span>class <span class="ident">ConfigurationService</span></span>
</code></dt>
<dd>
<div class="desc"><p>All services should inherit from this class.</p>
<p>Services are singleton objects which manage some server task.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConfigurationService(Service):
    def __init__(self) -&gt; None:
        self._logger.info(&#34;Configuration service created.&#34;)
        self._store = config
        self._task = None

    async def initialize(self) -&gt; None:
        self._task = asyncio.create_task(self._worker_loop())
        self._logger.info(&#34;Configuration service started.&#34;)

    async def _worker_loop(self) -&gt; None:
        while True:
            self._logger.debug(&#34;Refreshing configuration variables&#34;)
            self._store.refresh()
            await asyncio.sleep(self._store.CONFIGURATION_REFRESH_TIME)

    async def shutdown(self) -&gt; None:
        if self._task is not None:
            self._logger.info(&#34;Configuration service stopping.&#34;)
            self._task.cancel()
        self._task = None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="server.core.service.Service" href="core/service.html#server.core.service.Service">Service</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="server.ConfigurationService.services"><code class="name">var <span class="ident">services</span> : Dict[str, type]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="server.core.service.Service" href="core/service.html#server.core.service.Service">Service</a></b></code>:
<ul class="hlist">
<li><code><a title="server.core.service.Service.initialize" href="core/service.html#server.core.service.Service.initialize">initialize</a></code></li>
<li><code><a title="server.core.service.Service.on_connection_lost" href="core/service.html#server.core.service.Service.on_connection_lost">on_connection_lost</a></code></li>
<li><code><a title="server.core.service.Service.shutdown" href="core/service.html#server.core.service.Service.shutdown">shutdown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="server.GameConnection"><code class="flex name class">
<span>class <span class="ident">GameConnection</span></span>
<span>(</span><span>database: <a title="server.db.FAFDatabase" href="db/index.html#server.db.FAFDatabase">FAFDatabase</a>, game: <a title="server.games.game.Game" href="games/game.html#server.games.game.Game">Game</a>, player: <a title="server.players.Player" href="players.html#server.players.Player">Player</a>, protocol: <a title="server.protocol.protocol.Protocol" href="protocol/protocol.html#server.protocol.protocol.Protocol">Protocol</a>, player_service: <a title="server.player_service.PlayerService" href="player_service.html#server.player_service.PlayerService">PlayerService</a>, games: <a title="server.game_service.GameService" href="game_service.html#server.game_service.GameService">GameService</a>, state: <a title="server.abc.base_game.GameConnectionState" href="abc/base_game.html#server.abc.base_game.GameConnectionState">GameConnectionState</a> = GameConnectionState.INITIALIZING)</span>
</code></dt>
<dd>
<div class="desc"><p>Responsible for connections to the game, using the GPGNet protocol</p>
<p>Construct a new GameConnection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GameConnection(GpgNetServerProtocol):
    &#34;&#34;&#34;
    Responsible for connections to the game, using the GPGNet protocol
    &#34;&#34;&#34;

    def __init__(
        self,
        database: FAFDatabase,
        game: Game,
        player: Player,
        protocol: Protocol,
        player_service: PlayerService,
        games: GameService,
        state: GameConnectionState = GameConnectionState.INITIALIZING
    ):
        &#34;&#34;&#34;
        Construct a new GameConnection
        &#34;&#34;&#34;
        super().__init__()
        self._db = database
        self._logger.debug(&#34;GameConnection initializing&#34;)

        self.protocol = protocol
        self._state = state
        self.game_service = games
        self.player_service = player_service

        self._player = player
        player.game_connection = self  # Set up weak reference to self
        self._game = game

        self.finished_sim = False

    @property
    def state(self) -&gt; GameConnectionState:
        return self._state

    @property
    def game(self) -&gt; Game:
        return self._game

    @game.setter
    def game(self, val: Game):
        self._game = val

    @property
    def player(self) -&gt; Player:
        return self._player

    @player.setter
    def player(self, val: Player):
        self._player = val

    def is_host(self) -&gt; bool:
        if not self.game or not self.player:
            return False

        return (
            self.player.state == PlayerState.HOSTING and
            self.player == self.game.host
        )

    async def send(self, message):
        &#34;&#34;&#34;
        Send a game message to the client.

        :raises: DisconnectedError

        NOTE: When calling this on a connection other than `self` make sure to
        handle `DisconnectedError`, otherwise failure to send the message will
        cause the caller to be disconnected as well.
        &#34;&#34;&#34;
        message[&#34;target&#34;] = &#34;game&#34;

        self._logger.log(TRACE, &#34;&gt;&gt; %s: %s&#34;, self.player.login, message)
        await self.protocol.send_message(message)

    async def _handle_idle_state(self):
        &#34;&#34;&#34;
        This message is sent by FA when it doesn&#39;t know what to do.
        :return: None
        &#34;&#34;&#34;
        assert self.game
        state = self.player.state

        if state == PlayerState.HOSTING:
            self.game.state = GameState.LOBBY
            self._state = GameConnectionState.CONNECTED_TO_HOST
            self.game.add_game_connection(self)
            self.game.host = self.player
        elif state == PlayerState.JOINING:
            return
        else:
            self._logger.error(&#34;Unknown PlayerState: %s&#34;, state)
            await self.abort()

    async def _handle_lobby_state(self):
        &#34;&#34;&#34;
        The game has told us it is ready and listening on
        self.player.game_port for UDP.
        We determine the connectivity of the peer and respond
        appropriately
        &#34;&#34;&#34;
        player_state = self.player.state
        if player_state == PlayerState.HOSTING:
            await self.send_HostGame(self.game.map_folder_name)
            self.game.set_hosted()
        # If the player is joining, we connect him to host
        # followed by the rest of the players.
        elif player_state == PlayerState.JOINING:
            await self.connect_to_host(self.game.host.game_connection)

            if self._state is GameConnectionState.ENDED:
                # We aborted while trying to connect
                return

            self._state = GameConnectionState.CONNECTED_TO_HOST

            try:
                self.game.add_game_connection(self)
            except GameError as e:
                await self.abort(f&#34;GameError while joining {self.game.id}: {e}&#34;)
                return

            tasks = []
            for peer in self.game.connections:
                if peer != self and peer.player != self.game.host:
                    self._logger.debug(&#34;%s connecting to %s&#34;, self.player, peer)
                    tasks.append(self.connect_to_peer(peer))
            await asyncio.gather(*tasks)

    async def connect_to_host(self, peer: &#34;GameConnection&#34;):
        &#34;&#34;&#34;
        Connect self to a given peer (host)
        :return:
        &#34;&#34;&#34;
        if not peer or peer.player.state != PlayerState.HOSTING:
            await self.abort(&#34;The host left the lobby&#34;)
            return

        await self.send_JoinGame(peer.player.login, peer.player.id)

        if not peer:
            await self.abort(&#34;The host left the lobby&#34;)
            return

        await peer.send_ConnectToPeer(
            player_name=self.player.login,
            player_uid=self.player.id,
            offer=True
        )

    async def connect_to_peer(self, peer: &#34;GameConnection&#34;):
        &#34;&#34;&#34;
        Connect two peers
        :return: None
        &#34;&#34;&#34;
        if peer is not None:
            await self.send_ConnectToPeer(
                player_name=peer.player.login,
                player_uid=peer.player.id,
                offer=True
            )

        if peer is not None:
            with contextlib.suppress(DisconnectedError):
                await peer.send_ConnectToPeer(
                    player_name=self.player.login,
                    player_uid=self.player.id,
                    offer=False
                )

    async def handle_action(self, command, args):
        &#34;&#34;&#34;
        Handle GpgNetSend messages, wrapped in the JSON protocol
        :param command: command type
        :param args: command arguments
        :return: None
        &#34;&#34;&#34;
        try:
            await COMMAND_HANDLERS[command](self, *args)
        except KeyError:
            self._logger.warning(
                &#34;Unrecognized command %s: %s from player %s&#34;,
                command, args, self.player
            )
        except (TypeError, ValueError):
            self._logger.exception(&#34;Bad command arguments&#34;)
        except ConnectionError as e:
            raise e
        except Exception:  # pragma: no cover
            self._logger.exception(&#34;Something awful happened in a game thread!&#34;)
            await self.abort()

    async def handle_desync(self, *_args):  # pragma: no cover
        self.game.desyncs += 1

    async def handle_game_option(self, key, value):
        if not self.is_host():
            return

        if key == &#34;Victory&#34;:
            self.game.gameOptions[&#34;Victory&#34;] = Victory.__members__.get(
                value.upper(), None
            )
        else:
            self.game.gameOptions[key] = value

        if key == &#34;Slots&#34;:
            self.game.max_players = int(value)
        elif key == &#34;ScenarioFile&#34;:
            raw = repr(value)
            self.game.map_scenario_path = \
                raw.replace(&#34;\\&#34;, &#34;/&#34;).replace(&#34;//&#34;, &#34;/&#34;).replace(&#34;&#39;&#34;, &#34;&#34;)
            self.game.map_file_path = &#34;maps/{}.zip&#34;.format(
                self.game.map_scenario_path.split(&#34;/&#34;)[2].lower()
            )
        elif key == &#34;Title&#34;:
            with contextlib.suppress(ValueError):
                self.game.name = value

        self._mark_dirty()

    async def handle_game_mods(self, mode, args):
        if not self.is_host():
            return

        if mode == &#34;activated&#34;:
            # In this case args is the number of mods
            if int(args) == 0:
                self.game.mods = {}

        elif mode == &#34;uids&#34;:
            uids = str(args).split()
            self.game.mods = {uid: &#34;Unknown sim mod&#34; for uid in uids}
            async with self._db.acquire() as conn:
                result = await conn.execute(
                    text(&#34;SELECT `uid`, `name` from `table_mod` WHERE `uid` in :ids&#34;),
                    ids=tuple(uids))
                async for row in result:
                    self.game.mods[row[&#34;uid&#34;]] = row[&#34;name&#34;]
        else:
            self._logger.warning(&#34;Ignoring game mod: %s, %s&#34;, mode, args)
            return

        self._mark_dirty()

    async def handle_player_option(self, player_id, command, value):
        if not self.is_host():
            return

        self.game.set_player_option(int(player_id), command, value)
        self._mark_dirty()

    async def handle_ai_option(self, name, key, value):
        if not self.is_host():
            return

        self.game.set_ai_option(str(name), key, value)
        self._mark_dirty()

    async def handle_clear_slot(self, slot):
        if not self.is_host():
            return

        self.game.clear_slot(int(slot))
        self._mark_dirty()

    async def handle_game_result(self, army, result):
        army = int(army)
        result = str(result).lower()
        try:
            label, score = result.split(&#34; &#34;)[-2:]
            await self.game.add_result(self.player.id, army, label, int(score))
        except (KeyError, ValueError):  # pragma: no cover
            self._logger.warning(&#34;Invalid result for %s reported: %s&#34;, army, result)

    async def handle_operation_complete(self, army, secondary, delta):
        if not int(army) == 1:
            return

        if self.game.validity != ValidityState.COOP_NOT_RANKED:
            return

        secondary, delta = int(secondary), str(delta)
        async with self._db.acquire() as conn:
            # FIXME: Resolve used map earlier than this
            result = await conn.execute(
                select([coop_map.c.id]).where(
                    coop_map.c.filename == self.game.map_file_path
                )
            )
            row = await result.fetchone()
            if not row:
                self._logger.debug(&#34;can&#39;t find coop map: %s&#34;, self.game.map_file_path)
                return
            mission = row[&#34;id&#34;]

            await conn.execute(
                coop_leaderboard.insert().values(
                    mission=mission,
                    gameuid=self.game.id,
                    secondary=secondary,
                    time=delta,
                    player_count=len(self.game.players),
                )
            )

    async def handle_json_stats(self, stats):
        self.game.report_army_stats(stats)

    async def handle_enforce_rating(self):
        self.game.enforce_rating = True

    async def handle_teamkill_report(self, gametime, reporter_id, reporter_name, teamkiller_id, teamkiller_name):
        &#34;&#34;&#34;
            Sent when a player is teamkilled and clicks the &#39;Report&#39; button.

            :param gametime: seconds of gametime when kill happened
            :param reporter_id: reporter id
            :param reporter_name: reporter nickname (for debug purpose only)
            :param teamkiller_id: teamkiller id
            :param teamkiller_name: teamkiller nickname (for debug purpose only)
        &#34;&#34;&#34;

        pass

    async def handle_teamkill_happened(self, gametime, victim_id, victim_name, teamkiller_id, teamkiller_name):
        &#34;&#34;&#34;
            Send automatically by the game whenever a teamkill happens. Takes
            the same parameters as TeamkillReport.

            :param gametime: seconds of gametime when kill happened
            :param victim_id: victim id
            :param victim_name: victim nickname (for debug purpose only)
            :param teamkiller_id: teamkiller id
            :param teamkiller_name: teamkiller nickname (for debug purpose only)
        &#34;&#34;&#34;
        victim_id = int(victim_id)
        teamkiller_id = int(teamkiller_id)

        if 0 in (victim_id, teamkiller_id):
            self._logger.debug(&#34;Ignoring teamkill for AI player&#34;)
            return

        async with self._db.acquire() as conn:
            await conn.execute(
                teamkills.insert().values(
                    teamkiller=teamkiller_id,
                    victim=victim_id,
                    game_id=self.game.id,
                    gametime=gametime,
                )
            )

    async def handle_ice_message(self, receiver_id, ice_msg):
        receiver_id = int(receiver_id)
        peer = self.player_service.get_player(receiver_id)
        if not peer:
            self._logger.debug(
                &#34;Ignoring ICE message for unknown player: %s&#34;, receiver_id
            )
            return

        game_connection = peer.game_connection
        if not game_connection:
            self._logger.debug(
                &#34;Ignoring ICE message for player without game connection: %s&#34;, receiver_id
            )
            return

        try:
            await game_connection.send({
                &#34;command&#34;: &#34;IceMsg&#34;,
                &#34;args&#34;: [int(self.player.id), ice_msg]
            })
        except DisconnectedError:
            self._logger.debug(
                &#34;Failed to send ICE message to player due to a disconnect: %s&#34;,
                receiver_id
            )

    async def handle_game_state(self, state):
        &#34;&#34;&#34;
        Changes in game state
        :param state: new state
        :return: None
        &#34;&#34;&#34;

        if state == &#34;Idle&#34;:
            await self._handle_idle_state()
            # Don&#39;t mark as dirty
            return

        elif state == &#34;Lobby&#34;:
            # TODO: Do we still need to schedule with `ensure_future`?
            #
            # We do not yield from the task, since we
            # need to keep processing other commands while it runs
            await self._handle_lobby_state()

        elif state == &#34;Launching&#34;:
            if self.player.state != PlayerState.HOSTING:
                return

            self._logger.info(
                &#34;Launching game %s in state %s&#34;,
                self.game,
                self.game.state
            )

            await self.game.launch()

            if len(self.game.mods.keys()) &gt; 0:
                async with self._db.acquire() as conn:
                    uids = list(self.game.mods.keys())
                    await conn.execute(text(
                        &#34;&#34;&#34; UPDATE mod_stats s JOIN mod_version v ON v.mod_id = s.mod_id
                            SET s.times_played = s.times_played + 1 WHERE v.uid in :ids&#34;&#34;&#34;),
                        ids=tuple(uids)
                    )
        elif state == &#34;Ended&#34;:
            await self.on_connection_lost()
        self._mark_dirty()

    async def handle_game_ended(self, *args):
        &#34;&#34;&#34;
        Signals that the simulation has ended.
        &#34;&#34;&#34;
        self.finished_sim = True
        await self.game.check_sim_end()

        # FIXME Move this into check_sim_end
        if self.game.ended:
            await self.game.on_game_end()

    async def handle_rehost(self, *args):
        &#34;&#34;&#34;
        Signals that the user has rehosted the game. This is currently unused but
        included for documentation purposes.
        &#34;&#34;&#34;
        pass

    async def handle_bottleneck(self, *args):
        &#34;&#34;&#34;
        Not sure what this command means. This is currently unused but
        included for documentation purposes.
        &#34;&#34;&#34;
        pass

    async def handle_bottleneck_cleared(self, *args):
        &#34;&#34;&#34;
        Not sure what this command means. This is currently unused but
        included for documentation purposes.
        &#34;&#34;&#34;
        pass

    async def handle_disconnected(self, *args):
        &#34;&#34;&#34;
        Not sure what this command means. This is currently unused but
        included for documentation purposes.
        &#34;&#34;&#34;
        pass

    async def handle_chat(self, message: str):
        &#34;&#34;&#34;
        Whenever the player sends a chat message during the game lobby.
        &#34;&#34;&#34;
        pass

    async def handle_game_full(self):
        &#34;&#34;&#34;
        Sent when all game slots are full
        &#34;&#34;&#34;
        pass

    def _mark_dirty(self):
        if self.game:
            self.game_service.mark_dirty(self.game)

    async def abort(self, log_message: str = &#34;&#34;):
        &#34;&#34;&#34;
        Abort the connection

        Removes the GameConnection object from the any associated Game object,
        and deletes references to Player and Game held by this object.
        &#34;&#34;&#34;
        try:
            if self._state is GameConnectionState.ENDED:
                return

            self._logger.debug(&#34;%s.abort(%s)&#34;, self, log_message)

            if self.game.state is GameState.LOBBY:
                await self.disconnect_all_peers()

            self._state = GameConnectionState.ENDED
            await self.game.remove_game_connection(self)
            self._mark_dirty()
            self.player.state = PlayerState.IDLE
            if self.player.lobby_connection:
                self.player.lobby_connection.game_connection = None
            del self.player.game
            del self.player.game_connection
        except Exception as ex:  # pragma: no cover
            self._logger.debug(&#34;Exception in abort(): %s&#34;, ex)

    async def disconnect_all_peers(self):
        tasks = []
        for peer in self.game.connections:
            if peer == self:
                continue

            tasks.append(peer.send_DisconnectFromPeer(self.player.id))

        for fut in asyncio.as_completed(tasks):
            try:
                await fut
            except Exception:
                self._logger.debug(
                    &#34;peer_sendDisconnectFromPeer failed for player %i&#34;,
                    self.player.id,
                    exc_info=True
                )

    async def on_connection_lost(self):
        try:
            await self.game.remove_game_connection(self)
        except Exception as e:  # pragma: no cover
            self._logger.exception(e)
        finally:
            await self.abort()

    def __str__(self):
        return &#34;GameConnection({}, {})&#34;.format(self.player, self.game)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="server.protocol.gpgnet.GpgNetServerProtocol" href="protocol/gpgnet.html#server.protocol.gpgnet.GpgNetServerProtocol">GpgNetServerProtocol</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="server.GameConnection.game"><code class="name">var <span class="ident">game</span> : <a title="server.games.game.Game" href="games/game.html#server.games.game.Game">Game</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def game(self) -&gt; Game:
    return self._game</code></pre>
</details>
</dd>
<dt id="server.GameConnection.player"><code class="name">var <span class="ident">player</span> : <a title="server.players.Player" href="players.html#server.players.Player">Player</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def player(self) -&gt; Player:
    return self._player</code></pre>
</details>
</dd>
<dt id="server.GameConnection.state"><code class="name">var <span class="ident">state</span> : <a title="server.abc.base_game.GameConnectionState" href="abc/base_game.html#server.abc.base_game.GameConnectionState">GameConnectionState</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def state(self) -&gt; GameConnectionState:
    return self._state</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="server.GameConnection.abort"><code class="name flex">
<span>async def <span class="ident">abort</span></span>(<span>self, log_message: str = '')</span>
</code></dt>
<dd>
<div class="desc"><p>Abort the connection</p>
<p>Removes the GameConnection object from the any associated Game object,
and deletes references to Player and Game held by this object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def abort(self, log_message: str = &#34;&#34;):
    &#34;&#34;&#34;
    Abort the connection

    Removes the GameConnection object from the any associated Game object,
    and deletes references to Player and Game held by this object.
    &#34;&#34;&#34;
    try:
        if self._state is GameConnectionState.ENDED:
            return

        self._logger.debug(&#34;%s.abort(%s)&#34;, self, log_message)

        if self.game.state is GameState.LOBBY:
            await self.disconnect_all_peers()

        self._state = GameConnectionState.ENDED
        await self.game.remove_game_connection(self)
        self._mark_dirty()
        self.player.state = PlayerState.IDLE
        if self.player.lobby_connection:
            self.player.lobby_connection.game_connection = None
        del self.player.game
        del self.player.game_connection
    except Exception as ex:  # pragma: no cover
        self._logger.debug(&#34;Exception in abort(): %s&#34;, ex)</code></pre>
</details>
</dd>
<dt id="server.GameConnection.connect_to_host"><code class="name flex">
<span>async def <span class="ident">connect_to_host</span></span>(<span>self, peer: <a title="server.GameConnection" href="#server.GameConnection">GameConnection</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Connect self to a given peer (host)
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def connect_to_host(self, peer: &#34;GameConnection&#34;):
    &#34;&#34;&#34;
    Connect self to a given peer (host)
    :return:
    &#34;&#34;&#34;
    if not peer or peer.player.state != PlayerState.HOSTING:
        await self.abort(&#34;The host left the lobby&#34;)
        return

    await self.send_JoinGame(peer.player.login, peer.player.id)

    if not peer:
        await self.abort(&#34;The host left the lobby&#34;)
        return

    await peer.send_ConnectToPeer(
        player_name=self.player.login,
        player_uid=self.player.id,
        offer=True
    )</code></pre>
</details>
</dd>
<dt id="server.GameConnection.connect_to_peer"><code class="name flex">
<span>async def <span class="ident">connect_to_peer</span></span>(<span>self, peer: <a title="server.GameConnection" href="#server.GameConnection">GameConnection</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Connect two peers
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def connect_to_peer(self, peer: &#34;GameConnection&#34;):
    &#34;&#34;&#34;
    Connect two peers
    :return: None
    &#34;&#34;&#34;
    if peer is not None:
        await self.send_ConnectToPeer(
            player_name=peer.player.login,
            player_uid=peer.player.id,
            offer=True
        )

    if peer is not None:
        with contextlib.suppress(DisconnectedError):
            await peer.send_ConnectToPeer(
                player_name=self.player.login,
                player_uid=self.player.id,
                offer=False
            )</code></pre>
</details>
</dd>
<dt id="server.GameConnection.disconnect_all_peers"><code class="name flex">
<span>async def <span class="ident">disconnect_all_peers</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def disconnect_all_peers(self):
    tasks = []
    for peer in self.game.connections:
        if peer == self:
            continue

        tasks.append(peer.send_DisconnectFromPeer(self.player.id))

    for fut in asyncio.as_completed(tasks):
        try:
            await fut
        except Exception:
            self._logger.debug(
                &#34;peer_sendDisconnectFromPeer failed for player %i&#34;,
                self.player.id,
                exc_info=True
            )</code></pre>
</details>
</dd>
<dt id="server.GameConnection.handle_action"><code class="name flex">
<span>async def <span class="ident">handle_action</span></span>(<span>self, command, args)</span>
</code></dt>
<dd>
<div class="desc"><p>Handle GpgNetSend messages, wrapped in the JSON protocol
:param command: command type
:param args: command arguments
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_action(self, command, args):
    &#34;&#34;&#34;
    Handle GpgNetSend messages, wrapped in the JSON protocol
    :param command: command type
    :param args: command arguments
    :return: None
    &#34;&#34;&#34;
    try:
        await COMMAND_HANDLERS[command](self, *args)
    except KeyError:
        self._logger.warning(
            &#34;Unrecognized command %s: %s from player %s&#34;,
            command, args, self.player
        )
    except (TypeError, ValueError):
        self._logger.exception(&#34;Bad command arguments&#34;)
    except ConnectionError as e:
        raise e
    except Exception:  # pragma: no cover
        self._logger.exception(&#34;Something awful happened in a game thread!&#34;)
        await self.abort()</code></pre>
</details>
</dd>
<dt id="server.GameConnection.handle_ai_option"><code class="name flex">
<span>async def <span class="ident">handle_ai_option</span></span>(<span>self, name, key, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_ai_option(self, name, key, value):
    if not self.is_host():
        return

    self.game.set_ai_option(str(name), key, value)
    self._mark_dirty()</code></pre>
</details>
</dd>
<dt id="server.GameConnection.handle_bottleneck"><code class="name flex">
<span>async def <span class="ident">handle_bottleneck</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Not sure what this command means. This is currently unused but
included for documentation purposes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_bottleneck(self, *args):
    &#34;&#34;&#34;
    Not sure what this command means. This is currently unused but
    included for documentation purposes.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="server.GameConnection.handle_bottleneck_cleared"><code class="name flex">
<span>async def <span class="ident">handle_bottleneck_cleared</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Not sure what this command means. This is currently unused but
included for documentation purposes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_bottleneck_cleared(self, *args):
    &#34;&#34;&#34;
    Not sure what this command means. This is currently unused but
    included for documentation purposes.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="server.GameConnection.handle_chat"><code class="name flex">
<span>async def <span class="ident">handle_chat</span></span>(<span>self, message: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Whenever the player sends a chat message during the game lobby.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_chat(self, message: str):
    &#34;&#34;&#34;
    Whenever the player sends a chat message during the game lobby.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="server.GameConnection.handle_clear_slot"><code class="name flex">
<span>async def <span class="ident">handle_clear_slot</span></span>(<span>self, slot)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_clear_slot(self, slot):
    if not self.is_host():
        return

    self.game.clear_slot(int(slot))
    self._mark_dirty()</code></pre>
</details>
</dd>
<dt id="server.GameConnection.handle_desync"><code class="name flex">
<span>async def <span class="ident">handle_desync</span></span>(<span>self, *_args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_desync(self, *_args):  # pragma: no cover
    self.game.desyncs += 1</code></pre>
</details>
</dd>
<dt id="server.GameConnection.handle_disconnected"><code class="name flex">
<span>async def <span class="ident">handle_disconnected</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Not sure what this command means. This is currently unused but
included for documentation purposes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_disconnected(self, *args):
    &#34;&#34;&#34;
    Not sure what this command means. This is currently unused but
    included for documentation purposes.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="server.GameConnection.handle_enforce_rating"><code class="name flex">
<span>async def <span class="ident">handle_enforce_rating</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_enforce_rating(self):
    self.game.enforce_rating = True</code></pre>
</details>
</dd>
<dt id="server.GameConnection.handle_game_ended"><code class="name flex">
<span>async def <span class="ident">handle_game_ended</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Signals that the simulation has ended.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_game_ended(self, *args):
    &#34;&#34;&#34;
    Signals that the simulation has ended.
    &#34;&#34;&#34;
    self.finished_sim = True
    await self.game.check_sim_end()

    # FIXME Move this into check_sim_end
    if self.game.ended:
        await self.game.on_game_end()</code></pre>
</details>
</dd>
<dt id="server.GameConnection.handle_game_full"><code class="name flex">
<span>async def <span class="ident">handle_game_full</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Sent when all game slots are full</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_game_full(self):
    &#34;&#34;&#34;
    Sent when all game slots are full
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="server.GameConnection.handle_game_mods"><code class="name flex">
<span>async def <span class="ident">handle_game_mods</span></span>(<span>self, mode, args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_game_mods(self, mode, args):
    if not self.is_host():
        return

    if mode == &#34;activated&#34;:
        # In this case args is the number of mods
        if int(args) == 0:
            self.game.mods = {}

    elif mode == &#34;uids&#34;:
        uids = str(args).split()
        self.game.mods = {uid: &#34;Unknown sim mod&#34; for uid in uids}
        async with self._db.acquire() as conn:
            result = await conn.execute(
                text(&#34;SELECT `uid`, `name` from `table_mod` WHERE `uid` in :ids&#34;),
                ids=tuple(uids))
            async for row in result:
                self.game.mods[row[&#34;uid&#34;]] = row[&#34;name&#34;]
    else:
        self._logger.warning(&#34;Ignoring game mod: %s, %s&#34;, mode, args)
        return

    self._mark_dirty()</code></pre>
</details>
</dd>
<dt id="server.GameConnection.handle_game_option"><code class="name flex">
<span>async def <span class="ident">handle_game_option</span></span>(<span>self, key, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_game_option(self, key, value):
    if not self.is_host():
        return

    if key == &#34;Victory&#34;:
        self.game.gameOptions[&#34;Victory&#34;] = Victory.__members__.get(
            value.upper(), None
        )
    else:
        self.game.gameOptions[key] = value

    if key == &#34;Slots&#34;:
        self.game.max_players = int(value)
    elif key == &#34;ScenarioFile&#34;:
        raw = repr(value)
        self.game.map_scenario_path = \
            raw.replace(&#34;\\&#34;, &#34;/&#34;).replace(&#34;//&#34;, &#34;/&#34;).replace(&#34;&#39;&#34;, &#34;&#34;)
        self.game.map_file_path = &#34;maps/{}.zip&#34;.format(
            self.game.map_scenario_path.split(&#34;/&#34;)[2].lower()
        )
    elif key == &#34;Title&#34;:
        with contextlib.suppress(ValueError):
            self.game.name = value

    self._mark_dirty()</code></pre>
</details>
</dd>
<dt id="server.GameConnection.handle_game_result"><code class="name flex">
<span>async def <span class="ident">handle_game_result</span></span>(<span>self, army, result)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_game_result(self, army, result):
    army = int(army)
    result = str(result).lower()
    try:
        label, score = result.split(&#34; &#34;)[-2:]
        await self.game.add_result(self.player.id, army, label, int(score))
    except (KeyError, ValueError):  # pragma: no cover
        self._logger.warning(&#34;Invalid result for %s reported: %s&#34;, army, result)</code></pre>
</details>
</dd>
<dt id="server.GameConnection.handle_game_state"><code class="name flex">
<span>async def <span class="ident">handle_game_state</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<div class="desc"><p>Changes in game state
:param state: new state
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_game_state(self, state):
    &#34;&#34;&#34;
    Changes in game state
    :param state: new state
    :return: None
    &#34;&#34;&#34;

    if state == &#34;Idle&#34;:
        await self._handle_idle_state()
        # Don&#39;t mark as dirty
        return

    elif state == &#34;Lobby&#34;:
        # TODO: Do we still need to schedule with `ensure_future`?
        #
        # We do not yield from the task, since we
        # need to keep processing other commands while it runs
        await self._handle_lobby_state()

    elif state == &#34;Launching&#34;:
        if self.player.state != PlayerState.HOSTING:
            return

        self._logger.info(
            &#34;Launching game %s in state %s&#34;,
            self.game,
            self.game.state
        )

        await self.game.launch()

        if len(self.game.mods.keys()) &gt; 0:
            async with self._db.acquire() as conn:
                uids = list(self.game.mods.keys())
                await conn.execute(text(
                    &#34;&#34;&#34; UPDATE mod_stats s JOIN mod_version v ON v.mod_id = s.mod_id
                        SET s.times_played = s.times_played + 1 WHERE v.uid in :ids&#34;&#34;&#34;),
                    ids=tuple(uids)
                )
    elif state == &#34;Ended&#34;:
        await self.on_connection_lost()
    self._mark_dirty()</code></pre>
</details>
</dd>
<dt id="server.GameConnection.handle_ice_message"><code class="name flex">
<span>async def <span class="ident">handle_ice_message</span></span>(<span>self, receiver_id, ice_msg)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_ice_message(self, receiver_id, ice_msg):
    receiver_id = int(receiver_id)
    peer = self.player_service.get_player(receiver_id)
    if not peer:
        self._logger.debug(
            &#34;Ignoring ICE message for unknown player: %s&#34;, receiver_id
        )
        return

    game_connection = peer.game_connection
    if not game_connection:
        self._logger.debug(
            &#34;Ignoring ICE message for player without game connection: %s&#34;, receiver_id
        )
        return

    try:
        await game_connection.send({
            &#34;command&#34;: &#34;IceMsg&#34;,
            &#34;args&#34;: [int(self.player.id), ice_msg]
        })
    except DisconnectedError:
        self._logger.debug(
            &#34;Failed to send ICE message to player due to a disconnect: %s&#34;,
            receiver_id
        )</code></pre>
</details>
</dd>
<dt id="server.GameConnection.handle_json_stats"><code class="name flex">
<span>async def <span class="ident">handle_json_stats</span></span>(<span>self, stats)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_json_stats(self, stats):
    self.game.report_army_stats(stats)</code></pre>
</details>
</dd>
<dt id="server.GameConnection.handle_operation_complete"><code class="name flex">
<span>async def <span class="ident">handle_operation_complete</span></span>(<span>self, army, secondary, delta)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_operation_complete(self, army, secondary, delta):
    if not int(army) == 1:
        return

    if self.game.validity != ValidityState.COOP_NOT_RANKED:
        return

    secondary, delta = int(secondary), str(delta)
    async with self._db.acquire() as conn:
        # FIXME: Resolve used map earlier than this
        result = await conn.execute(
            select([coop_map.c.id]).where(
                coop_map.c.filename == self.game.map_file_path
            )
        )
        row = await result.fetchone()
        if not row:
            self._logger.debug(&#34;can&#39;t find coop map: %s&#34;, self.game.map_file_path)
            return
        mission = row[&#34;id&#34;]

        await conn.execute(
            coop_leaderboard.insert().values(
                mission=mission,
                gameuid=self.game.id,
                secondary=secondary,
                time=delta,
                player_count=len(self.game.players),
            )
        )</code></pre>
</details>
</dd>
<dt id="server.GameConnection.handle_player_option"><code class="name flex">
<span>async def <span class="ident">handle_player_option</span></span>(<span>self, player_id, command, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_player_option(self, player_id, command, value):
    if not self.is_host():
        return

    self.game.set_player_option(int(player_id), command, value)
    self._mark_dirty()</code></pre>
</details>
</dd>
<dt id="server.GameConnection.handle_rehost"><code class="name flex">
<span>async def <span class="ident">handle_rehost</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Signals that the user has rehosted the game. This is currently unused but
included for documentation purposes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_rehost(self, *args):
    &#34;&#34;&#34;
    Signals that the user has rehosted the game. This is currently unused but
    included for documentation purposes.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="server.GameConnection.handle_teamkill_happened"><code class="name flex">
<span>async def <span class="ident">handle_teamkill_happened</span></span>(<span>self, gametime, victim_id, victim_name, teamkiller_id, teamkiller_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Send automatically by the game whenever a teamkill happens. Takes
the same parameters as TeamkillReport.</p>
<p>:param gametime: seconds of gametime when kill happened
:param victim_id: victim id
:param victim_name: victim nickname (for debug purpose only)
:param teamkiller_id: teamkiller id
:param teamkiller_name: teamkiller nickname (for debug purpose only)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_teamkill_happened(self, gametime, victim_id, victim_name, teamkiller_id, teamkiller_name):
    &#34;&#34;&#34;
        Send automatically by the game whenever a teamkill happens. Takes
        the same parameters as TeamkillReport.

        :param gametime: seconds of gametime when kill happened
        :param victim_id: victim id
        :param victim_name: victim nickname (for debug purpose only)
        :param teamkiller_id: teamkiller id
        :param teamkiller_name: teamkiller nickname (for debug purpose only)
    &#34;&#34;&#34;
    victim_id = int(victim_id)
    teamkiller_id = int(teamkiller_id)

    if 0 in (victim_id, teamkiller_id):
        self._logger.debug(&#34;Ignoring teamkill for AI player&#34;)
        return

    async with self._db.acquire() as conn:
        await conn.execute(
            teamkills.insert().values(
                teamkiller=teamkiller_id,
                victim=victim_id,
                game_id=self.game.id,
                gametime=gametime,
            )
        )</code></pre>
</details>
</dd>
<dt id="server.GameConnection.handle_teamkill_report"><code class="name flex">
<span>async def <span class="ident">handle_teamkill_report</span></span>(<span>self, gametime, reporter_id, reporter_name, teamkiller_id, teamkiller_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Sent when a player is teamkilled and clicks the 'Report' button.</p>
<p>:param gametime: seconds of gametime when kill happened
:param reporter_id: reporter id
:param reporter_name: reporter nickname (for debug purpose only)
:param teamkiller_id: teamkiller id
:param teamkiller_name: teamkiller nickname (for debug purpose only)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_teamkill_report(self, gametime, reporter_id, reporter_name, teamkiller_id, teamkiller_name):
    &#34;&#34;&#34;
        Sent when a player is teamkilled and clicks the &#39;Report&#39; button.

        :param gametime: seconds of gametime when kill happened
        :param reporter_id: reporter id
        :param reporter_name: reporter nickname (for debug purpose only)
        :param teamkiller_id: teamkiller id
        :param teamkiller_name: teamkiller nickname (for debug purpose only)
    &#34;&#34;&#34;

    pass</code></pre>
</details>
</dd>
<dt id="server.GameConnection.is_host"><code class="name flex">
<span>def <span class="ident">is_host</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_host(self) -&gt; bool:
    if not self.game or not self.player:
        return False

    return (
        self.player.state == PlayerState.HOSTING and
        self.player == self.game.host
    )</code></pre>
</details>
</dd>
<dt id="server.GameConnection.on_connection_lost"><code class="name flex">
<span>async def <span class="ident">on_connection_lost</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def on_connection_lost(self):
    try:
        await self.game.remove_game_connection(self)
    except Exception as e:  # pragma: no cover
        self._logger.exception(e)
    finally:
        await self.abort()</code></pre>
</details>
</dd>
<dt id="server.GameConnection.send"><code class="name flex">
<span>async def <span class="ident">send</span></span>(<span>self, message)</span>
</code></dt>
<dd>
<div class="desc"><p>Send a game message to the client.</p>
<p>:raises: DisconnectedError</p>
<p>NOTE: When calling this on a connection other than <code>self</code> make sure to
handle <code>DisconnectedError</code>, otherwise failure to send the message will
cause the caller to be disconnected as well.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send(self, message):
    &#34;&#34;&#34;
    Send a game message to the client.

    :raises: DisconnectedError

    NOTE: When calling this on a connection other than `self` make sure to
    handle `DisconnectedError`, otherwise failure to send the message will
    cause the caller to be disconnected as well.
    &#34;&#34;&#34;
    message[&#34;target&#34;] = &#34;game&#34;

    self._logger.log(TRACE, &#34;&gt;&gt; %s: %s&#34;, self.player.login, message)
    await self.protocol.send_message(message)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="server.protocol.gpgnet.GpgNetServerProtocol" href="protocol/gpgnet.html#server.protocol.gpgnet.GpgNetServerProtocol">GpgNetServerProtocol</a></b></code>:
<ul class="hlist">
<li><code><a title="server.protocol.gpgnet.GpgNetServerProtocol.send_ConnectToPeer" href="protocol/gpgnet.html#server.protocol.gpgnet.GpgNetServerProtocol.send_ConnectToPeer">send_ConnectToPeer</a></code></li>
<li><code><a title="server.protocol.gpgnet.GpgNetServerProtocol.send_DisconnectFromPeer" href="protocol/gpgnet.html#server.protocol.gpgnet.GpgNetServerProtocol.send_DisconnectFromPeer">send_DisconnectFromPeer</a></code></li>
<li><code><a title="server.protocol.gpgnet.GpgNetServerProtocol.send_HostGame" href="protocol/gpgnet.html#server.protocol.gpgnet.GpgNetServerProtocol.send_HostGame">send_HostGame</a></code></li>
<li><code><a title="server.protocol.gpgnet.GpgNetServerProtocol.send_JoinGame" href="protocol/gpgnet.html#server.protocol.gpgnet.GpgNetServerProtocol.send_JoinGame">send_JoinGame</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="server.GameService"><code class="flex name class">
<span>class <span class="ident">GameService</span></span>
<span>(</span><span>database: <a title="server.db.FAFDatabase" href="db/index.html#server.db.FAFDatabase">FAFDatabase</a>, player_service, game_stats_service, rating_service: <a title="server.rating_service.rating_service.RatingService" href="rating_service/rating_service.html#server.rating_service.rating_service.RatingService">RatingService</a>, message_queue_service: <a title="server.message_queue_service.MessageQueueService" href="message_queue_service.html#server.message_queue_service.MessageQueueService">MessageQueueService</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Utility class for maintaining lifecycle of games</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GameService(Service):
    &#34;&#34;&#34;
    Utility class for maintaining lifecycle of games
    &#34;&#34;&#34;
    def __init__(
        self,
        database: FAFDatabase,
        player_service,
        game_stats_service,
        rating_service: RatingService,
        message_queue_service: MessageQueueService
    ):
        self._db = database
        self._dirty_games = set()
        self._dirty_queues = set()
        self.player_service = player_service
        self.game_stats_service = game_stats_service
        self._rating_service = rating_service
        self._message_queue_service = message_queue_service
        self.game_id_counter = 0

        # Populated below in really_update_static_ish_data.
        self.featured_mods = dict()

        # A set of mod ids that are allowed in ranked games (everyone loves caching)
        self.ranked_mods = set()

        # The set of active games
        self._games: Dict[int, Game] = dict()

    async def initialize(self) -&gt; None:
        await self.initialise_game_counter()
        await self.update_data()
        self._update_cron = aiocron.crontab(
            &#34;*/10 * * * *&#34;, func=self.update_data
        )

        await self._message_queue_service.declare_exchange(config.MQ_EXCHANGE_NAME)

    async def initialise_game_counter(self):
        async with self._db.acquire() as conn:
            # InnoDB, unusually, doesn&#39;t allow insertion of values greater than the next expected
            # value into an auto_increment field. We&#39;d like to do that, because we no longer insert
            # games into the database when they don&#39;t start, so game ids aren&#39;t contiguous (as
            # unstarted games consume ids that never get written out).
            # So, id has to just be an integer primary key, no auto-increment: we handle its
            # incrementing here in game service, but have to do this slightly expensive query on
            # startup (though the primary key index probably makes it super fast anyway).
            # This is definitely a better choice than inserting useless rows when games are created,
            # doing LAST_UPDATE_ID to get the id number, and then doing an UPDATE when the actual
            # data to go into the row becomes available: we now only do a single insert for each
            # game, and don&#39;t end up with 800,000 junk rows in the database.
            result = await conn.execute(&#34;SELECT MAX(id) FROM game_stats&#34;)
            row = await result.fetchone()
            self.game_id_counter = row[0]

    async def update_data(self):
        &#34;&#34;&#34;
        Loads from the database the mostly-constant things that it doesn&#39;t make sense to query every
        time we need, but which can in principle change over time.
        &#34;&#34;&#34;
        async with self._db.acquire() as conn:
            result = await conn.execute(&#34;SELECT `id`, `gamemod`, `name`, description, publish, `order` FROM game_featuredMods&#34;)

            async for row in result:
                mod_id, name, full_name, description, publish, order = (row[i] for i in range(6))
                self.featured_mods[name] = FeaturedMod(
                    mod_id, name, full_name, description, publish, order)

            result = await conn.execute(&#34;SELECT uid FROM table_mod WHERE ranked = 1&#34;)
            rows = await result.fetchall()

            # Turn resultset into a list of uids
            self.ranked_mods = set(map(lambda x: x[0], rows))

    @property
    def dirty_games(self):
        return self._dirty_games

    @property
    def dirty_queues(self):
        return self._dirty_queues

    def mark_dirty(self, obj: Union[Game, MatchmakerQueue]):
        if isinstance(obj, Game):
            self._dirty_games.add(obj)
        elif isinstance(obj, MatchmakerQueue):
            self._dirty_queues.add(obj)

    def clear_dirty(self):
        self._dirty_games = set()
        self._dirty_queues = set()

    def create_uid(self) -&gt; int:
        self.game_id_counter += 1

        return self.game_id_counter

    def create_game(
        self,
        game_mode: str,
        game_class: Type[Game] = None,
        visibility=VisibilityState.PUBLIC,
        host: Optional[Player] = None,
        name: Optional[str] = None,
        mapname: Optional[str] = None,
        password: Optional[str] = None,
        matchmaker_queue_id: Optional[int] = None,
        **kwargs
    ):
        &#34;&#34;&#34;
        Main entrypoint for creating new games
        &#34;&#34;&#34;
        game_id = self.create_uid()
        game_args = {
            &#34;database&#34;: self._db,
            &#34;id_&#34;: game_id,
            &#34;host&#34;: host,
            &#34;name&#34;: name,
            &#34;map_&#34;: mapname,
            &#34;game_mode&#34;: game_mode,
            &#34;game_service&#34;: self,
            &#34;game_stats_service&#34;: self.game_stats_service,
            &#34;matchmaker_queue_id&#34;: matchmaker_queue_id,
        }
        game_args.update(kwargs)

        if not game_class:
            game_class = {
                FeaturedModType.LADDER_1V1:   LadderGame,
                FeaturedModType.COOP:         CoopGame,
                FeaturedModType.FAF:          CustomGame,
                FeaturedModType.FAFBETA:      CustomGame,
                FeaturedModType.EQUILIBRIUM:  CustomGame
            }.get(game_mode, Game)
        game = game_class(**game_args)

        self._games[game_id] = game

        game.visibility = visibility
        game.password = password

        self.mark_dirty(game)
        return game

    def update_active_game_metrics(self):
        modes = list(self.featured_mods.keys())

        game_counter = Counter(
            (
                game.game_mode if game.game_mode in modes else &#34;other&#34;,
                game.state
            )
            for game in self._games.values()
        )

        for state in GameState:
            for mode in modes + [&#34;other&#34;]:
                metrics.active_games.labels(mode, state.name).set(
                    game_counter[(mode, state)]
                )

    @property
    def live_games(self) -&gt; List[Game]:
        return [game for game in self._games.values()
                if game.state is GameState.LIVE]

    @property
    def open_games(self) -&gt; List[Game]:
        &#34;&#34;&#34;
        Return all games that meet the client&#39;s definition of &#34;not closed&#34;.
        Server game states are mapped to client game states as follows:

            GameState.LOBBY: &#34;open&#34;,
            GameState.LIVE: &#34;playing&#34;,
            GameState.ENDED: &#34;closed&#34;,
            GameState.INITIALIZING: &#34;closed&#34;,

        The client ignores everything &#34;closed&#34;. This property fetches all such not-closed games.
        :return:
        &#34;&#34;&#34;
        return [game for game in self._games.values()
                if game.state is GameState.LOBBY or game.state is GameState.LIVE]

    @property
    def all_games(self) -&gt; ValuesView[Game]:
        return self._games.values()

    @property
    def pending_games(self) -&gt; List[Game]:
        return [game for game in self._games.values()
                if game.state is GameState.LOBBY or game.state is GameState.INITIALIZING]

    def remove_game(self, game: Game):
        if game.id in self._games:
            del self._games[game.id]

    def __getitem__(self, item: int) -&gt; Game:
        return self._games[item]

    def __contains__(self, item):
        return item in self._games

    async def publish_game_results(self, game_results: EndedGameInfo):
        result_dict = game_results.to_dict()
        await self._message_queue_service.publish(
            config.MQ_EXCHANGE_NAME,
            &#34;success.gameResults.create&#34;,
            result_dict,
        )

        # TODO: Remove when rating service starts listening to message queue
        if (
            game_results.validity is ValidityState.VALID
            and game_results.rating_type is not None
        ):
            await self._rating_service.enqueue(result_dict)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="server.core.service.Service" href="core/service.html#server.core.service.Service">Service</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="server.GameService.services"><code class="name">var <span class="ident">services</span> : Dict[str, type]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="server.GameService.all_games"><code class="name">var <span class="ident">all_games</span> : ValuesView[<a title="server.games.game.Game" href="games/game.html#server.games.game.Game">Game</a>]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def all_games(self) -&gt; ValuesView[Game]:
    return self._games.values()</code></pre>
</details>
</dd>
<dt id="server.GameService.dirty_games"><code class="name">var <span class="ident">dirty_games</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dirty_games(self):
    return self._dirty_games</code></pre>
</details>
</dd>
<dt id="server.GameService.dirty_queues"><code class="name">var <span class="ident">dirty_queues</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dirty_queues(self):
    return self._dirty_queues</code></pre>
</details>
</dd>
<dt id="server.GameService.live_games"><code class="name">var <span class="ident">live_games</span> : List[<a title="server.games.game.Game" href="games/game.html#server.games.game.Game">Game</a>]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def live_games(self) -&gt; List[Game]:
    return [game for game in self._games.values()
            if game.state is GameState.LIVE]</code></pre>
</details>
</dd>
<dt id="server.GameService.open_games"><code class="name">var <span class="ident">open_games</span> : List[<a title="server.games.game.Game" href="games/game.html#server.games.game.Game">Game</a>]</code></dt>
<dd>
<div class="desc"><p>Return all games that meet the client's definition of "not closed".
Server game states are mapped to client game states as follows:</p>
<pre><code>GameState.LOBBY: "open",
GameState.LIVE: "playing",
GameState.ENDED: "closed",
GameState.INITIALIZING: "closed",
</code></pre>
<p>The client ignores everything "closed". This property fetches all such not-closed games.
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def open_games(self) -&gt; List[Game]:
    &#34;&#34;&#34;
    Return all games that meet the client&#39;s definition of &#34;not closed&#34;.
    Server game states are mapped to client game states as follows:

        GameState.LOBBY: &#34;open&#34;,
        GameState.LIVE: &#34;playing&#34;,
        GameState.ENDED: &#34;closed&#34;,
        GameState.INITIALIZING: &#34;closed&#34;,

    The client ignores everything &#34;closed&#34;. This property fetches all such not-closed games.
    :return:
    &#34;&#34;&#34;
    return [game for game in self._games.values()
            if game.state is GameState.LOBBY or game.state is GameState.LIVE]</code></pre>
</details>
</dd>
<dt id="server.GameService.pending_games"><code class="name">var <span class="ident">pending_games</span> : List[<a title="server.games.game.Game" href="games/game.html#server.games.game.Game">Game</a>]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def pending_games(self) -&gt; List[Game]:
    return [game for game in self._games.values()
            if game.state is GameState.LOBBY or game.state is GameState.INITIALIZING]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="server.GameService.clear_dirty"><code class="name flex">
<span>def <span class="ident">clear_dirty</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_dirty(self):
    self._dirty_games = set()
    self._dirty_queues = set()</code></pre>
</details>
</dd>
<dt id="server.GameService.create_game"><code class="name flex">
<span>def <span class="ident">create_game</span></span>(<span>self, game_mode: str, game_class: Type[<a title="server.games.game.Game" href="games/game.html#server.games.game.Game">Game</a>] = None, visibility=VisibilityState.PUBLIC, host: Union[<a title="server.players.Player" href="players.html#server.players.Player">Player</a>, NoneType] = None, name: Union[str, NoneType] = None, mapname: Union[str, NoneType] = None, password: Union[str, NoneType] = None, matchmaker_queue_id: Union[int, NoneType] = None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Main entrypoint for creating new games</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_game(
    self,
    game_mode: str,
    game_class: Type[Game] = None,
    visibility=VisibilityState.PUBLIC,
    host: Optional[Player] = None,
    name: Optional[str] = None,
    mapname: Optional[str] = None,
    password: Optional[str] = None,
    matchmaker_queue_id: Optional[int] = None,
    **kwargs
):
    &#34;&#34;&#34;
    Main entrypoint for creating new games
    &#34;&#34;&#34;
    game_id = self.create_uid()
    game_args = {
        &#34;database&#34;: self._db,
        &#34;id_&#34;: game_id,
        &#34;host&#34;: host,
        &#34;name&#34;: name,
        &#34;map_&#34;: mapname,
        &#34;game_mode&#34;: game_mode,
        &#34;game_service&#34;: self,
        &#34;game_stats_service&#34;: self.game_stats_service,
        &#34;matchmaker_queue_id&#34;: matchmaker_queue_id,
    }
    game_args.update(kwargs)

    if not game_class:
        game_class = {
            FeaturedModType.LADDER_1V1:   LadderGame,
            FeaturedModType.COOP:         CoopGame,
            FeaturedModType.FAF:          CustomGame,
            FeaturedModType.FAFBETA:      CustomGame,
            FeaturedModType.EQUILIBRIUM:  CustomGame
        }.get(game_mode, Game)
    game = game_class(**game_args)

    self._games[game_id] = game

    game.visibility = visibility
    game.password = password

    self.mark_dirty(game)
    return game</code></pre>
</details>
</dd>
<dt id="server.GameService.create_uid"><code class="name flex">
<span>def <span class="ident">create_uid</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_uid(self) -&gt; int:
    self.game_id_counter += 1

    return self.game_id_counter</code></pre>
</details>
</dd>
<dt id="server.GameService.initialise_game_counter"><code class="name flex">
<span>async def <span class="ident">initialise_game_counter</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def initialise_game_counter(self):
    async with self._db.acquire() as conn:
        # InnoDB, unusually, doesn&#39;t allow insertion of values greater than the next expected
        # value into an auto_increment field. We&#39;d like to do that, because we no longer insert
        # games into the database when they don&#39;t start, so game ids aren&#39;t contiguous (as
        # unstarted games consume ids that never get written out).
        # So, id has to just be an integer primary key, no auto-increment: we handle its
        # incrementing here in game service, but have to do this slightly expensive query on
        # startup (though the primary key index probably makes it super fast anyway).
        # This is definitely a better choice than inserting useless rows when games are created,
        # doing LAST_UPDATE_ID to get the id number, and then doing an UPDATE when the actual
        # data to go into the row becomes available: we now only do a single insert for each
        # game, and don&#39;t end up with 800,000 junk rows in the database.
        result = await conn.execute(&#34;SELECT MAX(id) FROM game_stats&#34;)
        row = await result.fetchone()
        self.game_id_counter = row[0]</code></pre>
</details>
</dd>
<dt id="server.GameService.mark_dirty"><code class="name flex">
<span>def <span class="ident">mark_dirty</span></span>(<span>self, obj: Union[<a title="server.games.game.Game" href="games/game.html#server.games.game.Game">Game</a>, <a title="server.matchmaker.matchmaker_queue.MatchmakerQueue" href="matchmaker/matchmaker_queue.html#server.matchmaker.matchmaker_queue.MatchmakerQueue">MatchmakerQueue</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mark_dirty(self, obj: Union[Game, MatchmakerQueue]):
    if isinstance(obj, Game):
        self._dirty_games.add(obj)
    elif isinstance(obj, MatchmakerQueue):
        self._dirty_queues.add(obj)</code></pre>
</details>
</dd>
<dt id="server.GameService.publish_game_results"><code class="name flex">
<span>async def <span class="ident">publish_game_results</span></span>(<span>self, game_results: <a title="server.games.typedefs.EndedGameInfo" href="games/typedefs.html#server.games.typedefs.EndedGameInfo">EndedGameInfo</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def publish_game_results(self, game_results: EndedGameInfo):
    result_dict = game_results.to_dict()
    await self._message_queue_service.publish(
        config.MQ_EXCHANGE_NAME,
        &#34;success.gameResults.create&#34;,
        result_dict,
    )

    # TODO: Remove when rating service starts listening to message queue
    if (
        game_results.validity is ValidityState.VALID
        and game_results.rating_type is not None
    ):
        await self._rating_service.enqueue(result_dict)</code></pre>
</details>
</dd>
<dt id="server.GameService.remove_game"><code class="name flex">
<span>def <span class="ident">remove_game</span></span>(<span>self, game: <a title="server.games.game.Game" href="games/game.html#server.games.game.Game">Game</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_game(self, game: Game):
    if game.id in self._games:
        del self._games[game.id]</code></pre>
</details>
</dd>
<dt id="server.GameService.update_active_game_metrics"><code class="name flex">
<span>def <span class="ident">update_active_game_metrics</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_active_game_metrics(self):
    modes = list(self.featured_mods.keys())

    game_counter = Counter(
        (
            game.game_mode if game.game_mode in modes else &#34;other&#34;,
            game.state
        )
        for game in self._games.values()
    )

    for state in GameState:
        for mode in modes + [&#34;other&#34;]:
            metrics.active_games.labels(mode, state.name).set(
                game_counter[(mode, state)]
            )</code></pre>
</details>
</dd>
<dt id="server.GameService.update_data"><code class="name flex">
<span>async def <span class="ident">update_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads from the database the mostly-constant things that it doesn't make sense to query every
time we need, but which can in principle change over time.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def update_data(self):
    &#34;&#34;&#34;
    Loads from the database the mostly-constant things that it doesn&#39;t make sense to query every
    time we need, but which can in principle change over time.
    &#34;&#34;&#34;
    async with self._db.acquire() as conn:
        result = await conn.execute(&#34;SELECT `id`, `gamemod`, `name`, description, publish, `order` FROM game_featuredMods&#34;)

        async for row in result:
            mod_id, name, full_name, description, publish, order = (row[i] for i in range(6))
            self.featured_mods[name] = FeaturedMod(
                mod_id, name, full_name, description, publish, order)

        result = await conn.execute(&#34;SELECT uid FROM table_mod WHERE ranked = 1&#34;)
        rows = await result.fetchall()

        # Turn resultset into a list of uids
        self.ranked_mods = set(map(lambda x: x[0], rows))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="server.core.service.Service" href="core/service.html#server.core.service.Service">Service</a></b></code>:
<ul class="hlist">
<li><code><a title="server.core.service.Service.initialize" href="core/service.html#server.core.service.Service.initialize">initialize</a></code></li>
<li><code><a title="server.core.service.Service.on_connection_lost" href="core/service.html#server.core.service.Service.on_connection_lost">on_connection_lost</a></code></li>
<li><code><a title="server.core.service.Service.shutdown" href="core/service.html#server.core.service.Service.shutdown">shutdown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="server.GameStatsService"><code class="flex name class">
<span>class <span class="ident">GameStatsService</span></span>
<span>(</span><span>event_service: <a title="server.stats.event_service.EventService" href="stats/event_service.html#server.stats.event_service.EventService">EventService</a>, achievement_service: <a title="server.stats.achievement_service.AchievementService" href="stats/achievement_service.html#server.stats.achievement_service.AchievementService">AchievementService</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>All services should inherit from this class.</p>
<p>Services are singleton objects which manage some server task.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GameStatsService(Service):
    def __init__(self, event_service: EventService, achievement_service: AchievementService):
        self._event_service = event_service
        self._achievement_service = achievement_service

    async def process_game_stats(self, player: Player, game: Game, army_stats_list: List):
        stats = None
        number_of_humans = 0
        highest_score = 0
        highest_scorer = None

        for army_stats in army_stats_list:
            if army_stats[&#34;type&#34;] == &#34;AI&#34; and army_stats[&#34;name&#34;] != &#34;civilian&#34;:
                self._logger.debug(&#34;Ignoring AI game reported by %s&#34;, player.login)
                return

            if army_stats[&#34;type&#34;] == &#34;Human&#34;:
                number_of_humans += 1

                if highest_score &lt; army_stats[&#34;general&#34;][&#34;score&#34;]:
                    highest_score = army_stats[&#34;general&#34;][&#34;score&#34;]
                    highest_scorer = army_stats[&#34;name&#34;]

            if army_stats[&#34;name&#34;] == player.login:
                stats = army_stats

        if number_of_humans &lt; 2:
            self._logger.debug(&#34;Ignoring single player game reported by %s&#34;, player.login)
            return

        if stats is None:
            self._logger.warning(&#34;Player %s reported stats of a game he was not part of&#34;, player.login)
            return

        army_result = game.get_player_outcome(player)
        if army_result is ArmyOutcome.UNKNOWN:
            self._logger.warning(&#34;No army result available for player %s&#34;, player.login)
            return

        self._logger.debug(&#34;Processing game stats for player: %s&#34;, player.login)

        faction = stats[&#34;faction&#34;]
        # Stores achievements to batch update
        a_queue = []
        # Stores events to batch update
        e_queue = []
        self._logger.debug(&#34;Army result for %s =&gt; %s &#34;, player, army_result)

        survived = army_result is ArmyOutcome.VICTORY
        blueprint_stats = stats[&#34;blueprints&#34;]
        unit_stats = stats[&#34;units&#34;]
        scored_highest = highest_scorer == player.login

        if survived and game.game_mode == FeaturedModType.LADDER_1V1:
            self._unlock(ACH_FIRST_SUCCESS, a_queue)

        self._increment(ACH_NOVICE, 1, a_queue)
        self._increment(ACH_JUNIOR, 1, a_queue)
        self._increment(ACH_SENIOR, 1, a_queue)
        self._increment(ACH_VETERAN, 1, a_queue)
        self._increment(ACH_ADDICT, 1, a_queue)

        self._faction_played(faction, survived, a_queue, e_queue)
        self._category_stats(unit_stats, survived, a_queue, e_queue)
        self._killed_acus(unit_stats, survived, a_queue)
        self._built_mercies(_count_built_units(blueprint_stats, Unit.MERCY), a_queue)
        self._built_fire_beetles(_count_built_units(blueprint_stats, Unit.FIRE_BEETLE), a_queue)
        self._built_salvations(_count_built_units(blueprint_stats, Unit.SALVATION), survived, a_queue)
        self._built_yolona_oss(_count_built_units(blueprint_stats, Unit.YOLONA_OSS), survived, a_queue)
        self._built_paragons(_count_built_units(blueprint_stats, Unit.PARAGON), survived, a_queue)
        self._built_atlantis(_count_built_units(blueprint_stats, Unit.ATLANTIS), a_queue)
        self._built_tempests(_count_built_units(blueprint_stats, Unit.TEMPEST), a_queue)
        self._built_scathis(_count_built_units(blueprint_stats, Unit.SCATHIS), survived, a_queue)
        self._built_mavors(_count_built_units(blueprint_stats, Unit.MAVOR), survived, a_queue)
        self._built_czars(_count_built_units(blueprint_stats, Unit.CZAR), a_queue)
        self._built_ahwassas(_count_built_units(blueprint_stats, Unit.AHWASSA), a_queue)
        self._built_ythothas(_count_built_units(blueprint_stats, Unit.YTHOTHA), a_queue)
        self._built_fatboys(_count_built_units(blueprint_stats, Unit.FATBOY), a_queue)
        self._built_monkeylords(_count_built_units(blueprint_stats, Unit.MONKEYLORD), a_queue)
        self._built_galactic_colossus(_count_built_units(blueprint_stats, Unit.GALACTIC_COLOSSUS), a_queue)
        self._built_soul_rippers(_count_built_units(blueprint_stats, Unit.SOUL_RIPPER), a_queue)
        self._built_megaliths(_count_built_units(blueprint_stats, Unit.MEGALITH), a_queue)
        self._built_asfs(_count_built_units(blueprint_stats, *ASFS), a_queue)
        self._built_transports(unit_stats[&#34;transportation&#34;].get(&#34;built&#34;, 0), a_queue)
        self._built_sacus(unit_stats[&#34;sacu&#34;].get(&#34;built&#34;, 0), a_queue)
        self._lowest_acu_health(_count(blueprint_stats, lambda x: x.get(&#34;lowest_health&#34;, 0), *ACUS), survived, a_queue)
        self._highscore(scored_highest, number_of_humans, a_queue)

        if config.USE_API:
            updated_achievements = await self._achievement_service.execute_batch_update(player.id, a_queue)

            if updated_achievements is None:
                self._logger.warning(&#34;API returned an error while handling the achievements batch update.&#34;)
                return

            await self._event_service.execute_batch_update(player.id, e_queue)
            if player.lobby_connection is not None:
                await player.lobby_connection.send_updated_achievements(updated_achievements)

    def _category_stats(self, unit_stats, survived, achievements_queue, events_queue):
        built_air = unit_stats[&#34;air&#34;].get(&#34;built&#34;, 0)
        built_land = unit_stats[&#34;land&#34;].get(&#34;built&#34;, 0)
        built_naval = unit_stats[&#34;naval&#34;].get(&#34;built&#34;, 0)
        built_experimentals = unit_stats[&#34;experimental&#34;].get(&#34;built&#34;, 0)

        self._record_event(EVENT_BUILT_AIR_UNITS, built_air, events_queue)
        self._record_event(EVENT_LOST_AIR_UNITS, unit_stats[&#34;air&#34;].get(&#34;lost&#34;, 0), events_queue)
        self._record_event(EVENT_BUILT_LAND_UNITS, built_land, events_queue)
        self._record_event(EVENT_LOST_LAND_UNITS, unit_stats[&#34;land&#34;].get(&#34;lost&#34;, 0), events_queue)
        self._record_event(EVENT_BUILT_NAVAL_UNITS, built_naval, events_queue)
        self._record_event(EVENT_LOST_NAVAL_UNITS, unit_stats[&#34;naval&#34;].get(&#34;lost&#34;, 0), events_queue)
        self._record_event(EVENT_LOST_ACUS, unit_stats[&#34;cdr&#34;].get(&#34;lost&#34;, 0), events_queue)
        self._record_event(EVENT_BUILT_TECH_1_UNITS, unit_stats[&#34;tech1&#34;].get(&#34;built&#34;, 0), events_queue)
        self._record_event(EVENT_LOST_TECH_1_UNITS, unit_stats[&#34;tech1&#34;].get(&#34;lost&#34;, 0), events_queue)
        self._record_event(EVENT_BUILT_TECH_2_UNITS, unit_stats[&#34;tech2&#34;].get(&#34;built&#34;, 0), events_queue)
        self._record_event(EVENT_LOST_TECH_2_UNITS, unit_stats[&#34;tech2&#34;].get(&#34;lost&#34;, 0), events_queue)
        self._record_event(EVENT_BUILT_TECH_3_UNITS, unit_stats[&#34;tech3&#34;].get(&#34;built&#34;, 0), events_queue)
        self._record_event(EVENT_LOST_TECH_3_UNITS, unit_stats[&#34;tech3&#34;].get(&#34;lost&#34;, 0), events_queue)
        self._record_event(EVENT_BUILT_EXPERIMENTALS, built_experimentals, events_queue)
        self._record_event(EVENT_LOST_EXPERIMENTALS, unit_stats[&#34;experimental&#34;].get(&#34;lost&#34;, 0), events_queue)
        self._record_event(EVENT_BUILT_ENGINEERS, unit_stats[&#34;engineer&#34;].get(&#34;built&#34;, 0), events_queue)
        self._record_event(EVENT_LOST_ENGINEERS, unit_stats[&#34;engineer&#34;].get(&#34;lost&#34;, 0), events_queue)

        if survived:
            if built_air &gt; built_land and built_air &gt; built_naval:
                self._increment(ACH_WRIGHT_BROTHER, 1, achievements_queue)
                self._increment(ACH_WINGMAN, 1, achievements_queue)
                self._increment(ACH_KING_OF_THE_SKIES, 1, achievements_queue)
            elif built_land &gt; built_air and built_land &gt; built_naval:
                self._increment(ACH_MILITIAMAN, 1, achievements_queue)
                self._increment(ACH_GRENADIER, 1, achievements_queue)
                self._increment(ACH_FIELD_MARSHAL, 1, achievements_queue)
            elif built_naval &gt; built_land and built_naval &gt; built_air:
                self._increment(ACH_LANDLUBBER, 1, achievements_queue)
                self._increment(ACH_SEAMAN, 1, achievements_queue)
                self._increment(ACH_ADMIRAL_OF_THE_FLEET, 1, achievements_queue)

            if built_experimentals &gt; 0:
                self._increment(ACH_DR_EVIL, built_experimentals, achievements_queue)

                if built_experimentals &gt;= 3:
                    self._increment(ACH_TECHIE, 1, achievements_queue)
                    self._increment(ACH_I_LOVE_BIG_TOYS, 1, achievements_queue)
                    self._increment(ACH_EXPERIMENTALIST, 1, achievements_queue)

    def _faction_played(self, faction, survived, achievements_queue, events_queue):
        if faction == Faction.aeon:
            self._record_event(EVENT_AEON_PLAYS, 1, events_queue)

            if survived:
                self._record_event(EVENT_AEON_WINS, 1, events_queue)
                self._increment(ACH_AURORA, 1, achievements_queue)
                self._increment(ACH_BLAZE, 1, achievements_queue)
                self._increment(ACH_SERENITY, 1, achievements_queue)
        elif faction == Faction.cybran:
            self._record_event(EVENT_CYBRAN_PLAYS, 1, events_queue)

            if survived:
                self._record_event(EVENT_CYBRAN_WINS, 1, events_queue)
                self._increment(ACH_MANTIS, 1, achievements_queue)
                self._increment(ACH_WAGNER, 1, achievements_queue)
                self._increment(ACH_TREBUCHET, 1, achievements_queue)
        elif faction == Faction.uef:
            self._record_event(EVENT_UEF_PLAYS, 1, events_queue)

            if survived:
                self._record_event(EVENT_UEF_WINS, 1, events_queue)
                self._increment(ACH_MA12_STRIKER, 1, achievements_queue)
                self._increment(ACH_RIPTIDE, 1, achievements_queue)
                self._increment(ACH_DEMOLISHER, 1, achievements_queue)
        elif faction == Faction.seraphim:
            self._record_event(EVENT_SERAPHIM_PLAYS, 1, events_queue)

            if survived:
                self._record_event(EVENT_SERAPHIM_WINS, 1, events_queue)
                self._increment(ACH_THAAM, 1, achievements_queue)
                self._increment(ACH_YENZYNE, 1, achievements_queue)
                self._increment(ACH_SUTHANUS, 1, achievements_queue)

    def _killed_acus(self, unit_stats, survived, achievements_queue):
        killed_acus = unit_stats[&#34;cdr&#34;].get(&#34;kills&#34;, 0)

        if killed_acus &gt; 0:
            self._increment(ACH_DONT_MESS_WITH_ME, killed_acus, achievements_queue)

        if killed_acus &gt;= 3 and survived:
            self._unlock(ACH_HATTRICK, achievements_queue)

    def _built_mercies(self, count, achievements_queue):
        self._increment(ACH_NO_MERCY, count, achievements_queue)

    def _built_fire_beetles(self, count, achievements_queue):
        self._increment(ACH_DEADLY_BUGS, count, achievements_queue)

    def _built_salvations(self, count, survived, achievements_queue):
        if survived and count &gt; 0:
            self._unlock(ACH_RAINMAKER, achievements_queue)

    def _built_yolona_oss(self, count, survived, achievements_queue):
        if survived and count &gt; 0:
            self._unlock(ACH_NUCLEAR_WAR, achievements_queue)

    def _built_paragons(self, count, survived, achievements_queue):
        if survived and count &gt; 0:
            self._unlock(ACH_SO_MUCH_RESOURCES, achievements_queue)

    def _built_atlantis(self, count, achievements_queue):
        self._increment(ACH_IT_AINT_A_CITY, count, achievements_queue)

    def _built_tempests(self, count, achievements_queue):
        self._increment(ACH_STORMY_SEA, count, achievements_queue)

    def _built_scathis(self, count, survived, achievements_queue):
        if survived and count &gt; 0:
            self._unlock(ACH_MAKE_IT_HAIL, achievements_queue)

    def _built_mavors(self, count, survived, achievements_queue):
        if survived and count &gt; 0:
            self._unlock(ACH_I_HAVE_A_CANON, achievements_queue)

    def _built_czars(self, count, achievements_queue):
        self._increment(ACH_DEATH_FROM_ABOVE, count, achievements_queue)

    def _built_ahwassas(self, count, achievements_queue):
        self._increment(ACH_ASS_WASHER, count, achievements_queue)

    def _built_ythothas(self, count, achievements_queue):
        self._increment(ACH_ALIEN_INVASION, count, achievements_queue)

    def _built_fatboys(self, count, achievements_queue):
        self._increment(ACH_FATTER_IS_BETTER, count, achievements_queue)

    def _built_monkeylords(self, count, achievements_queue):
        self._increment(ACH_ARACHNOLOGIST, count, achievements_queue)

    def _built_galactic_colossus(self, count, achievements_queue):
        self._increment(ACH_INCOMING_ROBOTS, count, achievements_queue)

    def _built_soul_rippers(self, count, achievements_queue):
        self._increment(ACH_FLYING_DEATH, count, achievements_queue)

    def _built_megaliths(self, count, achievements_queue):
        self._increment(ACH_HOLY_CRAB, count, achievements_queue)

    def _built_transports(self, count, achievements_queue):
        self._increment(ACH_THE_TRANSPORTER, count, achievements_queue)

    def _built_sacus(self, count, achievements_queue):
        self._set_steps_at_least(ACH_WHO_NEEDS_SUPPORT, count, achievements_queue)

    def _built_asfs(self, count, achievements_queue):
        self._set_steps_at_least(ACH_WHAT_A_SWARM, count, achievements_queue)

    def _lowest_acu_health(self, health, survived, achievements_queue):
        if 0 &lt; health &lt; 500 and survived:
            self._unlock(ACH_THAT_WAS_CLOSE, achievements_queue)

    def _highscore(self, scored_highest, number_of_humans, achievements_queue):
        if scored_highest and number_of_humans &gt;= 8:
            self._unlock(ACH_TOP_SCORE, achievements_queue)
            self._increment(ACH_UNBEATABLE, 1, achievements_queue)

    def _unlock(self, achievement_id, achievements_queue):
        self._achievement_service.unlock(achievement_id, achievements_queue)

    def _increment(self, achievement_id, steps, achievements_queue):
        self._achievement_service.increment(achievement_id, steps, achievements_queue)

    def _set_steps_at_least(self, achievement_id, steps, achievements_queue):
        self._achievement_service.set_steps_at_least(achievement_id, steps, achievements_queue)

    def _record_event(self, event_id, count, events_queue):
        self._event_service.record_event(event_id, count, events_queue)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="server.core.service.Service" href="core/service.html#server.core.service.Service">Service</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="server.GameStatsService.services"><code class="name">var <span class="ident">services</span> : Dict[str, type]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="server.GameStatsService.process_game_stats"><code class="name flex">
<span>async def <span class="ident">process_game_stats</span></span>(<span>self, player: <a title="server.players.Player" href="players.html#server.players.Player">Player</a>, game: <a title="server.games.game.Game" href="games/game.html#server.games.game.Game">Game</a>, army_stats_list: List)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def process_game_stats(self, player: Player, game: Game, army_stats_list: List):
    stats = None
    number_of_humans = 0
    highest_score = 0
    highest_scorer = None

    for army_stats in army_stats_list:
        if army_stats[&#34;type&#34;] == &#34;AI&#34; and army_stats[&#34;name&#34;] != &#34;civilian&#34;:
            self._logger.debug(&#34;Ignoring AI game reported by %s&#34;, player.login)
            return

        if army_stats[&#34;type&#34;] == &#34;Human&#34;:
            number_of_humans += 1

            if highest_score &lt; army_stats[&#34;general&#34;][&#34;score&#34;]:
                highest_score = army_stats[&#34;general&#34;][&#34;score&#34;]
                highest_scorer = army_stats[&#34;name&#34;]

        if army_stats[&#34;name&#34;] == player.login:
            stats = army_stats

    if number_of_humans &lt; 2:
        self._logger.debug(&#34;Ignoring single player game reported by %s&#34;, player.login)
        return

    if stats is None:
        self._logger.warning(&#34;Player %s reported stats of a game he was not part of&#34;, player.login)
        return

    army_result = game.get_player_outcome(player)
    if army_result is ArmyOutcome.UNKNOWN:
        self._logger.warning(&#34;No army result available for player %s&#34;, player.login)
        return

    self._logger.debug(&#34;Processing game stats for player: %s&#34;, player.login)

    faction = stats[&#34;faction&#34;]
    # Stores achievements to batch update
    a_queue = []
    # Stores events to batch update
    e_queue = []
    self._logger.debug(&#34;Army result for %s =&gt; %s &#34;, player, army_result)

    survived = army_result is ArmyOutcome.VICTORY
    blueprint_stats = stats[&#34;blueprints&#34;]
    unit_stats = stats[&#34;units&#34;]
    scored_highest = highest_scorer == player.login

    if survived and game.game_mode == FeaturedModType.LADDER_1V1:
        self._unlock(ACH_FIRST_SUCCESS, a_queue)

    self._increment(ACH_NOVICE, 1, a_queue)
    self._increment(ACH_JUNIOR, 1, a_queue)
    self._increment(ACH_SENIOR, 1, a_queue)
    self._increment(ACH_VETERAN, 1, a_queue)
    self._increment(ACH_ADDICT, 1, a_queue)

    self._faction_played(faction, survived, a_queue, e_queue)
    self._category_stats(unit_stats, survived, a_queue, e_queue)
    self._killed_acus(unit_stats, survived, a_queue)
    self._built_mercies(_count_built_units(blueprint_stats, Unit.MERCY), a_queue)
    self._built_fire_beetles(_count_built_units(blueprint_stats, Unit.FIRE_BEETLE), a_queue)
    self._built_salvations(_count_built_units(blueprint_stats, Unit.SALVATION), survived, a_queue)
    self._built_yolona_oss(_count_built_units(blueprint_stats, Unit.YOLONA_OSS), survived, a_queue)
    self._built_paragons(_count_built_units(blueprint_stats, Unit.PARAGON), survived, a_queue)
    self._built_atlantis(_count_built_units(blueprint_stats, Unit.ATLANTIS), a_queue)
    self._built_tempests(_count_built_units(blueprint_stats, Unit.TEMPEST), a_queue)
    self._built_scathis(_count_built_units(blueprint_stats, Unit.SCATHIS), survived, a_queue)
    self._built_mavors(_count_built_units(blueprint_stats, Unit.MAVOR), survived, a_queue)
    self._built_czars(_count_built_units(blueprint_stats, Unit.CZAR), a_queue)
    self._built_ahwassas(_count_built_units(blueprint_stats, Unit.AHWASSA), a_queue)
    self._built_ythothas(_count_built_units(blueprint_stats, Unit.YTHOTHA), a_queue)
    self._built_fatboys(_count_built_units(blueprint_stats, Unit.FATBOY), a_queue)
    self._built_monkeylords(_count_built_units(blueprint_stats, Unit.MONKEYLORD), a_queue)
    self._built_galactic_colossus(_count_built_units(blueprint_stats, Unit.GALACTIC_COLOSSUS), a_queue)
    self._built_soul_rippers(_count_built_units(blueprint_stats, Unit.SOUL_RIPPER), a_queue)
    self._built_megaliths(_count_built_units(blueprint_stats, Unit.MEGALITH), a_queue)
    self._built_asfs(_count_built_units(blueprint_stats, *ASFS), a_queue)
    self._built_transports(unit_stats[&#34;transportation&#34;].get(&#34;built&#34;, 0), a_queue)
    self._built_sacus(unit_stats[&#34;sacu&#34;].get(&#34;built&#34;, 0), a_queue)
    self._lowest_acu_health(_count(blueprint_stats, lambda x: x.get(&#34;lowest_health&#34;, 0), *ACUS), survived, a_queue)
    self._highscore(scored_highest, number_of_humans, a_queue)

    if config.USE_API:
        updated_achievements = await self._achievement_service.execute_batch_update(player.id, a_queue)

        if updated_achievements is None:
            self._logger.warning(&#34;API returned an error while handling the achievements batch update.&#34;)
            return

        await self._event_service.execute_batch_update(player.id, e_queue)
        if player.lobby_connection is not None:
            await player.lobby_connection.send_updated_achievements(updated_achievements)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="server.core.service.Service" href="core/service.html#server.core.service.Service">Service</a></b></code>:
<ul class="hlist">
<li><code><a title="server.core.service.Service.initialize" href="core/service.html#server.core.service.Service.initialize">initialize</a></code></li>
<li><code><a title="server.core.service.Service.on_connection_lost" href="core/service.html#server.core.service.Service.on_connection_lost">on_connection_lost</a></code></li>
<li><code><a title="server.core.service.Service.shutdown" href="core/service.html#server.core.service.Service.shutdown">shutdown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="server.GeoIpService"><code class="flex name class">
<span>class <span class="ident">GeoIpService</span></span>
</code></dt>
<dd>
<div class="desc"><p>Service for managing the GeoIp database. This includes an asyncio crontab
which periodically checks if the current file is out of date. If it is, then
the service will try to download a new file from tue url in <code><a title="server.config" href="config.html">server.config</a></code>.</p>
<pre><code>Provides an interface for getting data out of the database.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GeoIpService(Service):
    &#34;&#34;&#34;
        Service for managing the GeoIp database. This includes an asyncio crontab
    which periodically checks if the current file is out of date. If it is, then
    the service will try to download a new file from tue url in ``server.config``.

        Provides an interface for getting data out of the database.
    &#34;&#34;&#34;

    def __init__(self):
        self.refresh_file_path()
        config.register_callback(&#34;GEO_IP_DATABASE_PATH&#34;, self.refresh_file_path)

        self.db = None
        self.db_update_time = None

        self.check_geoip_db_file_updated()

    def refresh_file_path(self):
        self.file_path = config.GEO_IP_DATABASE_PATH

    async def initialize(self) -&gt; None:
        await self.check_update_geoip_db()
        # crontab: min hour day month day_of_week
        # Run every Wednesday because GeoLite2 is updated every first Tuesday
        # of the month.
        self._update_cron = aiocron.crontab(
            &#34;0 0 0 * * 3&#34;, func=self.check_update_geoip_db
        )
        self._check_file_timer = Timer(
            60 * 10, self.check_geoip_db_file_updated, start=True
        )

    def check_geoip_db_file_updated(self):
        &#34;&#34;&#34;
            Checks if the local database file has been updated by a server admin
        and loads it if it has.
        &#34;&#34;&#34;
        if not os.path.isfile(self.file_path):
            return

        if self.db is None:
            # We haven&#39;t loaded the file before
            self.load_db()
        else:
            assert self.db_update_time is not None
            # We have loaded the file, so check if it has been updated

            date_modified = datetime.fromtimestamp(
                os.path.getmtime(self.file_path)
            )
            if date_modified &gt; self.db_update_time:
                self.load_db()

    async def check_update_geoip_db(self) -&gt; None:
        &#34;&#34;&#34;
            Check if the geoip database is old and update it if so.
        &#34;&#34;&#34;
        if not config.GEO_IP_LICENSE_KEY:
            self._logger.warning(
                &#34;GEO_IP_LICENSE_KEY not set! Unable to download GeoIP database!&#34;
            )
            return

        self._logger.debug(&#34;Checking if geoip database needs updating&#34;)
        try:
            date_modified = datetime.fromtimestamp(
                os.path.getmtime(self.file_path)
            )
            delta = datetime.now() - date_modified

            if delta.days &gt; config.GEO_IP_DATABASE_MAX_AGE_DAYS:
                self._logger.info(&#34;Geoip database is out of date&#34;)
                await self.download_geoip_db()
        except FileNotFoundError:    # pragma: no cover
            self._logger.warning(&#34;Geoip database is missing...&#34;)
            await self.download_geoip_db()
        except asyncio.TimeoutError:    # pragma: no cover
            self._logger.warning(
                &#34;Failed to download database file! &#34;
                &#34;Check the network connection and try again&#34;
            )
        except Exception as e:    # pragma: no cover
            self._logger.exception(e)
            raise e

        self.load_db()

    async def download_geoip_db(self) -&gt; None:
        &#34;&#34;&#34;
            Download the geoip database to a file. If the downloaded file is not
        a valid gzip file, then it does NOT overwrite the old file.
        &#34;&#34;&#34;
        assert config.GEO_IP_LICENSE_KEY is not None

        self._logger.info(&#34;Downloading new geoip database&#34;)

        # Download new file to a temp location
        temp_file_path = &#34;/tmp/geoip.mmdb.tar.gz&#34;
        await self._download_file(
            config.GEO_IP_DATABASE_URL,
            config.GEO_IP_LICENSE_KEY,
            temp_file_path
        )

        # Unzip the archive and overwrite the old file
        try:
            with tarfile.open(temp_file_path, &#34;r:gz&#34;) as tar:
                f_in = extract_file(tar, &#34;GeoLite2-Country.mmdb&#34;)
                with open(self.file_path, &#34;wb&#34;) as f_out:
                    shutil.copyfileobj(f_in, f_out)
        except (tarfile.TarError) as e:    # pragma: no cover
            self._logger.warning(&#34;Failed to extract downloaded file!&#34;)
            raise e
        self._logger.info(&#34;New database download complete&#34;)

    async def _download_file(self, url: str, license_key: str, file_path: str) -&gt; None:
        &#34;&#34;&#34;
            Download a file using aiohttp and save it to a file.

            :param url: The url to download from
            :param file_path: Path to save the file at
        &#34;&#34;&#34;

        chunk_size = 1024
        params = {
            &#34;edition_id&#34;: &#34;GeoLite2-Country&#34;,
            &#34;license_key&#34;: license_key,
            &#34;suffix&#34;: &#34;tar.gz&#34;
        }

        async def get_checksum(session):
            async with session.get(url, params={
                **params,
                &#34;suffix&#34;: params[&#34;suffix&#34;] + &#34;.md5&#34;
            }, timeout=60 * 20) as resp:
                return await resp.text()

        async def get_db_file_with_checksum(session):
            hasher = hashlib.md5()
            async with session.get(url, params=params, timeout=60 * 20) as resp:
                with open(file_path, &#34;wb&#34;) as f:
                    while True:
                        chunk = await resp.content.read(chunk_size)
                        if not chunk:
                            break
                        f.write(chunk)
                        hasher.update(chunk)

            return hasher.hexdigest()

        async with aiohttp.ClientSession(raise_for_status=True) as session:
            checksum, our_hash = await asyncio.gather(
                get_checksum(session),
                get_db_file_with_checksum(session)
            )

        if checksum != our_hash:
            raise Exception(
                f&#34;Hashes did not match! Expected {checksum} got {our_hash}&#34;
            )

    def load_db(self) -&gt; None:
        &#34;&#34;&#34;
            Loads the database into memory.
        &#34;&#34;&#34;
        try:
            # Set the time first, if the file is corrupted we don&#39;t need to try
            # loading it again anyways
            self.db_update_time = datetime.now()
            self.db = geoip2.database.Reader(self.file_path)
            self._logger.info(
                &#34;File loaded successfully from %s&#34;, self.file_path
            )
        except (InvalidDatabaseError, FileNotFoundError, ValueError):
            self._logger.exception(
                &#34;Failed to load maxmind db! Maybe the download was interrupted&#34;
            )

    def country(self, address: str) -&gt; str:
        &#34;&#34;&#34;
            Look up an ip address in the db and return it&#39;s country code.
        &#34;&#34;&#34;
        default_value = &#34;&#34;
        if self.db is None:
            return default_value

        try:
            return str(self.db.country(address).country.iso_code)
        except geoip2.errors.AddressNotFoundError:
            return default_value
        except ValueError as e:    # pragma: no cover
            self._logger.exception(&#34;ValueError: %s&#34;, e)
            return default_value</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="server.core.service.Service" href="core/service.html#server.core.service.Service">Service</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="server.GeoIpService.services"><code class="name">var <span class="ident">services</span> : Dict[str, type]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="server.GeoIpService.check_geoip_db_file_updated"><code class="name flex">
<span>def <span class="ident">check_geoip_db_file_updated</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the local database file has been updated by a server admin
and loads it if it has.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_geoip_db_file_updated(self):
    &#34;&#34;&#34;
        Checks if the local database file has been updated by a server admin
    and loads it if it has.
    &#34;&#34;&#34;
    if not os.path.isfile(self.file_path):
        return

    if self.db is None:
        # We haven&#39;t loaded the file before
        self.load_db()
    else:
        assert self.db_update_time is not None
        # We have loaded the file, so check if it has been updated

        date_modified = datetime.fromtimestamp(
            os.path.getmtime(self.file_path)
        )
        if date_modified &gt; self.db_update_time:
            self.load_db()</code></pre>
</details>
</dd>
<dt id="server.GeoIpService.check_update_geoip_db"><code class="name flex">
<span>async def <span class="ident">check_update_geoip_db</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the geoip database is old and update it if so.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def check_update_geoip_db(self) -&gt; None:
    &#34;&#34;&#34;
        Check if the geoip database is old and update it if so.
    &#34;&#34;&#34;
    if not config.GEO_IP_LICENSE_KEY:
        self._logger.warning(
            &#34;GEO_IP_LICENSE_KEY not set! Unable to download GeoIP database!&#34;
        )
        return

    self._logger.debug(&#34;Checking if geoip database needs updating&#34;)
    try:
        date_modified = datetime.fromtimestamp(
            os.path.getmtime(self.file_path)
        )
        delta = datetime.now() - date_modified

        if delta.days &gt; config.GEO_IP_DATABASE_MAX_AGE_DAYS:
            self._logger.info(&#34;Geoip database is out of date&#34;)
            await self.download_geoip_db()
    except FileNotFoundError:    # pragma: no cover
        self._logger.warning(&#34;Geoip database is missing...&#34;)
        await self.download_geoip_db()
    except asyncio.TimeoutError:    # pragma: no cover
        self._logger.warning(
            &#34;Failed to download database file! &#34;
            &#34;Check the network connection and try again&#34;
        )
    except Exception as e:    # pragma: no cover
        self._logger.exception(e)
        raise e

    self.load_db()</code></pre>
</details>
</dd>
<dt id="server.GeoIpService.country"><code class="name flex">
<span>def <span class="ident">country</span></span>(<span>self, address: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Look up an ip address in the db and return it's country code.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def country(self, address: str) -&gt; str:
    &#34;&#34;&#34;
        Look up an ip address in the db and return it&#39;s country code.
    &#34;&#34;&#34;
    default_value = &#34;&#34;
    if self.db is None:
        return default_value

    try:
        return str(self.db.country(address).country.iso_code)
    except geoip2.errors.AddressNotFoundError:
        return default_value
    except ValueError as e:    # pragma: no cover
        self._logger.exception(&#34;ValueError: %s&#34;, e)
        return default_value</code></pre>
</details>
</dd>
<dt id="server.GeoIpService.download_geoip_db"><code class="name flex">
<span>async def <span class="ident">download_geoip_db</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Download the geoip database to a file. If the downloaded file is not
a valid gzip file, then it does NOT overwrite the old file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def download_geoip_db(self) -&gt; None:
    &#34;&#34;&#34;
        Download the geoip database to a file. If the downloaded file is not
    a valid gzip file, then it does NOT overwrite the old file.
    &#34;&#34;&#34;
    assert config.GEO_IP_LICENSE_KEY is not None

    self._logger.info(&#34;Downloading new geoip database&#34;)

    # Download new file to a temp location
    temp_file_path = &#34;/tmp/geoip.mmdb.tar.gz&#34;
    await self._download_file(
        config.GEO_IP_DATABASE_URL,
        config.GEO_IP_LICENSE_KEY,
        temp_file_path
    )

    # Unzip the archive and overwrite the old file
    try:
        with tarfile.open(temp_file_path, &#34;r:gz&#34;) as tar:
            f_in = extract_file(tar, &#34;GeoLite2-Country.mmdb&#34;)
            with open(self.file_path, &#34;wb&#34;) as f_out:
                shutil.copyfileobj(f_in, f_out)
    except (tarfile.TarError) as e:    # pragma: no cover
        self._logger.warning(&#34;Failed to extract downloaded file!&#34;)
        raise e
    self._logger.info(&#34;New database download complete&#34;)</code></pre>
</details>
</dd>
<dt id="server.GeoIpService.load_db"><code class="name flex">
<span>def <span class="ident">load_db</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Loads the database into memory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_db(self) -&gt; None:
    &#34;&#34;&#34;
        Loads the database into memory.
    &#34;&#34;&#34;
    try:
        # Set the time first, if the file is corrupted we don&#39;t need to try
        # loading it again anyways
        self.db_update_time = datetime.now()
        self.db = geoip2.database.Reader(self.file_path)
        self._logger.info(
            &#34;File loaded successfully from %s&#34;, self.file_path
        )
    except (InvalidDatabaseError, FileNotFoundError, ValueError):
        self._logger.exception(
            &#34;Failed to load maxmind db! Maybe the download was interrupted&#34;
        )</code></pre>
</details>
</dd>
<dt id="server.GeoIpService.refresh_file_path"><code class="name flex">
<span>def <span class="ident">refresh_file_path</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh_file_path(self):
    self.file_path = config.GEO_IP_DATABASE_PATH</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="server.core.service.Service" href="core/service.html#server.core.service.Service">Service</a></b></code>:
<ul class="hlist">
<li><code><a title="server.core.service.Service.initialize" href="core/service.html#server.core.service.Service.initialize">initialize</a></code></li>
<li><code><a title="server.core.service.Service.on_connection_lost" href="core/service.html#server.core.service.Service.on_connection_lost">on_connection_lost</a></code></li>
<li><code><a title="server.core.service.Service.shutdown" href="core/service.html#server.core.service.Service.shutdown">shutdown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="server.LadderService"><code class="flex name class">
<span>class <span class="ident">LadderService</span></span>
<span>(</span><span>database: <a title="server.db.FAFDatabase" href="db/index.html#server.db.FAFDatabase">FAFDatabase</a>, game_service: <a title="server.game_service.GameService" href="game_service.html#server.game_service.GameService">GameService</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Service responsible for managing the 1v1 ladder. Does matchmaking, updates
statistics, and launches the games.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LadderService(Service):
    &#34;&#34;&#34;
    Service responsible for managing the 1v1 ladder. Does matchmaking, updates
    statistics, and launches the games.
    &#34;&#34;&#34;
    def __init__(
        self,
        database: FAFDatabase,
        game_service: GameService,
    ):
        self._db = database
        self._informed_players: Set[Player] = set()
        self.game_service = game_service
        self.queues = {}

        self._searches: Dict[Player, Dict[str, Search]] = defaultdict(dict)

    async def initialize(self) -&gt; None:
        await self.update_data()
        self._update_cron = aiocron.crontab(&#34;*/10 * * * *&#34;, func=self.update_data)

    async def update_data(self) -&gt; None:
        async with self._db.acquire() as conn:
            map_pool_maps = await self.fetch_map_pools(conn)
            db_queues = await self.fetch_matchmaker_queues(conn)

        for name, info in db_queues.items():
            if name not in self.queues:
                queue = MatchmakerQueue(
                    self.game_service,
                    self.on_match_found,
                    name=name,
                    queue_id=info[&#34;id&#34;],
                    featured_mod=info[&#34;mod&#34;],
                    rating_type=info[&#34;rating_type&#34;],
                    team_size=info[&#34;team_size&#34;],
                )
                self.queues[name] = queue
                queue.initialize()
            else:
                queue = self.queues[name]
                queue.featured_mod = info[&#34;mod&#34;]
                queue.rating_type = info[&#34;rating_type&#34;]
                queue.team_size = info[&#34;team_size&#34;]
            queue.map_pools.clear()
            for map_pool_id, min_rating, max_rating in info[&#34;map_pools&#34;]:
                map_pool_name, map_list = map_pool_maps[map_pool_id]
                if not map_list:
                    self._logger.warning(
                        &#34;Map pool &#39;%s&#39; is empty! Some %s games will &#34;
                        &#34;likely fail to start!&#34;,
                        map_pool_name,
                        name
                    )
                queue.add_map_pool(
                    MapPool(map_pool_id, map_pool_name, map_list),
                    min_rating,
                    max_rating
                )
        # Remove queues that don&#39;t exist anymore
        for queue_name in list(self.queues.keys()):
            if queue_name not in db_queues:
                self.queues[queue_name].shutdown()
                del self.queues[queue_name]

    async def fetch_map_pools(self, conn) -&gt; Dict[int, Tuple[str, List[Map]]]:
        result = await conn.execute(
            select([
                map_pool.c.id,
                map_pool.c.name,
                map_pool_map_version.c.weight,
                map_pool_map_version.c.map_params,
                map_version.c.map_id,
                map_version.c.filename,
                t_map.c.display_name
            ]).select_from(
                map_pool.outerjoin(map_pool_map_version)
                .outerjoin(map_version)
                .outerjoin(t_map)
            )
        )
        map_pool_maps = {}
        async for row in result:
            id_ = row.id
            name = row.name
            if id_ not in map_pool_maps:
                map_pool_maps[id_] = (name, list())
            _, map_list = map_pool_maps[id_]
            if row.map_id is not None:
                map_list.append(
                    Map(row.map_id, row.display_name, row.filename, row.weight)
                )
            elif row.map_params is not None:
                try:
                    params = json.loads(row.map_params)
                    map_type = params[&#34;type&#34;]
                    if map_type == &#34;neroxis&#34;:
                        map_list.append(NeroxisGeneratedMap.of(params, row.weight))
                    else:
                        self._logger.warning(
                            &#34;Unsupported map type %s in pool %s&#34;,
                             map_type,
                             row.id
                        )

                except Exception:
                    self._logger.warning(
                        &#34;Failed to load map in map pool %d &#34;
                        &#34;parameters specified as %s&#34;,
                        row.id,
                        row.map_params,
                        exc_info=True
                    )

        return map_pool_maps

    async def fetch_matchmaker_queues(self, conn):
        result = await conn.execute(
            select([
                matchmaker_queue.c.id,
                matchmaker_queue.c.technical_name,
                matchmaker_queue.c.team_size,
                matchmaker_queue_map_pool.c.map_pool_id,
                matchmaker_queue_map_pool.c.min_rating,
                matchmaker_queue_map_pool.c.max_rating,
                game_featuredMods.c.gamemod,
                leaderboard.c.technical_name.label(&#34;rating_type&#34;)
            ])
            .select_from(
                matchmaker_queue
                .join(matchmaker_queue_map_pool)
                .join(game_featuredMods)
                .join(leaderboard)
            ).where(matchmaker_queue.c.enabled == true())
        )
        matchmaker_queues = defaultdict(lambda: defaultdict(list))
        async for row in result:
            name = row.technical_name
            info = matchmaker_queues[name]
            info[&#34;id&#34;] = row.id
            info[&#34;mod&#34;] = row.gamemod
            info[&#34;rating_type&#34;] = row.rating_type
            info[&#34;team_size&#34;] = row.team_size
            info[&#34;map_pools&#34;].append((
                row.map_pool_id,
                row.min_rating,
                row.max_rating
            ))
        return matchmaker_queues

    def start_search(
        self,
        players: List[Player],
        queue_name: str,
        on_matched: OnMatchedCallback = lambda _1, _2: None
    ):
        # Cancel any existing searches that players have for this queue
        for player in players:
            if queue_name in self._searches[player]:
                self._cancel_search(player, queue_name)

        queue = self.queues[queue_name]
        search = Search(
            players,
            rating_type=queue.rating_type,
            on_matched=on_matched
        )

        for player in players:
            player.state = PlayerState.SEARCHING_LADDER

            self.write_rating_progress(player, queue.rating_type)

            player.write_message({
                &#34;command&#34;: &#34;search_info&#34;,
                &#34;queue_name&#34;: queue_name,
                &#34;state&#34;: &#34;start&#34;
            })

            self._searches[player][queue_name] = search

        self._logger.info(&#34;%s started searching for %s&#34;, search, queue_name)

        asyncio.create_task(queue.search(search))

    def cancel_search(
        self,
        initiator: Player,
        queue_name: Optional[str] = None
    ) -&gt; None:
        if queue_name is None:
            queue_names = list(self._searches[initiator].keys())
        else:
            queue_names = [queue_name]

        for queue_name in queue_names:
            self._cancel_search(initiator, queue_name)

    def _cancel_search(self, initiator: Player, queue_name: str) -&gt; None:
        &#34;&#34;&#34;
        Cancel search for a specific player/queue.
        &#34;&#34;&#34;
        cancelled_search = self._clear_search(initiator, queue_name)
        if cancelled_search is None:
            self._logger.debug(
                &#34;Ignoring request to cancel a search that does not exist: &#34;
                &#34;%s, %s&#34;,
                initiator,
                queue_name
            )
            return
        cancelled_search.cancel()

        for player in cancelled_search.players:
            player.write_message({
                &#34;command&#34;: &#34;search_info&#34;,
                &#34;queue_name&#34;: queue_name,
                &#34;state&#34;: &#34;stop&#34;
            })
            if (
                not self._searches[player]
                and player.state == PlayerState.SEARCHING_LADDER
            ):
                player.state = PlayerState.IDLE
        self._logger.info(
            &#34;%s stopped searching for %s&#34;, cancelled_search, queue_name
        )

    def _clear_search(
        self,
        initiator: Player,
        queue_name: str
    ) -&gt; Optional[Search]:
        &#34;&#34;&#34;
        Remove a search from the searches dictionary.

        Does NOT cancel the search.
        &#34;&#34;&#34;
        search = self._searches[initiator].get(queue_name)

        if search is not None:
            for player in search.players:
                del self._searches[player][queue_name]

        return search

    def write_rating_progress(self, player: Player, rating_type: str) -&gt; None:
        if player not in self._informed_players:
            self._informed_players.add(player)
            _, deviation = player.ratings[rating_type]

            if deviation &gt; 490:
                player.write_message({
                    &#34;command&#34;: &#34;notice&#34;,
                    &#34;style&#34;: &#34;info&#34;,
                    &#34;text&#34;: (
                        &#34;&lt;i&gt;Welcome to the matchmaker&lt;/i&gt;&lt;br&gt;&lt;br&gt;&lt;b&gt;Until &#34;
                        &#34;you&#39;ve played enough games for the system to learn &#34;
                        &#34;your skill level, you&#39;ll be matched randomly.&lt;/b&gt;&lt;br&gt;&#34;
                        &#34;Afterwards, you&#39;ll be more reliably matched up with &#34;
                        &#34;people of your skill level: so don&#39;t worry if your &#34;
                        &#34;first few games are uneven. This will improve as you &#34;
                        &#34;play!&lt;/b&gt;&#34;
                    )
                })
            elif deviation &gt; 250:
                progress = (500.0 - deviation) / 2.5
                player.write_message({
                    &#34;command&#34;: &#34;notice&#34;,
                    &#34;style&#34;: &#34;info&#34;,
                    &#34;text&#34;: (
                        &#34;The matchmaking system is calibrating your skill level; &#34;
                        &#34;your first few games may be slightly more imbalanced &#34;
                        &#34;as the system attempts to learn your capability as a player.&#34;
                        &#34;&lt;br&gt;&lt;br&gt;&#34;
                        f&#34;&lt;b&gt;The learning phase is {progress:.0f}% completed&lt;/b&gt;&#34;
                    )
                })

    def on_match_found(
        self,
        s1: Search,
        s2: Search,
        queue: MatchmakerQueue
    ) -&gt; None:
        &#34;&#34;&#34;
        Callback for when a match is generated by a matchmaker queue.

        NOTE: This function is called while the matchmaker search lock is held,
        so it should only perform fast operations.
        &#34;&#34;&#34;
        try:
            msg = {&#34;command&#34;: &#34;match_found&#34;, &#34;queue_name&#34;: queue.name}

            for player in s1.players + s2.players:
                player.state = PlayerState.STARTING_AUTOMATCH
                player.write_message(msg)

                # Cancel any other searches
                queue_names = list(
                    name for name in self._searches[player].keys()
                    if name != queue.name
                )
                for queue_name in queue_names:
                    self._cancel_search(player, queue_name)

                self._clear_search(player, queue.name)

            asyncio.create_task(
                self.start_game(s1.players, s2.players, queue)
            )
        except Exception:
            self._logger.exception(
                &#34;Error processing match between searches %s, and %s&#34;,
                s1, s2
            )

    async def start_game(
        self,
        team1: List[Player],
        team2: List[Player],
        queue: MatchmakerQueue
    ) -&gt; None:
        assert len(team1) == len(team2)

        self._logger.debug(
            &#34;Starting %s game between %s and %s&#34;,
            queue.name,
            [p.login for p in team1],
            [p.login for p in team2]
        )
        game = None
        try:
            host = team1[0]
            all_players = team1 + team2
            all_guests = all_players[1:]

            played_map_ids = await self.get_game_history(
                all_players,
                queue.id,
                limit=config.LADDER_ANTI_REPETITION_LIMIT
            )
            rating = min(
                newbie_adjusted_mean(player, queue.rating_type)
                for player in all_players
            )
            pool = queue.get_map_pool_for_rating(rating)
            if not pool:
                raise RuntimeError(f&#34;No map pool available for rating {rating}!&#34;)
            _, _, map_path, _ = pool.choose_map(played_map_ids)

            game = self.game_service.create_game(
                game_class=LadderGame,
                game_mode=queue.featured_mod,
                host=host,
                name=&#34;Matchmaker Game&#34;,
                matchmaker_queue_id=queue.id,
                rating_type=queue.rating_type,
                max_players=len(all_players)
            )
            game.init_mode = InitMode.AUTO_LOBBY
            game.map_file_path = map_path
            game.set_name_unchecked(game_name(team1, team2))

            def get_player_mean(player):
                return player.ratings[queue.rating_type][0]

            team1 = sorted(team1, key=get_player_mean)
            team2 = sorted(team2, key=get_player_mean)

            # Shuffle the teams such that direct opponents remain the same
            zipped_teams = list(zip(team1, team2))
            random.shuffle(zipped_teams)

            for i, player in enumerate(
                player for pair in zipped_teams for player in pair
            ):
                # FA uses lua and lua arrays are 1-indexed
                slot = i + 1
                # 2 if even, 3 if odd
                team = (i % 2) + 2
                player.game = game

                game.set_player_option(player.id, &#34;Faction&#34;, player.faction.value)
                game.set_player_option(player.id, &#34;Team&#34;, team)
                game.set_player_option(player.id, &#34;StartSpot&#34;, slot)
                game.set_player_option(player.id, &#34;Army&#34;, slot)
                game.set_player_option(player.id, &#34;Color&#34;, slot)

            mapname = re.match(&#34;maps/(.+).zip&#34;, map_path).group(1)
            # FIXME: Database filenames contain the maps/ prefix and .zip suffix.
            # Really in the future, just send a better description

            self._logger.debug(&#34;Starting ladder game: %s&#34;, game)
            # Options shared by all players
            options = GameLaunchOptions(
                mapname=mapname,
                expected_players=len(all_players),
            )

            def game_options(player: Player) -&gt; GameLaunchOptions:
                return options._replace(
                    team=game.get_player_option(player.id, &#34;Team&#34;),
                    faction=player.faction,
                    map_position=game.get_player_option(player.id, &#34;StartSpot&#34;)
                )

            await host.lobby_connection.launch_game(
                game, is_host=True, options=game_options(host)
            )
            try:
                await game.wait_hosted(60)
            finally:
                # TODO: Once the client supports `match_cancelled`, don&#39;t
                # send `launch_game` to the client if the host timed out. Until
                # then, failing to send `launch_game` will cause the client to
                # think it is searching for ladder, even though the server has
                # already removed it from the queue.

                await asyncio.gather(*[
                    guest.lobby_connection.launch_game(
                        game, is_host=False, options=game_options(guest)
                    )
                    for guest in all_guests
                    if guest.lobby_connection is not None
                ])
            await game.wait_launched(60 + 10 * len(all_guests))
            self._logger.debug(&#34;Ladder game launched successfully&#34;)
        except Exception:
            if game:
                await game.on_game_end()
            self._logger.exception(&#34;Failed to start ladder game!&#34;)

            msg = {&#34;command&#34;: &#34;match_cancelled&#34;}
            for player in all_players:
                if player.state == PlayerState.STARTING_AUTOMATCH:
                    player.state = PlayerState.IDLE
                player.write_message(msg)

    async def get_game_history(
        self,
        players: List[Player],
        queue_id: int,
        limit: int = 3
    ) -&gt; List[int]:
        async with self._db.acquire() as conn:
            result = []
            for player in players:
                query = select([
                    game_stats.c.mapId,
                ]).select_from(
                    game_player_stats
                    .join(game_stats)
                    .join(matchmaker_queue_game)
                ).where(
                    and_(
                        game_player_stats.c.playerId == player.id,
                        game_stats.c.startTime &gt;= func.DATE_SUB(
                            func.now(),
                            text(&#34;interval 1 day&#34;)
                        ),
                        matchmaker_queue_game.c.matchmaker_queue_id == queue_id
                    )
                ).order_by(game_stats.c.startTime.desc()).limit(limit)

                result.extend([
                    row.mapId async for row in await conn.execute(query)
                ])
        return result

    def on_connection_lost(self, conn: &#34;LobbyConnection&#34;) -&gt; None:
        if not conn.player:
            return

        player = conn.player
        self.cancel_search(player)
        del self._searches[player]
        if player in self._informed_players:
            self._informed_players.remove(player)

    async def shutdown(self):
        for queue in self.queues.values():
            queue.shutdown()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="server.core.service.Service" href="core/service.html#server.core.service.Service">Service</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="server.LadderService.services"><code class="name">var <span class="ident">services</span> : Dict[str, type]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="server.LadderService.cancel_search"><code class="name flex">
<span>def <span class="ident">cancel_search</span></span>(<span>self, initiator: <a title="server.players.Player" href="players.html#server.players.Player">Player</a>, queue_name: Union[str, NoneType] = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cancel_search(
    self,
    initiator: Player,
    queue_name: Optional[str] = None
) -&gt; None:
    if queue_name is None:
        queue_names = list(self._searches[initiator].keys())
    else:
        queue_names = [queue_name]

    for queue_name in queue_names:
        self._cancel_search(initiator, queue_name)</code></pre>
</details>
</dd>
<dt id="server.LadderService.fetch_map_pools"><code class="name flex">
<span>async def <span class="ident">fetch_map_pools</span></span>(<span>self, conn) ‑> Dict[int, Tuple[str, List[<a title="server.types.Map" href="types.html#server.types.Map">Map</a>]]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def fetch_map_pools(self, conn) -&gt; Dict[int, Tuple[str, List[Map]]]:
    result = await conn.execute(
        select([
            map_pool.c.id,
            map_pool.c.name,
            map_pool_map_version.c.weight,
            map_pool_map_version.c.map_params,
            map_version.c.map_id,
            map_version.c.filename,
            t_map.c.display_name
        ]).select_from(
            map_pool.outerjoin(map_pool_map_version)
            .outerjoin(map_version)
            .outerjoin(t_map)
        )
    )
    map_pool_maps = {}
    async for row in result:
        id_ = row.id
        name = row.name
        if id_ not in map_pool_maps:
            map_pool_maps[id_] = (name, list())
        _, map_list = map_pool_maps[id_]
        if row.map_id is not None:
            map_list.append(
                Map(row.map_id, row.display_name, row.filename, row.weight)
            )
        elif row.map_params is not None:
            try:
                params = json.loads(row.map_params)
                map_type = params[&#34;type&#34;]
                if map_type == &#34;neroxis&#34;:
                    map_list.append(NeroxisGeneratedMap.of(params, row.weight))
                else:
                    self._logger.warning(
                        &#34;Unsupported map type %s in pool %s&#34;,
                         map_type,
                         row.id
                    )

            except Exception:
                self._logger.warning(
                    &#34;Failed to load map in map pool %d &#34;
                    &#34;parameters specified as %s&#34;,
                    row.id,
                    row.map_params,
                    exc_info=True
                )

    return map_pool_maps</code></pre>
</details>
</dd>
<dt id="server.LadderService.fetch_matchmaker_queues"><code class="name flex">
<span>async def <span class="ident">fetch_matchmaker_queues</span></span>(<span>self, conn)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def fetch_matchmaker_queues(self, conn):
    result = await conn.execute(
        select([
            matchmaker_queue.c.id,
            matchmaker_queue.c.technical_name,
            matchmaker_queue.c.team_size,
            matchmaker_queue_map_pool.c.map_pool_id,
            matchmaker_queue_map_pool.c.min_rating,
            matchmaker_queue_map_pool.c.max_rating,
            game_featuredMods.c.gamemod,
            leaderboard.c.technical_name.label(&#34;rating_type&#34;)
        ])
        .select_from(
            matchmaker_queue
            .join(matchmaker_queue_map_pool)
            .join(game_featuredMods)
            .join(leaderboard)
        ).where(matchmaker_queue.c.enabled == true())
    )
    matchmaker_queues = defaultdict(lambda: defaultdict(list))
    async for row in result:
        name = row.technical_name
        info = matchmaker_queues[name]
        info[&#34;id&#34;] = row.id
        info[&#34;mod&#34;] = row.gamemod
        info[&#34;rating_type&#34;] = row.rating_type
        info[&#34;team_size&#34;] = row.team_size
        info[&#34;map_pools&#34;].append((
            row.map_pool_id,
            row.min_rating,
            row.max_rating
        ))
    return matchmaker_queues</code></pre>
</details>
</dd>
<dt id="server.LadderService.get_game_history"><code class="name flex">
<span>async def <span class="ident">get_game_history</span></span>(<span>self, players: List[<a title="server.players.Player" href="players.html#server.players.Player">Player</a>], queue_id: int, limit: int = 3) ‑> List[int]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_game_history(
    self,
    players: List[Player],
    queue_id: int,
    limit: int = 3
) -&gt; List[int]:
    async with self._db.acquire() as conn:
        result = []
        for player in players:
            query = select([
                game_stats.c.mapId,
            ]).select_from(
                game_player_stats
                .join(game_stats)
                .join(matchmaker_queue_game)
            ).where(
                and_(
                    game_player_stats.c.playerId == player.id,
                    game_stats.c.startTime &gt;= func.DATE_SUB(
                        func.now(),
                        text(&#34;interval 1 day&#34;)
                    ),
                    matchmaker_queue_game.c.matchmaker_queue_id == queue_id
                )
            ).order_by(game_stats.c.startTime.desc()).limit(limit)

            result.extend([
                row.mapId async for row in await conn.execute(query)
            ])
    return result</code></pre>
</details>
</dd>
<dt id="server.LadderService.on_match_found"><code class="name flex">
<span>def <span class="ident">on_match_found</span></span>(<span>self, s1: <a title="server.matchmaker.search.Search" href="matchmaker/search.html#server.matchmaker.search.Search">Search</a>, s2: <a title="server.matchmaker.search.Search" href="matchmaker/search.html#server.matchmaker.search.Search">Search</a>, queue: <a title="server.matchmaker.matchmaker_queue.MatchmakerQueue" href="matchmaker/matchmaker_queue.html#server.matchmaker.matchmaker_queue.MatchmakerQueue">MatchmakerQueue</a>) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Callback for when a match is generated by a matchmaker queue.</p>
<p>NOTE: This function is called while the matchmaker search lock is held,
so it should only perform fast operations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_match_found(
    self,
    s1: Search,
    s2: Search,
    queue: MatchmakerQueue
) -&gt; None:
    &#34;&#34;&#34;
    Callback for when a match is generated by a matchmaker queue.

    NOTE: This function is called while the matchmaker search lock is held,
    so it should only perform fast operations.
    &#34;&#34;&#34;
    try:
        msg = {&#34;command&#34;: &#34;match_found&#34;, &#34;queue_name&#34;: queue.name}

        for player in s1.players + s2.players:
            player.state = PlayerState.STARTING_AUTOMATCH
            player.write_message(msg)

            # Cancel any other searches
            queue_names = list(
                name for name in self._searches[player].keys()
                if name != queue.name
            )
            for queue_name in queue_names:
                self._cancel_search(player, queue_name)

            self._clear_search(player, queue.name)

        asyncio.create_task(
            self.start_game(s1.players, s2.players, queue)
        )
    except Exception:
        self._logger.exception(
            &#34;Error processing match between searches %s, and %s&#34;,
            s1, s2
        )</code></pre>
</details>
</dd>
<dt id="server.LadderService.start_game"><code class="name flex">
<span>async def <span class="ident">start_game</span></span>(<span>self, team1: List[<a title="server.players.Player" href="players.html#server.players.Player">Player</a>], team2: List[<a title="server.players.Player" href="players.html#server.players.Player">Player</a>], queue: <a title="server.matchmaker.matchmaker_queue.MatchmakerQueue" href="matchmaker/matchmaker_queue.html#server.matchmaker.matchmaker_queue.MatchmakerQueue">MatchmakerQueue</a>) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def start_game(
    self,
    team1: List[Player],
    team2: List[Player],
    queue: MatchmakerQueue
) -&gt; None:
    assert len(team1) == len(team2)

    self._logger.debug(
        &#34;Starting %s game between %s and %s&#34;,
        queue.name,
        [p.login for p in team1],
        [p.login for p in team2]
    )
    game = None
    try:
        host = team1[0]
        all_players = team1 + team2
        all_guests = all_players[1:]

        played_map_ids = await self.get_game_history(
            all_players,
            queue.id,
            limit=config.LADDER_ANTI_REPETITION_LIMIT
        )
        rating = min(
            newbie_adjusted_mean(player, queue.rating_type)
            for player in all_players
        )
        pool = queue.get_map_pool_for_rating(rating)
        if not pool:
            raise RuntimeError(f&#34;No map pool available for rating {rating}!&#34;)
        _, _, map_path, _ = pool.choose_map(played_map_ids)

        game = self.game_service.create_game(
            game_class=LadderGame,
            game_mode=queue.featured_mod,
            host=host,
            name=&#34;Matchmaker Game&#34;,
            matchmaker_queue_id=queue.id,
            rating_type=queue.rating_type,
            max_players=len(all_players)
        )
        game.init_mode = InitMode.AUTO_LOBBY
        game.map_file_path = map_path
        game.set_name_unchecked(game_name(team1, team2))

        def get_player_mean(player):
            return player.ratings[queue.rating_type][0]

        team1 = sorted(team1, key=get_player_mean)
        team2 = sorted(team2, key=get_player_mean)

        # Shuffle the teams such that direct opponents remain the same
        zipped_teams = list(zip(team1, team2))
        random.shuffle(zipped_teams)

        for i, player in enumerate(
            player for pair in zipped_teams for player in pair
        ):
            # FA uses lua and lua arrays are 1-indexed
            slot = i + 1
            # 2 if even, 3 if odd
            team = (i % 2) + 2
            player.game = game

            game.set_player_option(player.id, &#34;Faction&#34;, player.faction.value)
            game.set_player_option(player.id, &#34;Team&#34;, team)
            game.set_player_option(player.id, &#34;StartSpot&#34;, slot)
            game.set_player_option(player.id, &#34;Army&#34;, slot)
            game.set_player_option(player.id, &#34;Color&#34;, slot)

        mapname = re.match(&#34;maps/(.+).zip&#34;, map_path).group(1)
        # FIXME: Database filenames contain the maps/ prefix and .zip suffix.
        # Really in the future, just send a better description

        self._logger.debug(&#34;Starting ladder game: %s&#34;, game)
        # Options shared by all players
        options = GameLaunchOptions(
            mapname=mapname,
            expected_players=len(all_players),
        )

        def game_options(player: Player) -&gt; GameLaunchOptions:
            return options._replace(
                team=game.get_player_option(player.id, &#34;Team&#34;),
                faction=player.faction,
                map_position=game.get_player_option(player.id, &#34;StartSpot&#34;)
            )

        await host.lobby_connection.launch_game(
            game, is_host=True, options=game_options(host)
        )
        try:
            await game.wait_hosted(60)
        finally:
            # TODO: Once the client supports `match_cancelled`, don&#39;t
            # send `launch_game` to the client if the host timed out. Until
            # then, failing to send `launch_game` will cause the client to
            # think it is searching for ladder, even though the server has
            # already removed it from the queue.

            await asyncio.gather(*[
                guest.lobby_connection.launch_game(
                    game, is_host=False, options=game_options(guest)
                )
                for guest in all_guests
                if guest.lobby_connection is not None
            ])
        await game.wait_launched(60 + 10 * len(all_guests))
        self._logger.debug(&#34;Ladder game launched successfully&#34;)
    except Exception:
        if game:
            await game.on_game_end()
        self._logger.exception(&#34;Failed to start ladder game!&#34;)

        msg = {&#34;command&#34;: &#34;match_cancelled&#34;}
        for player in all_players:
            if player.state == PlayerState.STARTING_AUTOMATCH:
                player.state = PlayerState.IDLE
            player.write_message(msg)</code></pre>
</details>
</dd>
<dt id="server.LadderService.start_search"><code class="name flex">
<span>def <span class="ident">start_search</span></span>(<span>self, players: List[<a title="server.players.Player" href="players.html#server.players.Player">Player</a>], queue_name: str, on_matched: Callable[[ForwardRef('Search'), ForwardRef('Search')], Any] = &lt;function LadderService.&lt;lambda&gt;&gt;)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_search(
    self,
    players: List[Player],
    queue_name: str,
    on_matched: OnMatchedCallback = lambda _1, _2: None
):
    # Cancel any existing searches that players have for this queue
    for player in players:
        if queue_name in self._searches[player]:
            self._cancel_search(player, queue_name)

    queue = self.queues[queue_name]
    search = Search(
        players,
        rating_type=queue.rating_type,
        on_matched=on_matched
    )

    for player in players:
        player.state = PlayerState.SEARCHING_LADDER

        self.write_rating_progress(player, queue.rating_type)

        player.write_message({
            &#34;command&#34;: &#34;search_info&#34;,
            &#34;queue_name&#34;: queue_name,
            &#34;state&#34;: &#34;start&#34;
        })

        self._searches[player][queue_name] = search

    self._logger.info(&#34;%s started searching for %s&#34;, search, queue_name)

    asyncio.create_task(queue.search(search))</code></pre>
</details>
</dd>
<dt id="server.LadderService.update_data"><code class="name flex">
<span>async def <span class="ident">update_data</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def update_data(self) -&gt; None:
    async with self._db.acquire() as conn:
        map_pool_maps = await self.fetch_map_pools(conn)
        db_queues = await self.fetch_matchmaker_queues(conn)

    for name, info in db_queues.items():
        if name not in self.queues:
            queue = MatchmakerQueue(
                self.game_service,
                self.on_match_found,
                name=name,
                queue_id=info[&#34;id&#34;],
                featured_mod=info[&#34;mod&#34;],
                rating_type=info[&#34;rating_type&#34;],
                team_size=info[&#34;team_size&#34;],
            )
            self.queues[name] = queue
            queue.initialize()
        else:
            queue = self.queues[name]
            queue.featured_mod = info[&#34;mod&#34;]
            queue.rating_type = info[&#34;rating_type&#34;]
            queue.team_size = info[&#34;team_size&#34;]
        queue.map_pools.clear()
        for map_pool_id, min_rating, max_rating in info[&#34;map_pools&#34;]:
            map_pool_name, map_list = map_pool_maps[map_pool_id]
            if not map_list:
                self._logger.warning(
                    &#34;Map pool &#39;%s&#39; is empty! Some %s games will &#34;
                    &#34;likely fail to start!&#34;,
                    map_pool_name,
                    name
                )
            queue.add_map_pool(
                MapPool(map_pool_id, map_pool_name, map_list),
                min_rating,
                max_rating
            )
    # Remove queues that don&#39;t exist anymore
    for queue_name in list(self.queues.keys()):
        if queue_name not in db_queues:
            self.queues[queue_name].shutdown()
            del self.queues[queue_name]</code></pre>
</details>
</dd>
<dt id="server.LadderService.write_rating_progress"><code class="name flex">
<span>def <span class="ident">write_rating_progress</span></span>(<span>self, player: <a title="server.players.Player" href="players.html#server.players.Player">Player</a>, rating_type: str) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_rating_progress(self, player: Player, rating_type: str) -&gt; None:
    if player not in self._informed_players:
        self._informed_players.add(player)
        _, deviation = player.ratings[rating_type]

        if deviation &gt; 490:
            player.write_message({
                &#34;command&#34;: &#34;notice&#34;,
                &#34;style&#34;: &#34;info&#34;,
                &#34;text&#34;: (
                    &#34;&lt;i&gt;Welcome to the matchmaker&lt;/i&gt;&lt;br&gt;&lt;br&gt;&lt;b&gt;Until &#34;
                    &#34;you&#39;ve played enough games for the system to learn &#34;
                    &#34;your skill level, you&#39;ll be matched randomly.&lt;/b&gt;&lt;br&gt;&#34;
                    &#34;Afterwards, you&#39;ll be more reliably matched up with &#34;
                    &#34;people of your skill level: so don&#39;t worry if your &#34;
                    &#34;first few games are uneven. This will improve as you &#34;
                    &#34;play!&lt;/b&gt;&#34;
                )
            })
        elif deviation &gt; 250:
            progress = (500.0 - deviation) / 2.5
            player.write_message({
                &#34;command&#34;: &#34;notice&#34;,
                &#34;style&#34;: &#34;info&#34;,
                &#34;text&#34;: (
                    &#34;The matchmaking system is calibrating your skill level; &#34;
                    &#34;your first few games may be slightly more imbalanced &#34;
                    &#34;as the system attempts to learn your capability as a player.&#34;
                    &#34;&lt;br&gt;&lt;br&gt;&#34;
                    f&#34;&lt;b&gt;The learning phase is {progress:.0f}% completed&lt;/b&gt;&#34;
                )
            })</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="server.core.service.Service" href="core/service.html#server.core.service.Service">Service</a></b></code>:
<ul class="hlist">
<li><code><a title="server.core.service.Service.initialize" href="core/service.html#server.core.service.Service.initialize">initialize</a></code></li>
<li><code><a title="server.core.service.Service.on_connection_lost" href="core/service.html#server.core.service.Service.on_connection_lost">on_connection_lost</a></code></li>
<li><code><a title="server.core.service.Service.shutdown" href="core/service.html#server.core.service.Service.shutdown">shutdown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="server.MessageQueueService"><code class="flex name class">
<span>class <span class="ident">MessageQueueService</span></span>
</code></dt>
<dd>
<div class="desc"><p>All services should inherit from this class.</p>
<p>Services are singleton objects which manage some server task.</p>
<p>Service handling connection to the message queue
and providing an interface to publish messages.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MessageQueueService(Service):
    def __init__(self) -&gt; None:
        &#34;&#34;&#34;
        Service handling connection to the message queue
        and providing an interface to publish messages.
        &#34;&#34;&#34;
        self._logger.debug(&#34;Message queue service created.&#34;)
        self._connection = None
        self._channel = None
        self._exchanges = {}
        self._exchange_types = {}
        self._is_ready = False

        config.register_callback(&#34;MQ_USER&#34;, self.reconnect)
        config.register_callback(&#34;MQ_PASSWORD&#34;, self.reconnect)
        config.register_callback(&#34;MQ_VHOST&#34;, self.reconnect)
        config.register_callback(&#34;MQ_SERVER&#34;, self.reconnect)
        config.register_callback(&#34;MQ_PORT&#34;, self.reconnect)

    @synchronizedmethod(&#34;initialization_lock&#34;)
    async def initialize(self) -&gt; None:
        if self._is_ready:
            return

        try:
            await self._connect()
        except ConnectionAttemptFailed:
            return
        self._is_ready = True

    async def _connect(self) -&gt; None:
        try:
            self._connection = await aio_pika.connect_robust(
                &#34;amqp://{user}:{password}@{server}:{port}/{vhost}&#34;.format(
                    user=config.MQ_USER,
                    password=config.MQ_PASSWORD,
                    vhost=config.MQ_VHOST,
                    server=config.MQ_SERVER,
                    port=config.MQ_PORT,
                ),
                loop=asyncio.get_running_loop(),
            )
        except ConnectionError as e:
            self._logger.warning(
                &#34;Unable to connect to RabbitMQ. Is it running?&#34;, exc_info=True
            )
            raise ConnectionAttemptFailed from e
        except ProbableAuthenticationError as e:
            self._logger.warning(
                &#34;Unable to connect to RabbitMQ. Incorrect credentials?&#34;, exc_info=True
            )
            raise ConnectionAttemptFailed from e
        except Exception as e:
            self._logger.warning(
                &#34;Unable to connect to RabbitMQ due to unhandled excpetion %s. Incorrect vhost?&#34;,
                e,
                exc_info=True,
            )
            raise ConnectionAttemptFailed from e

        self._channel = await self._connection.channel(publisher_confirms=False)
        self._logger.debug(&#34;Connected to RabbitMQ %r&#34;, self._connection)

    async def declare_exchange(
        self, exchange_name: str, exchange_type: ExchangeType = ExchangeType.TOPIC
    ) -&gt; None:
        await self.initialize()
        if not self._is_ready:
            self._logger.warning(
                &#34;Not connected to RabbitMQ, unable to declare exchange.&#34;
            )
            return

        await self._declare_exchange(exchange_name, exchange_type)

    async def _declare_exchange(
        self, exchange_name: str, exchange_type: ExchangeType
    ) -&gt; None:
        new_exchange = await self._channel.declare_exchange(
            exchange_name, exchange_type
        )

        self._exchanges[exchange_name] = new_exchange
        self._exchange_types[exchange_name] = exchange_type

    @synchronizedmethod(&#34;initialization_lock&#34;)
    async def shutdown(self) -&gt; None:
        self._is_ready = False
        await self._shutdown()

    async def _shutdown(self) -&gt; None:
        if self._channel is not None:
            await self._channel.close()
            self._channel = None

        if self._connection is not None:
            await self._connection.close()
            self._connection = None

    async def publish(
        self,
        exchange_name: str,
        routing: str,
        payload: Dict,
        delivery_mode: DeliveryMode = DeliveryMode.PERSISTENT,
    ) -&gt; None:
        if not self._is_ready:
            self._logger.warning(
                &#34;Not connected to RabbitMQ, unable to publish message.&#34;
            )
            return

        exchange = self._exchanges.get(exchange_name)
        if exchange is None:
            raise KeyError(f&#34;Unknown exchange {exchange_name}.&#34;)

        message = aio_pika.Message(
            json.dumps(payload).encode(), delivery_mode=delivery_mode
        )

        async with self._channel.transaction():
            await exchange.publish(message, routing_key=routing)
            self._logger.log(
                TRACE, &#34;Published message %s to %s/%s&#34;, payload, exchange_name, routing
            )

    @synchronizedmethod(&#34;initialization_lock&#34;)
    async def reconnect(self) -&gt; None:
        self._is_ready = False
        await self._shutdown()

        try:
            await self._connect()
        except ConnectionAttemptFailed:
            return

        for exchange_name in list(self._exchanges.keys()):
            await self._declare_exchange(
                exchange_name, self._exchange_types[exchange_name]
            )
        self._is_ready = True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="server.core.service.Service" href="core/service.html#server.core.service.Service">Service</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="server.MessageQueueService.services"><code class="name">var <span class="ident">services</span> : Dict[str, type]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="server.MessageQueueService.declare_exchange"><code class="name flex">
<span>async def <span class="ident">declare_exchange</span></span>(<span>self, exchange_name: str, exchange_type: aio_pika.exchange.ExchangeType = ExchangeType.TOPIC) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def declare_exchange(
    self, exchange_name: str, exchange_type: ExchangeType = ExchangeType.TOPIC
) -&gt; None:
    await self.initialize()
    if not self._is_ready:
        self._logger.warning(
            &#34;Not connected to RabbitMQ, unable to declare exchange.&#34;
        )
        return

    await self._declare_exchange(exchange_name, exchange_type)</code></pre>
</details>
</dd>
<dt id="server.MessageQueueService.publish"><code class="name flex">
<span>async def <span class="ident">publish</span></span>(<span>self, exchange_name: str, routing: str, payload: Dict, delivery_mode: aio_pika.message.DeliveryMode = DeliveryMode.PERSISTENT) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def publish(
    self,
    exchange_name: str,
    routing: str,
    payload: Dict,
    delivery_mode: DeliveryMode = DeliveryMode.PERSISTENT,
) -&gt; None:
    if not self._is_ready:
        self._logger.warning(
            &#34;Not connected to RabbitMQ, unable to publish message.&#34;
        )
        return

    exchange = self._exchanges.get(exchange_name)
    if exchange is None:
        raise KeyError(f&#34;Unknown exchange {exchange_name}.&#34;)

    message = aio_pika.Message(
        json.dumps(payload).encode(), delivery_mode=delivery_mode
    )

    async with self._channel.transaction():
        await exchange.publish(message, routing_key=routing)
        self._logger.log(
            TRACE, &#34;Published message %s to %s/%s&#34;, payload, exchange_name, routing
        )</code></pre>
</details>
</dd>
<dt id="server.MessageQueueService.reconnect"><code class="name flex">
<span>async def <span class="ident">reconnect</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@synchronizedmethod(&#34;initialization_lock&#34;)
async def reconnect(self) -&gt; None:
    self._is_ready = False
    await self._shutdown()

    try:
        await self._connect()
    except ConnectionAttemptFailed:
        return

    for exchange_name in list(self._exchanges.keys()):
        await self._declare_exchange(
            exchange_name, self._exchange_types[exchange_name]
        )
    self._is_ready = True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="server.core.service.Service" href="core/service.html#server.core.service.Service">Service</a></b></code>:
<ul class="hlist">
<li><code><a title="server.core.service.Service.initialize" href="core/service.html#server.core.service.Service.initialize">initialize</a></code></li>
<li><code><a title="server.core.service.Service.on_connection_lost" href="core/service.html#server.core.service.Service.on_connection_lost">on_connection_lost</a></code></li>
<li><code><a title="server.core.service.Service.shutdown" href="core/service.html#server.core.service.Service.shutdown">shutdown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="server.PartyService"><code class="flex name class">
<span>class <span class="ident">PartyService</span></span>
<span>(</span><span>game_service: <a title="server.game_service.GameService" href="game_service.html#server.game_service.GameService">GameService</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Service responsible for managing the player parties.</p>
<p>Logically, we consider players to always be in a party, either alone, or
with other players.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PartyService(Service):
    &#34;&#34;&#34;
    Service responsible for managing the player parties.

    Logically, we consider players to always be in a party, either alone, or
    with other players.
    &#34;&#34;&#34;

    def __init__(self, game_service: GameService):
        self.game_service = game_service
        self.player_parties: Dict[Player, PlayerParty] = {}
        self._dirty_parties: Set[PlayerParty] = set()

    async def initialize(self):
        self._update_task = at_interval(1, self.update_dirties)

    async def shutdown(self):
        self._update_task.stop()

    async def update_dirties(self):
        if not self._dirty_parties:
            return

        dirty_parties = self._dirty_parties
        self._dirty_parties = set()

        for party in dirty_parties:
            try:
                self.write_broadcast_party(party)
            except Exception:  # pragma: no cover
                self._logger.exception(
                    &#34;Unexpected exception while sending party updates!&#34;
                )

    def write_broadcast_party(self, party, members=None):
        &#34;&#34;&#34;
        Send a party update to all players in the party
        &#34;&#34;&#34;
        if not members:
            members = iter(party)
        msg = {
            &#34;command&#34;: &#34;update_party&#34;,
            **party.to_dict()
        }
        for member in members:
            # Will re-encode the message for each player
            member.player.write_message(msg)

    def get_party(self, owner: Player) -&gt; PlayerParty:
        party = self.player_parties.get(owner)
        if not party:
            party = PlayerParty(owner)
            self.player_parties[owner] = party

        return party

    def mark_dirty(self, party: PlayerParty):
        self._dirty_parties.add(party)

    def invite_player_to_party(self, sender: Player, recipient: Player):
        &#34;&#34;&#34;
        Creates a new party for `sender` if one doesn&#39;t exist, and invites
        `recipient` to that party.
        &#34;&#34;&#34;
        if sender not in self.player_parties:
            self.player_parties[sender] = PlayerParty(sender)

        party = self.player_parties[sender]

        if party.owner != sender:
            raise ClientError(&#34;You do not own this party.&#34;, recoverable=True)

        party.add_invited_player(recipient)
        recipient.write_message({
            &#34;command&#34;: &#34;party_invite&#34;,
            &#34;sender&#34;: sender.id
        })

    async def accept_invite(self, recipient: Player, sender: Player):
        party = self.player_parties.get(sender)
        if (
            not party or
            recipient not in party.invited_players or
            party.invited_players[recipient].is_expired()
        ):
            # TODO: Localize with a proper message
            raise ClientError(&#34;You are not invited to that party (anymore)&#34;, recoverable=True)

        if sender.state is PlayerState.SEARCHING_LADDER:
            # TODO: Localize with a proper message
            raise ClientError(&#34;That party is already in queue&#34;, recoverable=True)

        old_party = self.player_parties.get(recipient)
        if old_party is not None:
            # Preserve state (like faction selection) from the old party
            member = old_party.get_member_by_player(recipient)
            assert member is not None

            await self.leave_party(recipient)
            party.add_member(member)
        else:
            party.add_player(recipient)

        self.player_parties[recipient] = party
        self.mark_dirty(party)

    async def kick_player_from_party(self, owner: Player, kicked_player: Player):
        if owner not in self.player_parties:
            raise ClientError(&#34;You are not in a party.&#34;, recoverable=True)

        party = self.player_parties[owner]

        if party.owner != owner:
            raise ClientError(&#34;You do not own that party.&#34;, recoverable=True)

        if kicked_player not in party:
            # Client state appears to be out of date
            await party.send_party(owner)
            return

        party.remove_player(kicked_player)
        del self.player_parties[kicked_player]

        kicked_player.write_message({&#34;command&#34;: &#34;kicked_from_party&#34;})

        self.mark_dirty(party)

    async def leave_party(self, player: Player):
        if player not in self.player_parties:
            raise ClientError(&#34;You are not in a party.&#34;, recoverable=True)

        party = self.player_parties[player]
        self._remove_player_from_party(player, party)
        # TODO: Remove?
        await party.send_party(player)

    def _remove_player_from_party(self, player, party):
        party.remove_player(player)
        del self.player_parties[player]

        if party.is_disbanded():
            self.remove_party(party)
            return

        self.mark_dirty(party)

    def set_factions(self, player: Player, factions: List[Faction]):
        if player not in self.player_parties:
            self.player_parties[player] = PlayerParty(player)

        party = self.player_parties[player]
        party.set_factions(player, factions)
        self.mark_dirty(party)

    def remove_party(self, party):
        # Remove all players who were in the party
        self._logger.info(&#34;Removing party: %s&#34;, party.members)
        for member in party:
            self._logger.info(&#34;Removing party for player %s&#34;, member.player)
            if party == self.player_parties.get(member.player):
                del self.player_parties[member.player]
            else:
                self._logger.warning(
                    &#34;Player %s was in two parties at once!&#34;, member.player
                )

        members = party.members
        party.clear()
        # TODO: Send a special &#34;disbanded&#34; command?
        self.write_broadcast_party(party, members=members)

    def on_connection_lost(self, conn: &#34;LobbyConnection&#34;) -&gt; None:
        if not conn.player or conn.player not in self.player_parties:
            return

        self._remove_player_from_party(
            conn.player,
            self.player_parties[conn.player]
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="server.core.service.Service" href="core/service.html#server.core.service.Service">Service</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="server.PartyService.services"><code class="name">var <span class="ident">services</span> : Dict[str, type]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="server.PartyService.accept_invite"><code class="name flex">
<span>async def <span class="ident">accept_invite</span></span>(<span>self, recipient: <a title="server.players.Player" href="players.html#server.players.Player">Player</a>, sender: <a title="server.players.Player" href="players.html#server.players.Player">Player</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def accept_invite(self, recipient: Player, sender: Player):
    party = self.player_parties.get(sender)
    if (
        not party or
        recipient not in party.invited_players or
        party.invited_players[recipient].is_expired()
    ):
        # TODO: Localize with a proper message
        raise ClientError(&#34;You are not invited to that party (anymore)&#34;, recoverable=True)

    if sender.state is PlayerState.SEARCHING_LADDER:
        # TODO: Localize with a proper message
        raise ClientError(&#34;That party is already in queue&#34;, recoverable=True)

    old_party = self.player_parties.get(recipient)
    if old_party is not None:
        # Preserve state (like faction selection) from the old party
        member = old_party.get_member_by_player(recipient)
        assert member is not None

        await self.leave_party(recipient)
        party.add_member(member)
    else:
        party.add_player(recipient)

    self.player_parties[recipient] = party
    self.mark_dirty(party)</code></pre>
</details>
</dd>
<dt id="server.PartyService.get_party"><code class="name flex">
<span>def <span class="ident">get_party</span></span>(<span>self, owner: <a title="server.players.Player" href="players.html#server.players.Player">Player</a>) ‑> <a title="server.team_matchmaker.player_party.PlayerParty" href="team_matchmaker/player_party.html#server.team_matchmaker.player_party.PlayerParty">PlayerParty</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_party(self, owner: Player) -&gt; PlayerParty:
    party = self.player_parties.get(owner)
    if not party:
        party = PlayerParty(owner)
        self.player_parties[owner] = party

    return party</code></pre>
</details>
</dd>
<dt id="server.PartyService.invite_player_to_party"><code class="name flex">
<span>def <span class="ident">invite_player_to_party</span></span>(<span>self, sender: <a title="server.players.Player" href="players.html#server.players.Player">Player</a>, recipient: <a title="server.players.Player" href="players.html#server.players.Player">Player</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new party for <code>sender</code> if one doesn't exist, and invites
<code>recipient</code> to that party.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def invite_player_to_party(self, sender: Player, recipient: Player):
    &#34;&#34;&#34;
    Creates a new party for `sender` if one doesn&#39;t exist, and invites
    `recipient` to that party.
    &#34;&#34;&#34;
    if sender not in self.player_parties:
        self.player_parties[sender] = PlayerParty(sender)

    party = self.player_parties[sender]

    if party.owner != sender:
        raise ClientError(&#34;You do not own this party.&#34;, recoverable=True)

    party.add_invited_player(recipient)
    recipient.write_message({
        &#34;command&#34;: &#34;party_invite&#34;,
        &#34;sender&#34;: sender.id
    })</code></pre>
</details>
</dd>
<dt id="server.PartyService.kick_player_from_party"><code class="name flex">
<span>async def <span class="ident">kick_player_from_party</span></span>(<span>self, owner: <a title="server.players.Player" href="players.html#server.players.Player">Player</a>, kicked_player: <a title="server.players.Player" href="players.html#server.players.Player">Player</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def kick_player_from_party(self, owner: Player, kicked_player: Player):
    if owner not in self.player_parties:
        raise ClientError(&#34;You are not in a party.&#34;, recoverable=True)

    party = self.player_parties[owner]

    if party.owner != owner:
        raise ClientError(&#34;You do not own that party.&#34;, recoverable=True)

    if kicked_player not in party:
        # Client state appears to be out of date
        await party.send_party(owner)
        return

    party.remove_player(kicked_player)
    del self.player_parties[kicked_player]

    kicked_player.write_message({&#34;command&#34;: &#34;kicked_from_party&#34;})

    self.mark_dirty(party)</code></pre>
</details>
</dd>
<dt id="server.PartyService.leave_party"><code class="name flex">
<span>async def <span class="ident">leave_party</span></span>(<span>self, player: <a title="server.players.Player" href="players.html#server.players.Player">Player</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def leave_party(self, player: Player):
    if player not in self.player_parties:
        raise ClientError(&#34;You are not in a party.&#34;, recoverable=True)

    party = self.player_parties[player]
    self._remove_player_from_party(player, party)
    # TODO: Remove?
    await party.send_party(player)</code></pre>
</details>
</dd>
<dt id="server.PartyService.mark_dirty"><code class="name flex">
<span>def <span class="ident">mark_dirty</span></span>(<span>self, party: <a title="server.team_matchmaker.player_party.PlayerParty" href="team_matchmaker/player_party.html#server.team_matchmaker.player_party.PlayerParty">PlayerParty</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mark_dirty(self, party: PlayerParty):
    self._dirty_parties.add(party)</code></pre>
</details>
</dd>
<dt id="server.PartyService.remove_party"><code class="name flex">
<span>def <span class="ident">remove_party</span></span>(<span>self, party)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_party(self, party):
    # Remove all players who were in the party
    self._logger.info(&#34;Removing party: %s&#34;, party.members)
    for member in party:
        self._logger.info(&#34;Removing party for player %s&#34;, member.player)
        if party == self.player_parties.get(member.player):
            del self.player_parties[member.player]
        else:
            self._logger.warning(
                &#34;Player %s was in two parties at once!&#34;, member.player
            )

    members = party.members
    party.clear()
    # TODO: Send a special &#34;disbanded&#34; command?
    self.write_broadcast_party(party, members=members)</code></pre>
</details>
</dd>
<dt id="server.PartyService.set_factions"><code class="name flex">
<span>def <span class="ident">set_factions</span></span>(<span>self, player: <a title="server.players.Player" href="players.html#server.players.Player">Player</a>, factions: List[<a title="server.factions.Faction" href="factions.html#server.factions.Faction">Faction</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_factions(self, player: Player, factions: List[Faction]):
    if player not in self.player_parties:
        self.player_parties[player] = PlayerParty(player)

    party = self.player_parties[player]
    party.set_factions(player, factions)
    self.mark_dirty(party)</code></pre>
</details>
</dd>
<dt id="server.PartyService.update_dirties"><code class="name flex">
<span>async def <span class="ident">update_dirties</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def update_dirties(self):
    if not self._dirty_parties:
        return

    dirty_parties = self._dirty_parties
    self._dirty_parties = set()

    for party in dirty_parties:
        try:
            self.write_broadcast_party(party)
        except Exception:  # pragma: no cover
            self._logger.exception(
                &#34;Unexpected exception while sending party updates!&#34;
            )</code></pre>
</details>
</dd>
<dt id="server.PartyService.write_broadcast_party"><code class="name flex">
<span>def <span class="ident">write_broadcast_party</span></span>(<span>self, party, members=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Send a party update to all players in the party</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_broadcast_party(self, party, members=None):
    &#34;&#34;&#34;
    Send a party update to all players in the party
    &#34;&#34;&#34;
    if not members:
        members = iter(party)
    msg = {
        &#34;command&#34;: &#34;update_party&#34;,
        **party.to_dict()
    }
    for member in members:
        # Will re-encode the message for each player
        member.player.write_message(msg)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="server.core.service.Service" href="core/service.html#server.core.service.Service">Service</a></b></code>:
<ul class="hlist">
<li><code><a title="server.core.service.Service.initialize" href="core/service.html#server.core.service.Service.initialize">initialize</a></code></li>
<li><code><a title="server.core.service.Service.on_connection_lost" href="core/service.html#server.core.service.Service.on_connection_lost">on_connection_lost</a></code></li>
<li><code><a title="server.core.service.Service.shutdown" href="core/service.html#server.core.service.Service.shutdown">shutdown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="server.RatingService"><code class="flex name class">
<span>class <span class="ident">RatingService</span></span>
<span>(</span><span>database: <a title="server.db.FAFDatabase" href="db/index.html#server.db.FAFDatabase">FAFDatabase</a>, player_service: <a title="server.player_service.PlayerService" href="player_service.html#server.player_service.PlayerService">PlayerService</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Service responsible for calculating and saving trueskill rating updates.
To avoid race conditions, rating updates from a single game ought to be
atomic.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RatingService(Service):
    &#34;&#34;&#34;
    Service responsible for calculating and saving trueskill rating updates.
    To avoid race conditions, rating updates from a single game ought to be
    atomic.
    &#34;&#34;&#34;

    def __init__(self, database: FAFDatabase, player_service: PlayerService):
        self._db = database
        self._player_service_callback = player_service.signal_player_rating_change
        self._accept_input = False
        self._queue = asyncio.Queue()
        self._task = None
        self._rating_type_ids = None

    async def initialize(self) -&gt; None:
        if self._task is not None:
            self._logger.error(&#34;Service already runnning or not properly shut down.&#34;)
            return

        await self.update_data()
        self._update_cron = aiocron.crontab(&#34;*/10 * * * *&#34;, func=self.update_data)
        self._accept_input = True
        self._logger.debug(&#34;RatingService starting...&#34;)
        self._task = asyncio.create_task(self._handle_rating_queue())

    async def update_data(self):
        async with self._db.acquire() as conn:
            sql = select([leaderboard])
            result = await conn.execute(sql)
            rows = await result.fetchall()

        self._rating_type_ids = RatingTypeMap(
            None,
            ((row[&#34;technical_name&#34;], row[&#34;id&#34;]) for row in rows)
        )

    async def enqueue(self, game_info: Dict) -&gt; None:
        if not self._accept_input:
            self._logger.warning(&#34;Dropped rating request %s&#34;, game_info)
            raise ServiceNotReadyError(
                &#34;RatingService not yet initialized or shutting down.&#34;
            )

        summary = GameRatingSummary.from_game_info_dict(game_info)
        self._logger.debug(&#34;Queued up rating request %s&#34;, summary)
        await self._queue.put(summary)
        rating_service_backlog.set(self._queue.qsize())

    async def _handle_rating_queue(self) -&gt; None:
        self._logger.debug(&#34;RatingService started!&#34;)
        try:
            while self._accept_input or not self._queue.empty():
                summary = await self._queue.get()
                self._logger.debug(&#34;Now rating request %s&#34;, summary)

                try:
                    await self._rate(summary)
                except GameRatingError:
                    self._logger.warning(&#34;Error rating game %s&#34;, summary)
                except Exception:  # pragma: no cover
                    self._logger.exception(&#34;Failed rating request %s&#34;, summary)
                else:
                    self._logger.debug(&#34;Done rating request.&#34;)

                self._queue.task_done()
                rating_service_backlog.set(self._queue.qsize())
        except asyncio.CancelledError:
            pass
        except Exception:
            self._logger.critical(
                &#34;Unexpected exception while handling rating queue.&#34;,
                exc_info=True
            )

        self._logger.debug(&#34;RatingService stopped.&#34;)

    async def _rate(self, summary: GameRatingSummary) -&gt; None:
        rating_data = await self._get_rating_data(summary)
        new_ratings = GameRater.compute_rating(rating_data)

        outcome_map = {
            player_id: team.outcome
            for team in summary.teams
            for player_id in team.player_ids
        }

        old_ratings = {
            player_id: rating
            for team in rating_data
            for player_id, rating in team.ratings.items()
        }
        await self._persist_rating_changes(
            summary.game_id, summary.rating_type, old_ratings, new_ratings, outcome_map
        )

    async def _get_rating_data(self, summary: GameRatingSummary) -&gt; GameRatingData:
        ratings = {}
        for team in summary.teams:
            for player_id in team.player_ids:
                ratings[player_id] = await self._get_player_rating(
                    player_id, summary.rating_type
                )

        return [
            TeamRatingData(
                team.outcome,
                {player_id: ratings[player_id] for player_id in team.player_ids},
            )
            for team in summary.teams
        ]

    async def _get_player_rating(
        self, player_id: int, rating_type: str
    ) -&gt; Rating:
        if self._rating_type_ids is None:
            self._logger.warning(
                &#34;Tried to fetch player data before initializing service.&#34;
            )
            raise ServiceNotReadyError(&#34;RatingService not yet initialized.&#34;)

        rating_type_id = self._rating_type_ids.get(rating_type)
        if rating_type_id is None:
            raise ValueError(f&#34;Unknown rating type {rating_type}.&#34;)

        async with self._db.acquire() as conn:
            sql = select(
                [leaderboard_rating.c.mean, leaderboard_rating.c.deviation]
            ).where(
                and_(
                    leaderboard_rating.c.login_id == player_id,
                    leaderboard_rating.c.leaderboard_id == rating_type_id,
                )
            )

            result = await conn.execute(sql)
            row = await result.fetchone()

            if not row:
                try:
                    return await self._get_player_legacy_rating(
                        conn, player_id, rating_type
                    )
                except ValueError:
                    return await self._create_default_rating(
                        conn, player_id, rating_type
                    )

        return Rating(row[&#34;mean&#34;], row[&#34;deviation&#34;])

    async def _get_player_legacy_rating(
        self, conn, player_id: int, rating_type: str
    ) -&gt; Rating:
        if rating_type == RatingType.GLOBAL:
            table = global_rating
            sql = select([table.c.mean, table.c.deviation, table.c.numGames]).where(
                table.c.id == player_id
            )
        elif rating_type == RatingType.LADDER_1V1:
            table = ladder1v1_rating
            sql = select(
                [table.c.mean, table.c.deviation, table.c.numGames, table.c.winGames]
            ).where(table.c.id == player_id)
        else:
            raise ValueError(f&#34;Unknown rating type {rating_type}.&#34;)

        result = await conn.execute(sql)
        row = await result.fetchone()

        if not row:
            return await self._create_default_rating(
                conn, player_id, rating_type
            )

        if rating_type == RatingType.GLOBAL:
            won_games = int(row[&#34;numGames&#34;] / 2)
        else:
            won_games = row[&#34;winGames&#34;]

        insertion_sql = leaderboard_rating.insert().values(
            login_id=player_id,
            mean=row[&#34;mean&#34;],
            deviation=row[&#34;deviation&#34;],
            total_games=row[&#34;numGames&#34;],
            won_games=won_games,
            leaderboard_id=self._rating_type_ids[rating_type],
        )
        await conn.execute(insertion_sql)

        return Rating(row[&#34;mean&#34;], row[&#34;deviation&#34;])

    async def _create_default_rating(
        self, conn, player_id: int, rating_type: str
    ):
        default_mean = config.START_RATING_MEAN
        default_deviation = config.START_RATING_DEV
        rating_type_id = self._rating_type_ids.get(rating_type)

        insertion_sql = leaderboard_rating.insert().values(
            login_id=player_id,
            mean=default_mean,
            deviation=default_deviation,
            total_games=0,
            won_games=0,
            leaderboard_id=rating_type_id,
        )
        await conn.execute(insertion_sql)

        return Rating(default_mean, default_deviation)

    async def _persist_rating_changes(
        self,
        game_id: int,
        rating_type: str,
        old_ratings: Dict[PlayerID, Rating],
        new_ratings: Dict[PlayerID, Rating],
        outcomes: Dict[PlayerID, GameOutcome],
    ) -&gt; None:
        &#34;&#34;&#34;
        Persist computed ratings to the respective players&#39; selected rating
        &#34;&#34;&#34;
        self._logger.debug(&#34;Saving rating change stats for game %i&#34;, game_id)

        async with self._db.acquire() as conn:
            for player_id, new_rating in new_ratings.items():
                old_rating = old_ratings[player_id]
                self._logger.debug(
                    &#34;New %s rating for player with id %s: %s -&gt; %s&#34;,
                    rating_type,
                    player_id,
                    old_rating,
                    new_rating,
                )

                gps_update_sql = (
                    game_player_stats.update()
                    .where(
                        and_(
                            game_player_stats.c.playerId == player_id,
                            game_player_stats.c.gameId == game_id,
                        )
                    )
                    .values(
                        after_mean=new_rating.mu,
                        after_deviation=new_rating.sigma,
                        mean=old_rating.mu,
                        deviation=old_rating.sigma,
                        scoreTime=func.now(),
                    )
                )
                result = await conn.execute(gps_update_sql)

                if not result.rowcount:
                    self._logger.warning(&#34;gps_update_sql resultset is empty for game_id %i&#34;, game_id)
                    return

                rating_type_id = self._rating_type_ids[rating_type]

                journal_insert_sql = leaderboard_rating_journal.insert().values(
                    leaderboard_id=rating_type_id,
                    rating_mean_before=old_rating.mu,
                    rating_deviation_before=old_rating.sigma,
                    rating_mean_after=new_rating.mu,
                    rating_deviation_after=new_rating.sigma,
                    game_player_stats_id=select([game_player_stats.c.id]).where(
                        and_(
                            game_player_stats.c.playerId == player_id,
                            game_player_stats.c.gameId == game_id,
                        )
                    ),
                )
                await conn.execute(journal_insert_sql)

                victory_increment = (
                    1 if outcomes[player_id] is GameOutcome.VICTORY else 0
                )
                rating_update_sql = (
                    leaderboard_rating.update()
                    .where(
                        and_(
                            leaderboard_rating.c.login_id == player_id,
                            leaderboard_rating.c.leaderboard_id == rating_type_id,
                        )
                    )
                    .values(
                        mean=new_rating.mu,
                        deviation=new_rating.sigma,
                        total_games=leaderboard_rating.c.total_games + 1,
                        won_games=leaderboard_rating.c.won_games + victory_increment,
                    )
                )
                await conn.execute(rating_update_sql)

                self._update_player_object(player_id, rating_type, new_rating)

    def _update_player_object(
        self, player_id: PlayerID, rating_type: RatingType, new_rating: Rating
    ) -&gt; None:
        if self._player_service_callback is None:
            self._logger.warning(
                &#34;Tried to send rating change to player service, &#34;
                &#34;but no service was registered.&#34;
            )
            return

        self._logger.debug(
            &#34;Sending player rating update for player with id %i&#34;, player_id
        )
        self._player_service_callback(player_id, rating_type, new_rating)

    async def _join_rating_queue(self) -&gt; None:
        &#34;&#34;&#34;
        Offers a call that is blocking until the rating queue has been emptied.
        Mostly for testing purposes.
        &#34;&#34;&#34;
        await self._queue.join()

    async def shutdown(self) -&gt; None:
        &#34;&#34;&#34;
        Finish rating all remaining games, then exit.
        &#34;&#34;&#34;
        self._accept_input = False
        self._logger.debug(
            &#34;Shutdown initiated. Waiting on current queue: %s&#34;, self._queue
        )
        await self._queue.join()
        self._task = None
        self._logger.debug(&#34;Queue emptied: %s&#34;, self._queue)

    def kill(self) -&gt; None:
        &#34;&#34;&#34;
        Exit without waiting for the queue to join.
        &#34;&#34;&#34;
        self._accept_input = False
        if self._task is not None:
            self._task.cancel()
            self._task = None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="server.core.service.Service" href="core/service.html#server.core.service.Service">Service</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="server.RatingService.services"><code class="name">var <span class="ident">services</span> : Dict[str, type]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="server.RatingService.enqueue"><code class="name flex">
<span>async def <span class="ident">enqueue</span></span>(<span>self, game_info: Dict) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def enqueue(self, game_info: Dict) -&gt; None:
    if not self._accept_input:
        self._logger.warning(&#34;Dropped rating request %s&#34;, game_info)
        raise ServiceNotReadyError(
            &#34;RatingService not yet initialized or shutting down.&#34;
        )

    summary = GameRatingSummary.from_game_info_dict(game_info)
    self._logger.debug(&#34;Queued up rating request %s&#34;, summary)
    await self._queue.put(summary)
    rating_service_backlog.set(self._queue.qsize())</code></pre>
</details>
</dd>
<dt id="server.RatingService.kill"><code class="name flex">
<span>def <span class="ident">kill</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Exit without waiting for the queue to join.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kill(self) -&gt; None:
    &#34;&#34;&#34;
    Exit without waiting for the queue to join.
    &#34;&#34;&#34;
    self._accept_input = False
    if self._task is not None:
        self._task.cancel()
        self._task = None</code></pre>
</details>
</dd>
<dt id="server.RatingService.shutdown"><code class="name flex">
<span>async def <span class="ident">shutdown</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Finish rating all remaining games, then exit.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def shutdown(self) -&gt; None:
    &#34;&#34;&#34;
    Finish rating all remaining games, then exit.
    &#34;&#34;&#34;
    self._accept_input = False
    self._logger.debug(
        &#34;Shutdown initiated. Waiting on current queue: %s&#34;, self._queue
    )
    await self._queue.join()
    self._task = None
    self._logger.debug(&#34;Queue emptied: %s&#34;, self._queue)</code></pre>
</details>
</dd>
<dt id="server.RatingService.update_data"><code class="name flex">
<span>async def <span class="ident">update_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def update_data(self):
    async with self._db.acquire() as conn:
        sql = select([leaderboard])
        result = await conn.execute(sql)
        rows = await result.fetchall()

    self._rating_type_ids = RatingTypeMap(
        None,
        ((row[&#34;technical_name&#34;], row[&#34;id&#34;]) for row in rows)
    )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="server.core.service.Service" href="core/service.html#server.core.service.Service">Service</a></b></code>:
<ul class="hlist">
<li><code><a title="server.core.service.Service.initialize" href="core/service.html#server.core.service.Service.initialize">initialize</a></code></li>
<li><code><a title="server.core.service.Service.on_connection_lost" href="core/service.html#server.core.service.Service.on_connection_lost">on_connection_lost</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="server.ServerInstance"><code class="flex name class">
<span>class <span class="ident">ServerInstance</span></span>
<span>(</span><span>name: str, database: <a title="server.db.FAFDatabase" href="db/index.html#server.db.FAFDatabase">FAFDatabase</a>, api_accessor: Union[<a title="server.api.api_accessor.ApiAccessor" href="api/api_accessor.html#server.api.api_accessor.ApiAccessor">ApiAccessor</a>, NoneType], twilio_nts: Union[<a title="server.ice_servers.nts.TwilioNTS" href="ice_servers/nts.html#server.ice_servers.nts.TwilioNTS">TwilioNTS</a>, NoneType], loop: asyncio.base_events.BaseEventLoop)</span>
</code></dt>
<dd>
<div class="desc"><p>A class representing a shared server state. Each ServerInstance may be
exposed on multiple ports, but each port will share the same internal server
state, i.e. the same players, games, etc.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ServerInstance(object):
    &#34;&#34;&#34;
        A class representing a shared server state. Each ServerInstance may be
    exposed on multiple ports, but each port will share the same internal server
    state, i.e. the same players, games, etc.
    &#34;&#34;&#34;

    def __init__(
        self,
        name: str,
        database: FAFDatabase,
        api_accessor: Optional[ApiAccessor],
        twilio_nts: Optional[TwilioNTS],
        loop: asyncio.BaseEventLoop,
        # For testing
        _override_services: Optional[Dict[str, Service]] = None
    ):
        self.name = name
        self._logger = logging.getLogger(self.name)
        self.database = database
        self.api_accessor = api_accessor
        self.twilio_nts = twilio_nts
        self.loop = loop

        self.started = False

        self.contexts: Set[ServerContext] = set()

        self.services = _override_services or create_services({
            &#34;database&#34;: self.database,
            &#34;api_accessor&#34;: self.api_accessor,
            &#34;loop&#34;: self.loop,
        })

        self.connection_factory = lambda: LobbyConnection(
            database=database,
            geoip=self.services[&#34;geo_ip_service&#34;],
            game_service=self.services[&#34;game_service&#34;],
            nts_client=twilio_nts,
            players=self.services[&#34;player_service&#34;],
            ladder_service=self.services[&#34;ladder_service&#34;],
            party_service=self.services[&#34;party_service&#34;]
        )

    def write_broadcast(self, message, predicate=lambda conn: conn.authenticated):
        self._logger.log(TRACE, &#34;]]: %s&#34;, message)
        metrics.server_broadcasts.inc()

        for ctx in self.contexts:
            try:
                ctx.write_broadcast(message, predicate)
            except Exception:
                self._logger.exception(
                    &#34;Error writing &#39;%s&#39;&#34;,
                    message.get(&#34;command&#34;, message)
                )

    @synchronizedmethod
    async def _start_services(self) -&gt; None:
        if self.started:
            return

        await asyncio.gather(*[
            service.initialize() for service in self.services.values()
        ])

        game_service: GameService = self.services[&#34;game_service&#34;]
        player_service: PlayerService = self.services[&#34;player_service&#34;]

        @at_interval(DIRTY_REPORT_INTERVAL, loop=self.loop)
        def do_report_dirties():
            game_service.update_active_game_metrics()
            dirty_games = game_service.dirty_games
            dirty_queues = game_service.dirty_queues
            dirty_players = player_service.dirty_players
            game_service.clear_dirty()
            player_service.clear_dirty()

            if dirty_queues:
                self.write_broadcast({
                    &#34;command&#34;: &#34;matchmaker_info&#34;,
                    &#34;queues&#34;: [queue.to_dict() for queue in dirty_queues]
                })

            if dirty_players:
                self.write_broadcast(
                    {
                        &#34;command&#34;: &#34;player_info&#34;,
                        &#34;players&#34;: [player.to_dict() for player in dirty_players]
                    },
                    lambda lobby_conn: lobby_conn.authenticated
                )

            # TODO: This spams squillions of messages: we should implement per-
            # connection message aggregation at the next abstraction layer down :P
            for game in dirty_games:
                if game.state == GameState.ENDED:
                    game_service.remove_game(game)

                # So we&#39;re going to be broadcasting this to _somebody_...
                message = game.to_dict()

                self.write_broadcast(
                    message,
                    lambda conn: (
                        conn.authenticated
                        and game.is_visible_to_player(conn.player)
                    )
                )

        @at_interval(45, loop=self.loop)
        def ping_broadcast():
            self.write_broadcast({&#34;command&#34;: &#34;ping&#34;})

        self.started = True

    async def listen(
        self,
        address: Tuple[str, int],
        protocol_class: Type[Protocol] = QDataStreamProtocol
    ) -&gt; ServerContext:
        &#34;&#34;&#34;
        Start listening on a new address.
        &#34;&#34;&#34;
        if not self.started:
            await self._start_services()

        ctx = ServerContext(
            f&#34;{self.name}[{protocol_class.__name__}]&#34;,
            self.connection_factory,
            list(self.services.values()),
            protocol_class
        )
        self.contexts.add(ctx)

        await ctx.listen(*address)

        return ctx

    async def shutdown(self):
        for ctx in self.contexts:
            ctx.close()

        for ctx in self.contexts:
            try:
                await ctx.wait_closed()
            except Exception:
                self._logger.error(
                    &#34;Encountered unexpected error when trying to shut down &#34;
                    &#34;context %s&#34;,
                    ctx
                )

        await asyncio.gather(*[
            service.shutdown() for service in self.services.values()
        ])

        self.started = False</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="server.ServerInstance.listen"><code class="name flex">
<span>async def <span class="ident">listen</span></span>(<span>self, address: Tuple[str, int], protocol_class: Type[<a title="server.protocol.protocol.Protocol" href="protocol/protocol.html#server.protocol.protocol.Protocol">Protocol</a>] = server.protocol.qdatastream.QDataStreamProtocol) ‑> <a title="server.servercontext.ServerContext" href="servercontext.html#server.servercontext.ServerContext">ServerContext</a></span>
</code></dt>
<dd>
<div class="desc"><p>Start listening on a new address.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def listen(
    self,
    address: Tuple[str, int],
    protocol_class: Type[Protocol] = QDataStreamProtocol
) -&gt; ServerContext:
    &#34;&#34;&#34;
    Start listening on a new address.
    &#34;&#34;&#34;
    if not self.started:
        await self._start_services()

    ctx = ServerContext(
        f&#34;{self.name}[{protocol_class.__name__}]&#34;,
        self.connection_factory,
        list(self.services.values()),
        protocol_class
    )
    self.contexts.add(ctx)

    await ctx.listen(*address)

    return ctx</code></pre>
</details>
</dd>
<dt id="server.ServerInstance.shutdown"><code class="name flex">
<span>async def <span class="ident">shutdown</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def shutdown(self):
    for ctx in self.contexts:
        ctx.close()

    for ctx in self.contexts:
        try:
            await ctx.wait_closed()
        except Exception:
            self._logger.error(
                &#34;Encountered unexpected error when trying to shut down &#34;
                &#34;context %s&#34;,
                ctx
            )

    await asyncio.gather(*[
        service.shutdown() for service in self.services.values()
    ])

    self.started = False</code></pre>
</details>
</dd>
<dt id="server.ServerInstance.write_broadcast"><code class="name flex">
<span>def <span class="ident">write_broadcast</span></span>(<span>self, message, predicate=&lt;function ServerInstance.&lt;lambda&gt;&gt;)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_broadcast(self, message, predicate=lambda conn: conn.authenticated):
    self._logger.log(TRACE, &#34;]]: %s&#34;, message)
    metrics.server_broadcasts.inc()

    for ctx in self.contexts:
        try:
            ctx.write_broadcast(message, predicate)
        except Exception:
            self._logger.exception(
                &#34;Error writing &#39;%s&#39;&#34;,
                message.get(&#34;command&#34;, message)
            )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="server.abc" href="abc/index.html">server.abc</a></code></li>
<li><code><a title="server.api" href="api/index.html">server.api</a></code></li>
<li><code><a title="server.asyncio_extensions" href="asyncio_extensions.html">server.asyncio_extensions</a></code></li>
<li><code><a title="server.config" href="config.html">server.config</a></code></li>
<li><code><a title="server.configuration_service" href="configuration_service.html">server.configuration_service</a></code></li>
<li><code><a title="server.control" href="control.html">server.control</a></code></li>
<li><code><a title="server.core" href="core/index.html">server.core</a></code></li>
<li><code><a title="server.db" href="db/index.html">server.db</a></code></li>
<li><code><a title="server.decorators" href="decorators.html">server.decorators</a></code></li>
<li><code><a title="server.exceptions" href="exceptions.html">server.exceptions</a></code></li>
<li><code><a title="server.factions" href="factions.html">server.factions</a></code></li>
<li><code><a title="server.game_service" href="game_service.html">server.game_service</a></code></li>
<li><code><a title="server.gameconnection" href="gameconnection.html">server.gameconnection</a></code></li>
<li><code><a title="server.games" href="games/index.html">server.games</a></code></li>
<li><code><a title="server.geoip_service" href="geoip_service.html">server.geoip_service</a></code></li>
<li><code><a title="server.ice_servers" href="ice_servers/index.html">server.ice_servers</a></code></li>
<li><code><a title="server.ladder_service" href="ladder_service.html">server.ladder_service</a></code></li>
<li><code><a title="server.lobbyconnection" href="lobbyconnection.html">server.lobbyconnection</a></code></li>
<li><code><a title="server.matchmaker" href="matchmaker/index.html">server.matchmaker</a></code></li>
<li><code><a title="server.message_queue_service" href="message_queue_service.html">server.message_queue_service</a></code></li>
<li><code><a title="server.metrics" href="metrics.html">server.metrics</a></code></li>
<li><code><a title="server.party_service" href="party_service.html">server.party_service</a></code></li>
<li><code><a title="server.player_service" href="player_service.html">server.player_service</a></code></li>
<li><code><a title="server.players" href="players.html">server.players</a></code></li>
<li><code><a title="server.profiler" href="profiler.html">server.profiler</a></code></li>
<li><code><a title="server.protocol" href="protocol/index.html">server.protocol</a></code></li>
<li><code><a title="server.rating" href="rating.html">server.rating</a></code></li>
<li><code><a title="server.rating_service" href="rating_service/index.html">server.rating_service</a></code></li>
<li><code><a title="server.servercontext" href="servercontext.html">server.servercontext</a></code></li>
<li><code><a title="server.stats" href="stats/index.html">server.stats</a></code></li>
<li><code><a title="server.team_matchmaker" href="team_matchmaker/index.html">server.team_matchmaker</a></code></li>
<li><code><a title="server.timing" href="timing/index.html">server.timing</a></code></li>
<li><code><a title="server.types" href="types.html">server.types</a></code></li>
<li><code><a title="server.weakattr" href="weakattr.html">server.weakattr</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="server.run_control_server" href="#server.run_control_server">run_control_server</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="server.ConfigurationService" href="#server.ConfigurationService">ConfigurationService</a></code></h4>
<ul class="">
<li><code><a title="server.ConfigurationService.services" href="#server.ConfigurationService.services">services</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="server.GameConnection" href="#server.GameConnection">GameConnection</a></code></h4>
<ul class="">
<li><code><a title="server.GameConnection.abort" href="#server.GameConnection.abort">abort</a></code></li>
<li><code><a title="server.GameConnection.connect_to_host" href="#server.GameConnection.connect_to_host">connect_to_host</a></code></li>
<li><code><a title="server.GameConnection.connect_to_peer" href="#server.GameConnection.connect_to_peer">connect_to_peer</a></code></li>
<li><code><a title="server.GameConnection.disconnect_all_peers" href="#server.GameConnection.disconnect_all_peers">disconnect_all_peers</a></code></li>
<li><code><a title="server.GameConnection.game" href="#server.GameConnection.game">game</a></code></li>
<li><code><a title="server.GameConnection.handle_action" href="#server.GameConnection.handle_action">handle_action</a></code></li>
<li><code><a title="server.GameConnection.handle_ai_option" href="#server.GameConnection.handle_ai_option">handle_ai_option</a></code></li>
<li><code><a title="server.GameConnection.handle_bottleneck" href="#server.GameConnection.handle_bottleneck">handle_bottleneck</a></code></li>
<li><code><a title="server.GameConnection.handle_bottleneck_cleared" href="#server.GameConnection.handle_bottleneck_cleared">handle_bottleneck_cleared</a></code></li>
<li><code><a title="server.GameConnection.handle_chat" href="#server.GameConnection.handle_chat">handle_chat</a></code></li>
<li><code><a title="server.GameConnection.handle_clear_slot" href="#server.GameConnection.handle_clear_slot">handle_clear_slot</a></code></li>
<li><code><a title="server.GameConnection.handle_desync" href="#server.GameConnection.handle_desync">handle_desync</a></code></li>
<li><code><a title="server.GameConnection.handle_disconnected" href="#server.GameConnection.handle_disconnected">handle_disconnected</a></code></li>
<li><code><a title="server.GameConnection.handle_enforce_rating" href="#server.GameConnection.handle_enforce_rating">handle_enforce_rating</a></code></li>
<li><code><a title="server.GameConnection.handle_game_ended" href="#server.GameConnection.handle_game_ended">handle_game_ended</a></code></li>
<li><code><a title="server.GameConnection.handle_game_full" href="#server.GameConnection.handle_game_full">handle_game_full</a></code></li>
<li><code><a title="server.GameConnection.handle_game_mods" href="#server.GameConnection.handle_game_mods">handle_game_mods</a></code></li>
<li><code><a title="server.GameConnection.handle_game_option" href="#server.GameConnection.handle_game_option">handle_game_option</a></code></li>
<li><code><a title="server.GameConnection.handle_game_result" href="#server.GameConnection.handle_game_result">handle_game_result</a></code></li>
<li><code><a title="server.GameConnection.handle_game_state" href="#server.GameConnection.handle_game_state">handle_game_state</a></code></li>
<li><code><a title="server.GameConnection.handle_ice_message" href="#server.GameConnection.handle_ice_message">handle_ice_message</a></code></li>
<li><code><a title="server.GameConnection.handle_json_stats" href="#server.GameConnection.handle_json_stats">handle_json_stats</a></code></li>
<li><code><a title="server.GameConnection.handle_operation_complete" href="#server.GameConnection.handle_operation_complete">handle_operation_complete</a></code></li>
<li><code><a title="server.GameConnection.handle_player_option" href="#server.GameConnection.handle_player_option">handle_player_option</a></code></li>
<li><code><a title="server.GameConnection.handle_rehost" href="#server.GameConnection.handle_rehost">handle_rehost</a></code></li>
<li><code><a title="server.GameConnection.handle_teamkill_happened" href="#server.GameConnection.handle_teamkill_happened">handle_teamkill_happened</a></code></li>
<li><code><a title="server.GameConnection.handle_teamkill_report" href="#server.GameConnection.handle_teamkill_report">handle_teamkill_report</a></code></li>
<li><code><a title="server.GameConnection.is_host" href="#server.GameConnection.is_host">is_host</a></code></li>
<li><code><a title="server.GameConnection.on_connection_lost" href="#server.GameConnection.on_connection_lost">on_connection_lost</a></code></li>
<li><code><a title="server.GameConnection.player" href="#server.GameConnection.player">player</a></code></li>
<li><code><a title="server.GameConnection.send" href="#server.GameConnection.send">send</a></code></li>
<li><code><a title="server.GameConnection.state" href="#server.GameConnection.state">state</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="server.GameService" href="#server.GameService">GameService</a></code></h4>
<ul class="">
<li><code><a title="server.GameService.all_games" href="#server.GameService.all_games">all_games</a></code></li>
<li><code><a title="server.GameService.clear_dirty" href="#server.GameService.clear_dirty">clear_dirty</a></code></li>
<li><code><a title="server.GameService.create_game" href="#server.GameService.create_game">create_game</a></code></li>
<li><code><a title="server.GameService.create_uid" href="#server.GameService.create_uid">create_uid</a></code></li>
<li><code><a title="server.GameService.dirty_games" href="#server.GameService.dirty_games">dirty_games</a></code></li>
<li><code><a title="server.GameService.dirty_queues" href="#server.GameService.dirty_queues">dirty_queues</a></code></li>
<li><code><a title="server.GameService.initialise_game_counter" href="#server.GameService.initialise_game_counter">initialise_game_counter</a></code></li>
<li><code><a title="server.GameService.live_games" href="#server.GameService.live_games">live_games</a></code></li>
<li><code><a title="server.GameService.mark_dirty" href="#server.GameService.mark_dirty">mark_dirty</a></code></li>
<li><code><a title="server.GameService.open_games" href="#server.GameService.open_games">open_games</a></code></li>
<li><code><a title="server.GameService.pending_games" href="#server.GameService.pending_games">pending_games</a></code></li>
<li><code><a title="server.GameService.publish_game_results" href="#server.GameService.publish_game_results">publish_game_results</a></code></li>
<li><code><a title="server.GameService.remove_game" href="#server.GameService.remove_game">remove_game</a></code></li>
<li><code><a title="server.GameService.services" href="#server.GameService.services">services</a></code></li>
<li><code><a title="server.GameService.update_active_game_metrics" href="#server.GameService.update_active_game_metrics">update_active_game_metrics</a></code></li>
<li><code><a title="server.GameService.update_data" href="#server.GameService.update_data">update_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="server.GameStatsService" href="#server.GameStatsService">GameStatsService</a></code></h4>
<ul class="">
<li><code><a title="server.GameStatsService.process_game_stats" href="#server.GameStatsService.process_game_stats">process_game_stats</a></code></li>
<li><code><a title="server.GameStatsService.services" href="#server.GameStatsService.services">services</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="server.GeoIpService" href="#server.GeoIpService">GeoIpService</a></code></h4>
<ul class="">
<li><code><a title="server.GeoIpService.check_geoip_db_file_updated" href="#server.GeoIpService.check_geoip_db_file_updated">check_geoip_db_file_updated</a></code></li>
<li><code><a title="server.GeoIpService.check_update_geoip_db" href="#server.GeoIpService.check_update_geoip_db">check_update_geoip_db</a></code></li>
<li><code><a title="server.GeoIpService.country" href="#server.GeoIpService.country">country</a></code></li>
<li><code><a title="server.GeoIpService.download_geoip_db" href="#server.GeoIpService.download_geoip_db">download_geoip_db</a></code></li>
<li><code><a title="server.GeoIpService.load_db" href="#server.GeoIpService.load_db">load_db</a></code></li>
<li><code><a title="server.GeoIpService.refresh_file_path" href="#server.GeoIpService.refresh_file_path">refresh_file_path</a></code></li>
<li><code><a title="server.GeoIpService.services" href="#server.GeoIpService.services">services</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="server.LadderService" href="#server.LadderService">LadderService</a></code></h4>
<ul class="">
<li><code><a title="server.LadderService.cancel_search" href="#server.LadderService.cancel_search">cancel_search</a></code></li>
<li><code><a title="server.LadderService.fetch_map_pools" href="#server.LadderService.fetch_map_pools">fetch_map_pools</a></code></li>
<li><code><a title="server.LadderService.fetch_matchmaker_queues" href="#server.LadderService.fetch_matchmaker_queues">fetch_matchmaker_queues</a></code></li>
<li><code><a title="server.LadderService.get_game_history" href="#server.LadderService.get_game_history">get_game_history</a></code></li>
<li><code><a title="server.LadderService.on_match_found" href="#server.LadderService.on_match_found">on_match_found</a></code></li>
<li><code><a title="server.LadderService.services" href="#server.LadderService.services">services</a></code></li>
<li><code><a title="server.LadderService.start_game" href="#server.LadderService.start_game">start_game</a></code></li>
<li><code><a title="server.LadderService.start_search" href="#server.LadderService.start_search">start_search</a></code></li>
<li><code><a title="server.LadderService.update_data" href="#server.LadderService.update_data">update_data</a></code></li>
<li><code><a title="server.LadderService.write_rating_progress" href="#server.LadderService.write_rating_progress">write_rating_progress</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="server.MessageQueueService" href="#server.MessageQueueService">MessageQueueService</a></code></h4>
<ul class="">
<li><code><a title="server.MessageQueueService.declare_exchange" href="#server.MessageQueueService.declare_exchange">declare_exchange</a></code></li>
<li><code><a title="server.MessageQueueService.publish" href="#server.MessageQueueService.publish">publish</a></code></li>
<li><code><a title="server.MessageQueueService.reconnect" href="#server.MessageQueueService.reconnect">reconnect</a></code></li>
<li><code><a title="server.MessageQueueService.services" href="#server.MessageQueueService.services">services</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="server.PartyService" href="#server.PartyService">PartyService</a></code></h4>
<ul class="">
<li><code><a title="server.PartyService.accept_invite" href="#server.PartyService.accept_invite">accept_invite</a></code></li>
<li><code><a title="server.PartyService.get_party" href="#server.PartyService.get_party">get_party</a></code></li>
<li><code><a title="server.PartyService.invite_player_to_party" href="#server.PartyService.invite_player_to_party">invite_player_to_party</a></code></li>
<li><code><a title="server.PartyService.kick_player_from_party" href="#server.PartyService.kick_player_from_party">kick_player_from_party</a></code></li>
<li><code><a title="server.PartyService.leave_party" href="#server.PartyService.leave_party">leave_party</a></code></li>
<li><code><a title="server.PartyService.mark_dirty" href="#server.PartyService.mark_dirty">mark_dirty</a></code></li>
<li><code><a title="server.PartyService.remove_party" href="#server.PartyService.remove_party">remove_party</a></code></li>
<li><code><a title="server.PartyService.services" href="#server.PartyService.services">services</a></code></li>
<li><code><a title="server.PartyService.set_factions" href="#server.PartyService.set_factions">set_factions</a></code></li>
<li><code><a title="server.PartyService.update_dirties" href="#server.PartyService.update_dirties">update_dirties</a></code></li>
<li><code><a title="server.PartyService.write_broadcast_party" href="#server.PartyService.write_broadcast_party">write_broadcast_party</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="server.RatingService" href="#server.RatingService">RatingService</a></code></h4>
<ul class="">
<li><code><a title="server.RatingService.enqueue" href="#server.RatingService.enqueue">enqueue</a></code></li>
<li><code><a title="server.RatingService.kill" href="#server.RatingService.kill">kill</a></code></li>
<li><code><a title="server.RatingService.services" href="#server.RatingService.services">services</a></code></li>
<li><code><a title="server.RatingService.shutdown" href="#server.RatingService.shutdown">shutdown</a></code></li>
<li><code><a title="server.RatingService.update_data" href="#server.RatingService.update_data">update_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="server.ServerInstance" href="#server.ServerInstance">ServerInstance</a></code></h4>
<ul class="">
<li><code><a title="server.ServerInstance.listen" href="#server.ServerInstance.listen">listen</a></code></li>
<li><code><a title="server.ServerInstance.shutdown" href="#server.ServerInstance.shutdown">shutdown</a></code></li>
<li><code><a title="server.ServerInstance.write_broadcast" href="#server.ServerInstance.write_broadcast">write_broadcast</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>